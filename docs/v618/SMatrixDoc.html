<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: SMatrix Class Properties</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SMatrix Class Properties </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The template <a class="el" href="classROOT_1_1Math_1_1SMatrix.html" title="SMatrix: a generic fixed size D1 x D2 Matrix class. ">ROOT::Math::SMatrix</a> class has 4 template parameters which define, at compile time, its properties. These are:</p>
<ul>
<li>type of the contained elements, T, for example <em>float</em> or <em>double</em>;</li>
<li>number of rows;</li>
<li>number of columns;</li>
<li>representation type (<a class="el" href="group__MatRep.html">SMatrix Storage Representation</a>). This is a class describing the underlined storage model of the Matrix. Presently exists only two types of this class:<ol type="1">
<li><a class="el" href="classROOT_1_1Math_1_1MatRepStd.html" title="Expression wrapper class for Matrix objects. ">ROOT::Math::MatRepStd</a> for a general nrows x ncols matrix. This class is itself a template on the contained type T, the number of rows and the number of columns. Its data member is an array T[nrows*ncols] containing the matrix data. The data are stored in the row-major C convention. For example, for a matrix, M, of size 3x3, the data \( \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \) are stored in the following order: <p class="formulaDsp">
\[ M = \left( \begin{array}{ccc} a_0 &amp; a_1 &amp; a_2 \\ a_3 &amp; a_4 &amp; a_5 \\ a_6 &amp; a_7 &amp; a_8 \end{array} \right) \]
</p>
</li>
<li><a class="el" href="classROOT_1_1Math_1_1MatRepSym.html" title="MatRepSym Matrix storage representation for a symmetric matrix of dimension NxN This class is a templ...">ROOT::Math::MatRepSym</a> for a symmetric matrix of size NxN. This class is a template on the contained type and on the symmetric matrix size, N. It has as data member an array of type T of size N*(N+1)/2, containing the lower diagonal block of the matrix. The order follows the lower diagonal block, still in a row-major convention. For example for a symmetric 3x3 matrix the order of the 6 elements \( \left[a_0,a_1.....a_5 \right]\) is: <p class="formulaDsp">
\[ M = \left( \begin{array}{ccc} a_0 &amp; a_1 &amp; a_3 \\ a_1 &amp; a_2 &amp; a_4 \\ a_3 &amp; a_4 &amp; a_5 \end{array} \right) \]
</p>
</li>
</ol>
</li>
</ul>
<h3>Creating a matrix</h3>
<p>The following constructors are available to create a matrix:</p>
<ul>
<li>Default constructor for a zero matrix (all elements equal to zero).</li>
<li>Constructor of an identity matrix.</li>
<li>Copy constructor (and assignment) for a matrix with the same representation, or from a different one when possible, for example from a symmetric to a general matrix.</li>
<li>Constructor (and assignment) from a matrix expression, like D = A*B + C. Due to the expression template technique, no temporary objects are created in this operation. In the case of an operation like A = A*B + C, a temporary object is needed and it is created automatically to store the intermediary result in order to preserve the validity of this operation.</li>
<li>Constructor from a generic STL-like iterator copying the data referred by the iterator, following its order. It is both possible to specify the <em>begin</em> and <em>end</em> of the iterator or the <em>begin</em> and the size. In case of a symmetric matrix, it is required only the triangular block and the user can specify whether giving a block representing the lower (default case) or the upper diagonal part.</li>
<li>Constructor of a symmetric matrix NxN passing a <a class="el" href="classROOT_1_1Math_1_1SVector.html" title="SVector: a generic fixed size Vector class. ">ROOT::Math::SVector</a> with dimension N*(N+1)/2 containing the lower (or upper) block data elements.</li>
</ul>
<p>Here are some examples on how to create a matrix. We use <em>typedef's</em> in the following examples to avoid the full C++ names for the matrix classes. Notice that for a general matrix the representation has the default value, <a class="el" href="classROOT_1_1Math_1_1MatRepStd.html" title="Expression wrapper class for Matrix objects. ">ROOT::Math::MatRepStd</a>, and it is not needed to be specified. Furtheremore, for a general square matrix, the number of column may be as well omitted.</p>
<div class="fragment"><div class="line">// typedef definitions used in the following declarations</div><div class="line">typedef ROOT::Math::SMatrix&lt;double,3&gt;                                       SMatrix33;</div><div class="line">typedef ROOT::Math::SMatrix&lt;double,2&gt;                                       SMatrix22;</div><div class="line">typedef ROOT::Math::SMatrix&lt;double,3,3,ROOT::Math::MatRepSym&lt;double,3&gt; &gt;    SMatrixSym3;</div><div class="line">typedef ROOT::Math::SVector&gt;double,2&gt;                                       SVector2;</div><div class="line">typedef ROOT::Math::SVector&gt;double,3&gt;                                       SVector3;</div><div class="line">typedef ROOT::Math::SVector&gt;double,6&gt;                                       SVector6;</div><div class="line"></div><div class="line">SMatrix33   m0;                         // create a zero 3x3 matrix</div><div class="line">// create an 3x3 identity matrix</div><div class="line">SMatrix33   i = ROOT::Math::SMatrixIdentity();</div><div class="line">double   a[9] = {1,2,3,4,5,6,7,8,9};    // input matrix data</div><div class="line">SMatrix33   m(a,9);                     // create a matrix using the a[] data</div><div class="line">// this will produce the 3x3 matrix</div><div class="line">//    (  1    2    3</div><div class="line">//       4    5    6</div><div class="line">//       7    8    9  )</div></div><!-- fragment --><p>Example to create a symmetric matrix from an <em>std::vector</em>:</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; v(6);</div><div class="line">for (int i = 0; i&lt;6; ++i) v[i] = double(i+1);</div><div class="line">SMatrixSym3  s(v.begin(),v.end())</div><div class="line">// this will produce the symmetric  matrix</div><div class="line">//    (  1    2    4</div><div class="line">//       2    3    5</div><div class="line">//       4    5    6  )</div><div class="line"></div><div class="line">// create a a general matrix from a symmetric matrix. The opposite will not compile</div><div class="line">SMatrix33    m2 = s;</div></div><!-- fragment --><p>Example to create a symmetric matrix from a <a class="el" href="classROOT_1_1Math_1_1SVector.html" title="SVector: a generic fixed size Vector class. ">ROOT::Math::SVector</a> contining the lower/upper data block:</p>
<div class="fragment"><div class="line">ROOT::Math::SVectorr&lt;double, 6&gt; v(1,2,3,4,5,6);</div><div class="line">SMatrixSym3 s1(v);  // lower block (default)</div><div class="line">// this will produce the symmetric  matrix</div><div class="line">//    (  1    2    4</div><div class="line">//       2    3    5</div><div class="line">//       4    5    6  )</div><div class="line"></div><div class="line">SMatrixSym3 s2(v,false);  // upper block</div><div class="line">// this will produce the symmetric  matrix</div><div class="line">//    (  1    2    3</div><div class="line">//       2    4    5</div><div class="line">//       3    5    6  )</div></div><!-- fragment --><h3>Accessing and Setting Methods</h3>
<p>The matrix elements can be set using the <em>operator()(irow,icol)</em>, where irow and icol are the row and column indexes or by using the iterator interface. Notice that the indexes start from zero and not from one as in FORTRAN. All the matrix elements can be set also by using the ROOT::Math::SetElements function passing a generic iterator. The elements can be accessed by these same methods and also by using the <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a09e49a437c30c94a3f82d5385fc21187" title="access the parse tree with the index starting from zero and following the C convention for the order ...">ROOT::Math::SMatrix::apply</a> function. The <em>apply(i)</em> function has exactly the same behavior for general and symmetric matrices, in contrast to the iterator access methods which behave differently (it follows the data order).</p>
<div class="fragment"><div class="line">SMatrix33   m;</div><div class="line">m(0,0)  = 1;                          // set the element in first row and first column</div><div class="line">*(m.**begin**()+1) = 2;                    // set the second element (0,1)</div><div class="line">double d[9]={1,2,3,4,5,6,7,8,9};</div><div class="line">m.SetElements(d,d+9);                  // set the d[] values in m</div><div class="line"></div><div class="line">double x = m(2,1);                     // return the element in third row and first column</div><div class="line">x = m.**apply**(7);                        // return the 8-th element (row=2,col=1)</div><div class="line">x = *(m.**begin**()+7);                    // return the 8-th element (row=2,col=1)</div><div class="line">// symmetric matrices (note the difference in behavior between apply and the iterators)</div><div class="line">x = *(m.**begin**()+4)                     // return the element (row=2,col=1).</div><div class="line">x = m.**apply**(7);                        // returns again the (row=2,col=1) element</div></div><!-- fragment --><p>There are methods to place and/or retrieve <a class="el" href="classROOT_1_1Math_1_1SVector.html" title="SVector: a generic fixed size Vector class. ">ROOT::Math::SVector</a> objects as rows or columns in (from) a matrix. In addition one can put (get) a sub-matrix as another <a class="el" href="classROOT_1_1Math_1_1SMatrix.html" title="SMatrix: a generic fixed size D1 x D2 Matrix class. ">ROOT::Math::SMatrix</a> object in a matrix. If the size of the the sub-vector or sub-matrix are larger than the matrix size a static assert ( a compilation error) is produced. The non-const methods are:</p>
<div class="fragment"><div class="line">SMatrix33            m;</div><div class="line">SVector2       v2(1,2);</div><div class="line">// place a vector of size 2 in the first row starting from element (0,1) : m(0,1) = v2[0]</div><div class="line">m.**Place_in_row**(v2,0,1);</div><div class="line">// place the vector in the second column from (0,1) : m(0,1) = v2[0]</div><div class="line">m.**Place in_col**(v2,0,1);</div><div class="line">SMatrix22           m2;</div><div class="line">// place the sub-matrix m2 in m starting from the element (1,1) : m(1,1) = m2(0,0)</div><div class="line">m.**Place_at**(m2,1,1);</div><div class="line">SVector3     v3(1,2,3);</div><div class="line">// set v3 as the diagonal elements of m  : m(i,i) = v3[i] for i=0,1,2</div><div class="line">m.**SetDiagonal**(v3)</div></div><!-- fragment --><p>The const methods retrieving contents (getting slices of a matrix) are:</p>
<div class="fragment"><div class="line">a = {1,2,3,4,5,6,7,8,9};</div><div class="line">SMatrix33       m(a,a+9);</div><div class="line">SVector3 irow = m.**Row**(0);             // return as vector the first matrix row</div><div class="line">SVector3 jcol = m.**Col**(1);            // return as vector the second matrix column</div><div class="line">// return a slice of the first row from element (0,1) : r2[0] = m(0,1); r2[1] = m(0,2)</div><div class="line">SVector2 r2   =  m.**SubRow**&lt;SVector2&gt; (0,1);</div><div class="line">// return a slice of the second column from element (0,1) : c2[0] = m(0,1); c2[1] = m(1,1);</div><div class="line">SVector2 c2   =  m.**SubCol**&lt;SVector2&gt; (1,0);</div><div class="line">// return a sub-matrix 2x2 with the upper left corner at the values (1,1)</div><div class="line">SMatrix22 subM = m.**Sub**&lt;SMatrix22&gt;   (1,1);</div><div class="line">// return the diagonal element in a SVector</div><div class="line">SVector3  diag = m.**Diagonal**();</div><div class="line">// return the upper(lower) block of the matrix m</div><div class="line">SVector6 vub = m.**UpperBlock**();        //  vub = [ 1, 2, 3, 5, 6, 9 ]</div><div class="line">SVector6 vlb = m.**LowerBlock**();       //  vlb = [ 1, 4, 5, 7, 8, 9 ]</div></div><!-- fragment --><h3>Linear Algebra Functions</h3>
<p>Only limited linear algebra functionality is available for SMatrix. It is possible for squared matrices NxN, to find the inverse or to calculate the determinant. Different inversion algorithms are used if the matrix is smaller than 6x6 or if it is symmetric. In the case of a small matrix, a faster direct inversion is used. For a large (N &gt; 6) symmetric matrix the Bunch-Kaufman diagonal pivoting method is used while for a large (N &gt; 6) general matrix an LU factorization is performed using the same algorithm as in the CERNLIB routine <a href="https://cern-tex.web.cern.ch/cern-tex/shortwrupsdir/f010/top.html">dinv</a>.</p>
<div class="fragment"><div class="line">//  Invert a NxN matrix. The inverted matrix replace the existing one and returns if the result is successful</div><div class="line">bool ret = m.**Invert**()</div><div class="line">// return the inverse matrix of m. If the inversion fails ifail is different than zero</div><div class="line">int ifail = 0;</div><div class="line">mInv = m.**Inverse**(ifail);</div></div><!-- fragment --><p>The determinant of a square matrix can be obtained as follows:</p>
<div class="fragment"><div class="line">double det;</div><div class="line">// calculate the determinant modifying the matrix content. Returns if the calculation was successful</div><div class="line">bool ret = m.**Det**(det);</div><div class="line">// calculate the determinant using a temporary matrix but preserving the matrix content</div><div class="line">bool ret = n.**Det2**(det);</div></div><!-- fragment --><p>For additional Matrix functionality see the <a class="el" href="MatVecFunctions.html">Matrix and Vector Operators and Functions</a> page </p>
</div></div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:10:40 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
