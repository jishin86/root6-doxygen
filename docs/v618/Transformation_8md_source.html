<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: math/genvector/doc/Transformation.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">math/genvector/doc/Transformation.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="Transformation_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Rotation and transformation doxygen page</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/**</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;\page TransformPage Vector Transformations</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Transformations classes are grouped in Rotations (in 3 dimensions), Lorentz transformations and Poincarre transformations, which are Translation/Rotation combinations. Each group has several members which may model physically equivalent trasformations but with different internal representations.   </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;All the classes are non-template and use double precision as the scalar type The following types of transformation classes are defined:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;*   3D Rotations:</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    *   ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    *   ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein [definition](http://mathworld.wolfram.com/EulerAngles.html).</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    *   ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y&#39; axis and then along the rotated X&#39;&#39; axis.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    *   ROOT::Math::AxisAngle, rotation described by a vector (axis) and an angle</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    *   ROOT::Math::Quaternion, rotation described by a quaternion (4 numbers)</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    *   ROOT::Math::RotationX, specialized rotation along the X axis</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    *   ROOT::Math::RotationY, specialized rotation along the Y axis</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    *   ROOT::Math::RotationZ, specialized rotation along the Z axis</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;*   3D Transformations (Rotations + Translations)</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    *   ROOT::Math::Translation3D, (only translation) described by a 3D Vector</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    *   ROOT::Math::Transform3D, (rotations and then translation) described by a 3x4 matrix (12 numbers)</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;*   Lorentz Rotations and Boost</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    *   ROOT::Math::LorentzRotation , 4D rotation (3D rotation plus a boost) described by a 4x4 matrix</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    *   ROOT::Math::Boost, a Lorentz boost in an arbitrary direction and described by a 4x4 symmetrix matrix (10 numbers)</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    *   ROOT::Math::BoostX, a boost in the X axis direction</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    *   ROOT::Math::BoostY, a boost in the Y axis direction</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    *   ROOT::Math::BoostZ, a boost in the Z axis direction</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;#### Constructors</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;All rotations and transformations are default constructible (giving the identity transformation). All rotations are constructible taking a number of scalar argumnts matching the number (and order of components)</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;&lt;pre&gt;Rotation3D    rI;                                // create a summy rotation (Identity matrix)</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;RotationX     rX(M_PI);                          // create a rotationX with an angle PI</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;EulerAngles   rE(phi, theta, psi);               // create a Euler rotation with phi,theta,psi angles</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;XYZVector     u(ux,uy,uz);</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;AxisAngle     rA(u, delta);                      // create a rotation based on direction u with delta angle</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;&lt;/pre&gt;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;In addition, all rotations and transformations (other than the axial rotations) and transformations are constructible from (begin,end) iterators or from pointers whicih behave like iterators.</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;&lt;pre&gt;double          data[9];</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;Rotation3D      r(data, data+9);                 // create a rotation from a rotation matrix</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;std::vector &lt;double&gt;w(12);</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;Transform3D     t(w.begin(),w.end());            // create a Transform3D from the content of a std::vector&lt;/double&gt; &lt;/pre&gt;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;All rotations, except the axial rotations, are constructible and assigned from any other type of rotation (including the axial):</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;&lt;pre&gt;Rotation3D    r(ROOT::Math::RotationX(PI));      // create a rotation 3D from a rotation along X axis of angle PI</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;EulerAngles   r2(r);                             // construct an Euler Rotation from A Rotation3D</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;AxisAngle     r3; r3 = r2;                       // assign an Axis Rotation from an Euler Rotation;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;&lt;/pre&gt;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;Transform3D (rotation + translation) can be constructed from a rotation and a translation vector</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;&lt;pre&gt;Rotation3D r; XYZVector v;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;Transform3D   t1(r,v);                           // construct from rotation and then translation</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;Transform3D   t2(v,r);                           // construct inverse from first translation then rotation</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;Transform3D   t3(r);                             // construct from only a rotation (zero translation)</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;Transform3D   t4(v);                             // construct from only translation (identity rotation)</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;&lt;/pre&gt;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;#### Operations</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;All transformations can be applied to vector and points using the _operator *_ or using the _operator()_</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;&lt;pre&gt;XYZVector  v1(...);</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;Rotation3D r(...);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;XYZVector v2 = r*v1;                             // rotate vector v1 using r</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;v2 = r(v1)                                       // equivalent</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;&lt;/pre&gt;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;Transformations can be combined using the operator * . Note that the rotations are not commutative ans therefore the order is important</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;&lt;pre&gt;Rotation3D     r1(...);</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;Rotation3D     r2(...);</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;Rotation3D  r3 = r2*r1;                          // obtain a combine rotation r3 by applying first r1 then r2</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;&lt;/pre&gt;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;We can combine rotations of different types, like Rotation3D with any other type of rotations. The product of two different axial rotations return a Rotation3D:</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;&lt;pre&gt;RotationX        rx(1.);</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;RotationY        ry(2.);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;Rotation3D  r = ry * rx;                         // rotation along X and then Y axis</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;&lt;/pre&gt;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;It is also possible to invert all the transformation or return the inverse of a transformation</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;&lt;pre&gt;Rotation3D           r1(...);</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                 r1.Invert();                    // invert the rotation modifying its content</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;Rotation3D  r2 =r1.Inverse();                    // return the inverse in a new rotation class</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;&lt;/pre&gt;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;We have used rotation as examples, but all these operations can be applied to all the transformation classes. Rotation3D, Transform3D and Translation3D classes can all be combined via the _operator *_.</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;&lt;pre&gt;Rotation3D     r(AxisAngle(phi,ux,uy,uz));   // rotation of an angle phi around u.</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;Translation3D  d(dx,dy,dz);                  // translation of a vector d</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;Transform3D    t1 = d * r;                   // transformation obtained applying first the rotation</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;Transform3D    t2 = r * d;                   // transformation obtained applying first the translation</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;&lt;/pre&gt;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;#### Set/GetComponents methods</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;Common methods to all the transformations are the Get and SetComponents. They can be used to retrieve all the scalar values on which the trasformation is based. They can be used with a signature based iterators or by using any foreign matrix which implements the _operator(i,j)_ or a different signatures depending on the transformation type.</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;&lt;pre&gt;RotationX  rx;  rx.SetComponents(1.)           // set agle of the X rotation</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;double d[9] = {........}</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;Rotation3D r;   r.SetComponents(d,d+9);        // set 9 components of 3D rotation</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;double d[16];</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;LorentzRotation lr;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;lr.GetComponents( d, d+16);                    // get 16 components of a LorentzRotation</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;TMatrixD(3,4) m;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;Transform3D t;  t.GetComponens(m);             // fill matrix of size 3x4 with components of the transform3D t</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;&lt;/pre&gt;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;For more detailed documentation on all methods see the reference doc for the specific transformation class.</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;*/</div></div><!-- fragment --></div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:09:26 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
