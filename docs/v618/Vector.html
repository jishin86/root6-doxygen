<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: Generic Vector for 2, 3 and 4 Dimensions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Generic Vector for 2, 3 and 4 Dimensions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>GenVector</b>, is a new package intended to prepresent vectors and their operations and transformations, such as rotations and Lorentz transformations, in 2, 3 and 4 dimensions. The 2D and 3D space are used to describe the geometry vectors and points, while the 4D space-time is used for physics vectors representing relativistic particles. <br />
These 2D,3D and 4D vectors are different from vectors of the Linear Algebra package which describe generic N-dimensional vectors. Similar functionality is currently provided by the CLHEP <a href="http://proj-clhep.web.cern.ch/proj-clhep/manual/UserGuide/VectorDefs/index.html">Vector</a> and <a href="http://www.hep.phy.cam.ac.uk/lhcb/doc/CLHEP/1.9.1.2/html/namespaceHepGeom.html">Geometry</a> packages and the ROOT <a href="http://root.cern.ch/root/html/PHYSICS_Index.html">Physics Vector</a> classes (Tvector2, <a class="el" href="classTVector3.html" title="TVector3 is a general three vector class, which can be used for the description of different vectors ...">TVector3</a> and <a class="el" href="classTLorentzVector.html" title="DisclaimerTLorentzVector is a legacy class. ">TLorentzVector</a>). It is also re-uses concepts and ideas from the CMS <a href="http://lcgapp.cern.ch/doxygen/SEAL/snapshot/html/dir_000007.html">Common Vector package</a>.</p>
<p>In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modelling the vectors. There is a user-controlled freedom on how the vector is internally represented. This is expressed by a choice of coordinate system which is supplied as a template prameter when the vector is constructed. Furthermore each coordinate system is itself a template, so that the user can specify the underlying scalar type. <br />
In more detail, the main characteristics of GenVector are:</p>
<ul>
<li><p class="startli"><b>Optimal runtime performances</b></p>
<p class="startli">We try to minimize any overhead in the run-time performances. We have deliberatly avoided to have any virtual function and even virtual destructors in the classes and have inlined as much as possible all the functions. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions.</p>
</li>
<li><p class="startli"><b>Points and Vector concept</b></p>
<p class="startli">Mathematically vectors and points are two distinct concepts. They have different transformations, like vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 2 and 3 dimensional case, between points and vectors, modeling them with different classes:</p><ul>
<li><a class="el" href="classROOT_1_1Math_1_1DisplacementVector3D.html" title=" Class describing a generic displacement vector in 3 dimensions. ">ROOT::Math::DisplacementVector3D</a> and <a class="el" href="classROOT_1_1Math_1_1DisplacementVector2D.html" title="Class describing a generic displacement vector in 2 dimensions. ">ROOT::Math::DisplacementVector2D</a> template classes describing 3 and 2 component direction and magnitude vectors, not rooted at any particular point;</li>
<li><a class="el" href="classROOT_1_1Math_1_1PositionVector3D.html" title=" Class describing a generic position vector (point) in 3 dimensions. ">ROOT::Math::PositionVector3D</a> template and <a class="el" href="classROOT_1_1Math_1_1PositionVector3D.html" title=" Class describing a generic position vector (point) in 3 dimensions. ">ROOT::Math::PositionVector3D</a> class modeling the points in 3 and 2 dimensions For the 4D space-time vectors, we use the same class to model them, <a class="el" href="classROOT_1_1Math_1_1LorentzVector.html" title="  Class describing a generic LorentzVector in the 4D space-time, using the specified coordinate syste...">ROOT::Math::LorentzVector</a>, since we have recognized a limited needs for modeling the functionality of a 4D point.</li>
</ul>
</li>
<li><p class="startli"><b>Generic Coordinate System</b></p>
<p class="startli">The vector classes are based on a generic type of coordinate system, expressed as a template parameter of the class. Various classes exist to describe the various coordinates systems:</p><ul>
<li><b>2D coordinate system</b> classes:<ul>
<li><a class="el" href="classROOT_1_1Math_1_1Cartesian2D.html" title="Class describing a 2D cartesian coordinate system (x, y coordinates) ">ROOT::Math::Cartesian2D</a>, based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(x,y)</a>_;</li>
<li><a class="el" href="classROOT_1_1Math_1_1Polar2D.html" title="Class describing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range...">ROOT::Math::Polar2D</a>, based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(r, phi)</a>_;</li>
</ul>
</li>
<li><b>3D coordinate system</b> classes:<ul>
<li><a class="el" href="classROOT_1_1Math_1_1Cartesian3D.html" title="Class describing a 3D cartesian coordinate system (x, y, z coordinates) ">ROOT::Math::Cartesian3D</a>, based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(x,y,z)</a>_;</li>
<li><a class="el" href="classROOT_1_1Math_1_1Polar3D.html" title="Class describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the r...">ROOT::Math::Polar3D</a>, based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(r, theta, phi)</a>_;</li>
<li><a class="el" href="classROOT_1_1Math_1_1Cylindrical3D.html" title="Class describing a cylindrical coordinate system based on rho, z and phi. ">ROOT::Math::Cylindrical3D</a>, based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(rho, z, phi)</a>_</li>
<li><a class="el" href="classROOT_1_1Math_1_1CylindricalEta3D.html" title="Class describing a cylindrical coordinate system based on eta (pseudorapidity) instead of z...">ROOT::Math::CylindricalEta3D</a>, based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(rho, eta, phi)</a>_, where eta is the pseudo-rapidity;</li>
</ul>
</li>
<li><b>4D coordinate system</b> classes:<ul>
<li><a class="el" href="classROOT_1_1Math_1_1PxPyPzE4D.html" title="Class describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors...">ROOT::Math::PxPyPzE4D</a>, based on based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(px,py,pz,E)</a>_;</li>
<li><a class="el" href="classROOT_1_1Math_1_1PxPyPzM4D.html" title="Class describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py...">ROOT::Math::PxPyPzM4D</a>, based on based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(px,py,pz,M)</a>_;</li>
<li><a class="el" href="classROOT_1_1Math_1_1PtEtaPhiE4D.html" title="Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho...">ROOT::Math::PtEtaPhiE4D</a>, based on based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(pt,eta,phi,E)</a>_;</li>
<li><a class="el" href="classROOT_1_1Math_1_1PtEtaPhiM4D.html" title="Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used ...">ROOT::Math::PtEtaPhiM4D</a>, based on based on <a class="el" href="cfortran_8h.html#ae5cd5aa262ffbc853d773293d00e4323">_(pt,eta,phi,M)</a>_;The angle <em>theta</em> is defined between [0,PI] and <em>phi</em> between [-PI,PI]. The angles are expressed in radians. <br />
 Users can define the Vectors according to the coordinate type which is most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment _(=)_ operator. <br />
 For maximum flexibility and minimize in some use case memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based an double's. <br />
 See the <a class="el" href="Vector3DPage.html">3D Vector</a>, <a class="el" href="Point3DPage.html">3D Point</a>, <a class="el" href="Vector2DPage.html">2D Vector and Point</a>, and <a class="el" href="LorentzVectorPage.html">LorentzVector</a> classes for all the possible types of vector classes which can be constructed by the user with the available coordinate system types.</li>
</ul>
</li>
</ul>
</li>
<li><p class="startli"><b>Coordinate System Tag</b></p>
<p class="startli">The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the <a class="el" href="classROOT_1_1Math_1_1DisplacementVector3D.html" title=" Class describing a generic displacement vector in 3 dimensions. ">ROOT::Math::DisplacementVector3D</a> (and <a class="el" href="classROOT_1_1Math_1_1DisplacementVector2D.html" title="Class describing a generic displacement vector in 2 dimensions. ">ROOT::Math::DisplacementVector2D</a>) and <a class="el" href="classROOT_1_1Math_1_1PositionVector3D.html" title=" Class describing a generic position vector (point) in 3 dimensions. ">ROOT::Math::PositionVector3D</a> (and <a class="el" href="classROOT_1_1Math_1_1PositionVector2D.html" title="Class describing a generic position vector (point) in 2 dimensions. ">ROOT::Math::PositionVector2D</a>) classes. A default tag, <a class="el" href="classROOT_1_1Math_1_1DefaultCoordinateSystemTag.html" title="DefaultCoordinateSystemTag Default tag for identifying any coordinate system. ">ROOT::Math::DefaultCoordinateSystemTag</a>, exists for users who don't need this functionality.</p>
</li>
<li><p class="startli"><b>Transformations</b></p>
<p class="startli">The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in Rotations (in 3 dimensions), Lorentz transformations and Poincarre transformations, which are Translation/Rotation combinations. Each group has several members which may model physically equivalent trasformations but with different internal representations. Transformation classes can operate on all type of vectors using the <em>operator()</em> or the <em>operator *</em> and the transformations can also be combined via the <em>operator *</em>. In more detail the transformations available are:</p><ul>
<li><b>3D Rotations classes</b><ul>
<li>Rotation described by a 3x3 matrix (<a class="el" href="classROOT_1_1Math_1_1Rotation3D.html" title="Rotation class with the (3D) rotation represented by a 3x3 orthogonal matrix. ">ROOT::Math::Rotation3D</a>)</li>
<li>Rotation described by Euler angles, Goldstein representation, (<a class="el" href="classROOT_1_1Math_1_1EulerAngles.html" title="EulerAngles class describing rotation as three angles (Euler Angles). ">ROOT::Math::EulerAngles</a>)</li>
<li>Rotation described by 3-2-1 Euler angles (<a class="el" href="classROOT_1_1Math_1_1RotationZYX.html" title="Rotation class with the (3D) rotation represented by angles describing first a rotation of an angle p...">ROOT::Math::RotationZYX</a>)</li>
<li>Rotation described by a direction axis and an angle (<a class="el" href="classROOT_1_1Math_1_1AxisAngle.html" title="AxisAngle class describing rotation represented with direction axis (3D Vector) and an angle of rotat...">ROOT::Math::AxisAngle</a>)</li>
<li>Rotation described by a quaternion (<a class="el" href="classROOT_1_1Math_1_1Quaternion.html" title="Rotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k). ">ROOT::Math::Quaternion</a>)</li>
<li>Optimized rotation around the x (<a class="el" href="classROOT_1_1Math_1_1RotationX.html" title="Rotation class representing a 3D rotation about the X axis by the angle of rotation. ">ROOT::Math::RotationX</a>), y (<a class="el" href="classROOT_1_1Math_1_1RotationY.html" title="Rotation class representing a 3D rotation about the Y axis by the angle of rotation. ">ROOT::Math::RotationY</a>) and z (<a class="el" href="classROOT_1_1Math_1_1RotationZ.html" title="Rotation class representing a 3D rotation about the Z axis by the angle of rotation. ">ROOT::Math::RotationZ</a>) axis and described by just one angle.</li>
</ul>
</li>
<li><p class="startli"><b>3D Transformation</b></p>
<p class="startli">We describe the transformations defined as a composition between a rotation and a translation using the class <a class="el" href="namespaceROOT_1_1Math.html#a89144a159757feb539e4a6b0d2bbface">ROOT::Math::Transform3D</a>. It is important to note that transformations act differently on Vectors and Points. The Vectors only rotate, therefore when applying a transfomation (rotation + translation) on a Vector, only the rotation operates while the translation has no effect. The interface for Transformations is similar to the one used in the CLHEP Geometry package (class <a href="http://www.hep.phy.cam.ac.uk/lhcb/doc/CLHEP/1.9.1.2/html/classHepGeom_1_1Transform3D.html">Transform3D</a>). <br />
 A class, <a class="el" href="namespaceROOT_1_1Math.html#a481720b73948f90ac9fdbfced941e3f4">ROOT::Math::Translation3D</a>. describe transformations consisting of only a translation. Translation can be applied only on Points, applying them on Vector objects has no effect. The Translation3D class can be combined with both <a class="el" href="classROOT_1_1Math_1_1Rotation3D.html" title="Rotation class with the (3D) rotation represented by a 3x3 orthogonal matrix. ">ROOT::Math::Rotation3D</a> and <a class="el" href="namespaceROOT_1_1Math.html#a89144a159757feb539e4a6b0d2bbface">ROOT::Math::Transform3D</a> using the <em>operator *</em> to obtain a new transformation as an instance of a Transform3D class.</p>
</li>
<li><b>Lorentz Rotation</b><ul>
<li>Generic Lorentz Rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class <a class="el" href="classROOT_1_1Math_1_1LorentzRotation.html" title="Lorentz transformation class with the (4D) transformation represented by a 4x4 orthosymplectic matrix...">ROOT::Math::LorentzRotation</a>)</li>
<li>A pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class <a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">ROOT::Math::Boost</a>)</li>
<li>Boost along the x (<a class="el" href="classROOT_1_1Math_1_1BoostX.html" title="Class representing a Lorentz Boost along the X axis, by beta. ">ROOT::Math::BoostX</a>), y (<a class="el" href="classROOT_1_1Math_1_1BoostY.html" title="Class representing a Lorentz Boost along the Y axis, by beta. ">ROOT::Math::BoostY</a>) and z (<a class="el" href="classROOT_1_1Math_1_1BoostZ.html" title="Class representing a Lorentz Boost along the Z axis, by beta. ">ROOT::Math::BoostZ</a>) axis.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Other main characteristics of the GenVector classes are:</p>
<ul>
<li><p class="startli"><b>Minimal Vector classes interface</b></p>
<p class="startli">We have tried to keep the interface to a minimal level:</p><ul>
<li>We try to avoid methods providing the same functionality but with different names ( like getX() and <a class="el" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x()</a> ).</li>
<li>we minimize the number of setter methods, avoiding methods which can be ambigous and set the Vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.</li>
<li>The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see <a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html" title=" Global Helper functions for generic Vector classes. ">ROOT::Math::VectorUtil</a>). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily.</li>
</ul>
</li>
<li><p class="startli"><b>Naming Convention</b></p>
<p class="startli">As part of ROOT, the GenVector package adheres to the prescribed <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> naming convention, with some (approved) exceptions, as described here:</p><ul>
<li>Every class and function is in the <em><a class="el" href="namespaceROOT_1_1Math.html">ROOT::Math</a></em> namespace</li>
<li>Member function names starts with upper-case letter, apart some exceptions (see later CLHEP compatibility)</li>
</ul>
</li>
<li><b>Compatibility with CLHEP Vector classes</b><ul>
<li>For backward compatibility with CLHEP the Vector classes can be constructed easly from a CLHEP HepVector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessors <a class="el" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x()</a>, <a class="el" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y()</a> and <a class="el" href="TRolke_8cxx.html#a89a026883dd7df087bf16c8c176caeed">z()</a> (and t() for the 4D).</li>
<li>we have decided to provide Vector member function with the same naming convention as CLHEP for the most used functions like <em><a class="el" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x()</a></em>, <em><a class="el" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y()</a></em> and <em><a class="el" href="TRolke_8cxx.html#a89a026883dd7df087bf16c8c176caeed">z()</a></em>.</li>
</ul>
</li>
<li><p class="startli"><b>Connection to Linear Algebra package</b></p>
<p class="startli">In some use cases, like in track reconstruction, it is needed to use the content of the vector and rotation classes in conjunction with linear algebra operations. We prefer to avoid any direct dependency to any Linear algebra package. However, we provide some hooks to convert to and from Linear Algebra classes.</p><ul>
<li>The vector and the transformation classes have methods which allow to get and set their data members (like SetCoordinates and GetCoordinates ) passing either a generic iterator or a pointer to a contigous set of data, like a C array. This allows a easy connection with linear algebra package which allows creation of matrices using C arrays (like the ROOT TMatrix classes) or iterators ( SMatrix classes )</li>
<li>Multiplication between Linear Algebra matrix and GenVector Vectors is possible by using the template free functions <a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#afdf11694d6d123a4b9b8c07bf477b95c" title=" Multiplications of a generic matrices with a DisplacementVector3D of any coordinate system...">ROOT::Math::VectorUtil::Mult</a>. This works for any Linear Algebra matrix which implement the <em>operator(i,j)</em> and with first matrix element at <em>i=j=0</em>.</li>
</ul>
</li>
</ul>
<h2>Example of Usage</h2>
<ul>
<li><a class="el" href="Vector3DPage.html">Vector3D Classes</a></li>
<li><a class="el" href="Point3DPage.html">Point3D Classes</a></li>
<li><a class="el" href="LorentzVectorPage.html">LorentzVector Classes</a></li>
<li><a class="el" href="TransformPage.html">Vector Transformations</a></li>
<li><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html" title=" Global Helper functions for generic Vector classes. ">ROOT::Math::VectorUtil</a> (Helper functions)</li>
<li><a class="el" href="ExtUsagePage.html">Examples with External Packages</a></li>
</ul>
<h2>Packaging</h2>
<p>This GenVector package is part of the <a class="el" href="index.html">ROOT Reference Documentation</a> and it can be built as an independent package. A tar file can be downloaded from <a href="../GenVector.tar.gz">here</a>.</p>
<h2>Additional Documentation</h2>
<p>A more detailed description of all the GenVector classes is available in this <a href="http://seal.cern.ch/documents/mathlib/GenVector.pdf">document</a>.</p>
<h2>References</h2>
<ol type="1">
<li>CLHEP Vector package (<a href="http://proj-clhep.web.cern.ch/proj-clhep/manual/UserGuide/VectorDefs/index.html">User guide</a> and <a href="http://www.hep.phy.cam.ac.uk/lhcb/doc/CLHEP/1.9.1.2/html/dir_000027.html">reference doc</a>)</li>
<li><a href="http://www.hep.phy.cam.ac.uk/lhcb/doc/CLHEP/1.9.1.2/html/namespaceH">CLHEP Geometry package</a></li>
<li><a href="http://root.cern.ch/root/html/PHYSICS_Index.html">ROOT Physics Vector classes</a></li>
<li><a href="http://lcgapp.cern.ch/doxygen/SEAL/snapshot/html/dir_000007.html">CMS Vector package</a></li>
</ol>
<hr/>
<p>*/ </p>
</div></div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:10:40 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
