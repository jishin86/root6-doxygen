<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: ROOT::TThreadedObject&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceROOT.html">ROOT</a></li><li class="navelem"><a class="el" href="classROOT_1_1TThreadedObject.html">TThreadedObject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classROOT_1_1TThreadedObject-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classROOT_1_1TThreadedObject-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ROOT::TThreadedObject&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class ROOT::TThreadedObject&lt; T &gt;</h3>

<p>A wrapper to make object instances thread private, lazily. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Class of the object to be made thread private (e.g. <a class="el" href="classTH1F.html" title="1-D histogram with a float per channel (see TH1 documentation)} ">TH1F</a>)</td></tr>
  </table>
  </dd>
</dl>
<p>A wrapper which makes objects thread private. The methods of the underlying object can be invoked via the the arrow operator. The object is created in a specific thread lazily, i.e. upon invocation of one of its methods. The correct object pointer from within a particular thread can be accessed with the overloaded arrow operator or with the Get method. In case an elaborate thread management is in place, e.g. in presence of stream of operations or "processing slots", it is also possible to manually select the correct object pointer explicitly. The default size of the threaded objects is 64. This size can be extended manually via the fgMaxSlots parameter. The size of individual instances is automatically extended if the size of the implicit MT pool is bigger than 64. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00153">153</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a87fc060e5a528ca8556978ab7c98eb4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a87fc060e5a528ca8556978ab7c98eb4e">TThreadedObject</a> (const <a class="el" href="classROOT_1_1TThreadedObject.html">TThreadedObject</a> &amp;)=delete</td></tr>
<tr class="separator:a87fc060e5a528ca8556978ab7c98eb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef712868233d3adf1d01f1a166e325d1"><td class="memTemplParams" colspan="2">template&lt;class ... ARGS&gt; </td></tr>
<tr class="memitem:aef712868233d3adf1d01f1a166e325d1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#aef712868233d3adf1d01f1a166e325d1">TThreadedObject</a> (<a class="el" href="x11_2src_2gifencode_8c.html#a9ee5aea69f1c40a6eb1e51350a6ea178">ARGS</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:aef712868233d3adf1d01f1a166e325d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the TThreaded object and the "model" of the thread private objects.  <a href="#aef712868233d3adf1d01f1a166e325d1">More...</a><br /></td></tr>
<tr class="separator:aef712868233d3adf1d01f1a166e325d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da6ea208efdc7444a814e6561080c7c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a5da6ea208efdc7444a814e6561080c7c">Get</a> ()</td></tr>
<tr class="memdesc:a5da6ea208efdc7444a814e6561080c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the pointer corresponding to the current slot.  <a href="#a5da6ea208efdc7444a814e6561080c7c">More...</a><br /></td></tr>
<tr class="separator:a5da6ea208efdc7444a814e6561080c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244275d2cfca5f52ae44875920a454be"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a244275d2cfca5f52ae44875920a454be">GetAtSlot</a> (unsigned i)</td></tr>
<tr class="memdesc:a244275d2cfca5f52ae44875920a454be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a particular processing slot.  <a href="#a244275d2cfca5f52ae44875920a454be">More...</a><br /></td></tr>
<tr class="separator:a244275d2cfca5f52ae44875920a454be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3d51cfb51097a835cd6cf77005b035"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a9b3d51cfb51097a835cd6cf77005b035">GetAtSlotRaw</a> (unsigned i) const</td></tr>
<tr class="memdesc:a9b3d51cfb51097a835cd6cf77005b035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a particular slot which corresponds to a single thread.  <a href="#a9b3d51cfb51097a835cd6cf77005b035">More...</a><br /></td></tr>
<tr class="separator:a9b3d51cfb51097a835cd6cf77005b035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a1dfa562dcffb10364fd5eb2938322"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#ae6a1dfa562dcffb10364fd5eb2938322">GetAtSlotUnchecked</a> (unsigned i) const</td></tr>
<tr class="memdesc:ae6a1dfa562dcffb10364fd5eb2938322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a particular slot which corresponds to a single thread.  <a href="#ae6a1dfa562dcffb10364fd5eb2938322">More...</a><br /></td></tr>
<tr class="separator:ae6a1dfa562dcffb10364fd5eb2938322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b4ead410a73ab6bb388450f2feab78"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a49b4ead410a73ab6bb388450f2feab78">Merge</a> (<a class="el" href="namespaceROOT_1_1TThreadedObjectUtils.html#a4f438c93c94a72761541f6d7f9f95873">TThreadedObjectUtils::MergeFunctionType</a>&lt; T &gt; mergeFunction=<a class="el" href="namespaceROOT_1_1TThreadedObjectUtils.html#ab35001adad073e9f54e42da5ff64fcc8">TThreadedObjectUtils::MergeTObjects</a>&lt; T &gt;)</td></tr>
<tr class="memdesc:a49b4ead410a73ab6bb388450f2feab78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge all the thread private objects.  <a href="#a49b4ead410a73ab6bb388450f2feab78">More...</a><br /></td></tr>
<tr class="separator:a49b4ead410a73ab6bb388450f2feab78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab687472c3eece0f413992b42b17d1dd"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#aab687472c3eece0f413992b42b17d1dd">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:aab687472c3eece0f413992b42b17d1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the wrapped object and allow to call its methods.  <a href="#aab687472c3eece0f413992b42b17d1dd">More...</a><br /></td></tr>
<tr class="separator:aab687472c3eece0f413992b42b17d1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff271fed98e0aff1bd3717992fb8172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a2ff271fed98e0aff1bd3717992fb8172">SetAtSlot</a> (unsigned i, std::shared_ptr&lt; T &gt; <a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a2ff271fed98e0aff1bd3717992fb8172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a particular slot.  <a href="#a2ff271fed98e0aff1bd3717992fb8172">More...</a><br /></td></tr>
<tr class="separator:a2ff271fed98e0aff1bd3717992fb8172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac707146c84d4fb93d62183d9210fb6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#afac707146c84d4fb93d62183d9210fb6">SnapshotMerge</a> (<a class="el" href="namespaceROOT_1_1TThreadedObjectUtils.html#a4f438c93c94a72761541f6d7f9f95873">TThreadedObjectUtils::MergeFunctionType</a>&lt; T &gt; mergeFunction=<a class="el" href="namespaceROOT_1_1TThreadedObjectUtils.html#ab35001adad073e9f54e42da5ff64fcc8">TThreadedObjectUtils::MergeTObjects</a>&lt; T &gt;)</td></tr>
<tr class="memdesc:afac707146c84d4fb93d62183d9210fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge all the thread private objects.  <a href="#afac707146c84d4fb93d62183d9210fb6">More...</a><br /></td></tr>
<tr class="separator:afac707146c84d4fb93d62183d9210fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a905fa05363d56f1df77b162e59f3c91f"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a905fa05363d56f1df77b162e59f3c91f">fgMaxSlots</a> = 64</td></tr>
<tr class="memdesc:a905fa05363d56f1df77b162e59f3c91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of processing slots (distinct threads) which the instances can manage.  <a href="#a905fa05363d56f1df77b162e59f3c91f">More...</a><br /></td></tr>
<tr class="separator:a905fa05363d56f1df77b162e59f3c91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa1821c4c75028d08a1812461fedec928"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#aa1821c4c75028d08a1812461fedec928">GetThisSlotNumber</a> ()</td></tr>
<tr class="memdesc:aa1821c4c75028d08a1812461fedec928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the slot number for this threadID.  <a href="#aa1821c4c75028d08a1812461fedec928">More...</a><br /></td></tr>
<tr class="separator:aa1821c4c75028d08a1812461fedec928"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a94094f5f6b88f999c7b52cbd05e7db64"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a94094f5f6b88f999c7b52cbd05e7db64">fCurrMaxSlotIndex</a> = 0</td></tr>
<tr class="memdesc:a94094f5f6b88f999c7b52cbd05e7db64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum slot index.  <a href="#a94094f5f6b88f999c7b52cbd05e7db64">More...</a><br /></td></tr>
<tr class="separator:a94094f5f6b88f999c7b52cbd05e7db64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2540dfeab874315eb844d42a7486c40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTDirectory.html">TDirectory</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#ad2540dfeab874315eb844d42a7486c40">fDirectories</a></td></tr>
<tr class="memdesc:ad2540dfeab874315eb844d42a7486c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classTDirectory.html" title="Describe directory structure in memory. ">TDirectory</a> per thread is kept.  <a href="#ad2540dfeab874315eb844d42a7486c40">More...</a><br /></td></tr>
<tr class="separator:ad2540dfeab874315eb844d42a7486c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af173eb8b5047322e9e5eb8e9ec04cddf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#af173eb8b5047322e9e5eb8e9ec04cddf">fIsMerged</a> = false</td></tr>
<tr class="memdesc:af173eb8b5047322e9e5eb8e9ec04cddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remember if the objects have been merged already.  <a href="#af173eb8b5047322e9e5eb8e9ec04cddf">More...</a><br /></td></tr>
<tr class="separator:af173eb8b5047322e9e5eb8e9ec04cddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24408f1dc01188491279972622ddd48a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a24408f1dc01188491279972622ddd48a">fMaxSlots</a></td></tr>
<tr class="memdesc:a24408f1dc01188491279972622ddd48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the instance.  <a href="#a24408f1dc01188491279972622ddd48a">More...</a><br /></td></tr>
<tr class="separator:a24408f1dc01188491279972622ddd48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bbce7aa09b773fc3cc3a30659e8e1c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a89bbce7aa09b773fc3cc3a30659e8e1c">fModel</a></td></tr>
<tr class="memdesc:a89bbce7aa09b773fc3cc3a30659e8e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to store a "model" of the object.  <a href="#a89bbce7aa09b773fc3cc3a30659e8e1c">More...</a><br /></td></tr>
<tr class="separator:a89bbce7aa09b773fc3cc3a30659e8e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53ce7ccf7f09bf5f268894a9102aefd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#af53ce7ccf7f09bf5f268894a9102aefd">fObjPointers</a></td></tr>
<tr class="memdesc:af53ce7ccf7f09bf5f268894a9102aefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer per thread is kept.  <a href="#af53ce7ccf7f09bf5f268894a9102aefd">More...</a><br /></td></tr>
<tr class="separator:af53ce7ccf7f09bf5f268894a9102aefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfa6d96b83ccfe7b208c6a17de62ddb"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::thread::id, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#a1cfa6d96b83ccfe7b208c6a17de62ddb">fThrIDSlotMap</a></td></tr>
<tr class="memdesc:a1cfa6d96b83ccfe7b208c6a17de62ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping between the thread IDs and the slots.  <a href="#a1cfa6d96b83ccfe7b208c6a17de62ddb">More...</a><br /></td></tr>
<tr class="separator:a1cfa6d96b83ccfe7b208c6a17de62ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14c2b8fea0a487f92478a1e0982f76e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1TSpinMutex.html">ROOT::TSpinMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1TThreadedObject.html#ac14c2b8fea0a487f92478a1e0982f76e">fThrIDSlotMutex</a></td></tr>
<tr class="memdesc:ac14c2b8fea0a487f92478a1e0982f76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect the ID-slot map access.  <a href="#ac14c2b8fea0a487f92478a1e0982f76e">More...</a><br /></td></tr>
<tr class="separator:ac14c2b8fea0a487f92478a1e0982f76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

<p><code>#include &lt;<a class="el" href="TThreadedObject_8hxx_source.html">ROOT/TThreadedObject.hxx</a>&gt;</code></p>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a87fc060e5a528ca8556978ab7c98eb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fc060e5a528ca8556978ab7c98eb4e">&#9670;&nbsp;</a></span>TThreadedObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::<a class="el" href="classROOT_1_1TThreadedObject.html">TThreadedObject</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1TThreadedObject.html">TThreadedObject</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef712868233d3adf1d01f1a166e325d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef712868233d3adf1d01f1a166e325d1">&#9670;&nbsp;</a></span>TThreadedObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class ... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::<a class="el" href="classROOT_1_1TThreadedObject.html">TThreadedObject</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="x11_2src_2gifencode_8c.html#a9ee5aea69f1c40a6eb1e51350a6ea178">ARGS</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the TThreaded object and the "model" of the thread private objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ARGS</td><td>Arguments of the constructor of T </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00161">161</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5da6ea208efdc7444a814e6561080c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da6ea208efdc7444a814e6561080c7c">&#9670;&nbsp;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::Get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the pointer corresponding to the current slot. </p>
<p>This method is not adequate for being called inside tight loops as it implies a lookup in a mapping between the threadIDs and the slot indices. A good practice consists in copying the pointer onto the stack and proceed with the loop as shown in this work item (psudo-code) which will be sent to different threads: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> workItem = [](){</div><div class="line">   <span class="keyword">auto</span> objPtr = tthreadedObject.Get();</div><div class="line">   <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="classROOT_1_1TSeq.html">ROOT::TSeqI</a>(1000)) {</div><div class="line">      <span class="comment">// tthreadedObject-&gt;FastMethod(i); // don&#39;t do this! Inefficient!</span></div><div class="line">      objPtr-&gt;FastMethod(i);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00229">229</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="a244275d2cfca5f52ae44875920a454be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244275d2cfca5f52ae44875920a454be">&#9670;&nbsp;</a></span>GetAtSlot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::GetAtSlot </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a particular processing slot. </p>
<p>This method is <em>thread-unsafe</em>: it cannot be invoked from two different threads with the same argument. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00175">175</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="a9b3d51cfb51097a835cd6cf77005b035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3d51cfb51097a835cd6cf77005b035">&#9670;&nbsp;</a></span>GetAtSlotRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::GetAtSlotRaw </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a particular slot which corresponds to a single thread. </p>
<p>This overload is faster than the GetAtSlotUnchecked method but the caller is responsible to make sure that an object is initialised for the particular slot and that the returned pointer will not outlive the <a class="el" href="classROOT_1_1TThreadedObject.html" title="A wrapper to make object instances thread private, lazily. ">TThreadedObject</a> that returned it. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00209">209</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="ae6a1dfa562dcffb10364fd5eb2938322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a1dfa562dcffb10364fd5eb2938322">&#9670;&nbsp;</a></span>GetAtSlotUnchecked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::GetAtSlotUnchecked </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a particular slot which corresponds to a single thread. </p>
<p>This is in general faster than the GetAtSlot method but it is responsibility of the caller to make sure that an object is initialised for the particular slot. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00199">199</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="aa1821c4c75028d08a1812461fedec928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1821c4c75028d08a1812461fedec928">&#9670;&nbsp;</a></span>GetThisSlotNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::GetThisSlotNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the slot number for this threadID. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00282">282</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="a49b4ead410a73ab6bb388450f2feab78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b4ead410a73ab6bb388450f2feab78">&#9670;&nbsp;</a></span>Merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceROOT_1_1TThreadedObjectUtils.html#a4f438c93c94a72761541f6d7f9f95873">TThreadedObjectUtils::MergeFunctionType</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>mergeFunction</em> = <code><a class="el" href="namespaceROOT_1_1TThreadedObjectUtils.html#ab35001adad073e9f54e42da5ff64fcc8">TThreadedObjectUtils::MergeTObjects</a>&lt;T&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge all the thread private objects. </p>
<p>Can be called once: it does not create any new object but destroys the present bookkeping collapsing all objects into the one at slot 0. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00243">243</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="aab687472c3eece0f413992b42b17d1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab687472c3eece0f413992b42b17d1dd">&#9670;&nbsp;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the wrapped object and allow to call its methods. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00235">235</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="a2ff271fed98e0aff1bd3717992fb8172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff271fed98e0aff1bd3717992fb8172">&#9670;&nbsp;</a></span>SetAtSlot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a> <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::SetAtSlot </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of a particular slot. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00190">190</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="afac707146c84d4fb93d62183d9210fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac707146c84d4fb93d62183d9210fb6">&#9670;&nbsp;</a></span>SnapshotMerge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::SnapshotMerge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceROOT_1_1TThreadedObjectUtils.html#a4f438c93c94a72761541f6d7f9f95873">TThreadedObjectUtils::MergeFunctionType</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>mergeFunction</em> = <code><a class="el" href="namespaceROOT_1_1TThreadedObjectUtils.html#ab35001adad073e9f54e42da5ff64fcc8">TThreadedObjectUtils::MergeTObjects</a>&lt;T&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge all the thread private objects. </p>
<p>Can be called many times. It does create a new instance of class T to represent the "Sum" object. This method is not thread safe: correct or acceptable behaviours depend on the nature of T and of the merging function. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00259">259</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a94094f5f6b88f999c7b52cbd05e7db64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94094f5f6b88f999c7b52cbd05e7db64">&#9670;&nbsp;</a></span>fCurrMaxSlotIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::fCurrMaxSlotIndex = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum slot index. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00277">277</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="ad2540dfeab874315eb844d42a7486c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2540dfeab874315eb844d42a7486c40">&#9670;&nbsp;</a></span>fDirectories</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTDirectory.html">TDirectory</a>*&gt; <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::fDirectories</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classTDirectory.html" title="Describe directory structure in memory. ">TDirectory</a> per thread is kept. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00275">275</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="a905fa05363d56f1df77b162e59f3c91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905fa05363d56f1df77b162e59f3c91f">&#9670;&nbsp;</a></span>fgMaxSlots</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::fgMaxSlots = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of processing slots (distinct threads) which the instances can manage. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00155">155</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="af173eb8b5047322e9e5eb8e9ec04cddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af173eb8b5047322e9e5eb8e9ec04cddf">&#9670;&nbsp;</a></span>fIsMerged</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::fIsMerged = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remember if the objects have been merged already. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00278">278</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="a24408f1dc01188491279972622ddd48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24408f1dc01188491279972622ddd48a">&#9670;&nbsp;</a></span>fMaxSlots</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::fMaxSlots</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the instance. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00272">272</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="a89bbce7aa09b773fc3cc3a30659e8e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bbce7aa09b773fc3cc3a30659e8e1c">&#9670;&nbsp;</a></span>fModel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::fModel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to store a "model" of the object. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00273">273</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="af53ce7ccf7f09bf5f268894a9102aefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53ce7ccf7f09bf5f268894a9102aefd">&#9670;&nbsp;</a></span>fObjPointers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;T&gt; &gt; <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::fObjPointers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer per thread is kept. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00274">274</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="a1cfa6d96b83ccfe7b208c6a17de62ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfa6d96b83ccfe7b208c6a17de62ddb">&#9670;&nbsp;</a></span>fThrIDSlotMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::thread::id, unsigned&gt; <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::fThrIDSlotMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A mapping between the thread IDs and the slots. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00276">276</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<a id="ac14c2b8fea0a487f92478a1e0982f76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14c2b8fea0a487f92478a1e0982f76e">&#9670;&nbsp;</a></span>fThrIDSlotMutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1TSpinMutex.html">ROOT::TSpinMutex</a> <a class="el" href="classROOT_1_1TThreadedObject.html">ROOT::TThreadedObject</a>&lt; T &gt;::fThrIDSlotMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex to protect the ID-slot map access. </p>

<p class="definition">Definition at line <a class="el" href="TThreadedObject_8hxx_source.html#l00279">279</a> of file <a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a>.</p>

</div>
</div>
<div class="dynheader">
</div>
<div class="dyncontent">
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>core/thread/inc/ROOT/<a class="el" href="TThreadedObject_8hxx_source.html">TThreadedObject.hxx</a></li>
</ul>
</div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:11:52 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
