<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: Vector Transformations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Vector Transformations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Transformations classes are grouped in Rotations (in 3 dimensions), Lorentz transformations and Poincarre transformations, which are Translation/Rotation combinations. Each group has several members which may model physically equivalent trasformations but with different internal representations. <br />
All the classes are non-template and use double precision as the scalar type The following types of transformation classes are defined:</p>
<ul>
<li>3D Rotations:<ul>
<li><a class="el" href="classROOT_1_1Math_1_1Rotation3D.html" title="Rotation class with the (3D) rotation represented by a 3x3 orthogonal matrix. ">ROOT::Math::Rotation3D</a>, rotation described by a 3x3 matrix of doubles</li>
<li><a class="el" href="classROOT_1_1Math_1_1EulerAngles.html" title="EulerAngles class describing rotation as three angles (Euler Angles). ">ROOT::Math::EulerAngles</a> rotation described by the three Euler angles (phi, theta and psi) following the GoldStein <a href="http://mathworld.wolfram.com/EulerAngles.html">definition</a>.</li>
<li><a class="el" href="classROOT_1_1Math_1_1RotationZYX.html" title="Rotation class with the (3D) rotation represented by angles describing first a rotation of an angle p...">ROOT::Math::RotationZYX</a> rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.</li>
<li><a class="el" href="classROOT_1_1Math_1_1AxisAngle.html" title="AxisAngle class describing rotation represented with direction axis (3D Vector) and an angle of rotat...">ROOT::Math::AxisAngle</a>, rotation described by a vector (axis) and an angle</li>
<li><a class="el" href="classROOT_1_1Math_1_1Quaternion.html" title="Rotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k). ">ROOT::Math::Quaternion</a>, rotation described by a quaternion (4 numbers)</li>
<li><a class="el" href="classROOT_1_1Math_1_1RotationX.html" title="Rotation class representing a 3D rotation about the X axis by the angle of rotation. ">ROOT::Math::RotationX</a>, specialized rotation along the X axis</li>
<li><a class="el" href="classROOT_1_1Math_1_1RotationY.html" title="Rotation class representing a 3D rotation about the Y axis by the angle of rotation. ">ROOT::Math::RotationY</a>, specialized rotation along the Y axis</li>
<li><a class="el" href="classROOT_1_1Math_1_1RotationZ.html" title="Rotation class representing a 3D rotation about the Z axis by the angle of rotation. ">ROOT::Math::RotationZ</a>, specialized rotation along the Z axis</li>
</ul>
</li>
<li>3D Transformations (Rotations + Translations)<ul>
<li><a class="el" href="namespaceROOT_1_1Math.html#a481720b73948f90ac9fdbfced941e3f4">ROOT::Math::Translation3D</a>, (only translation) described by a 3D Vector</li>
<li><a class="el" href="namespaceROOT_1_1Math.html#a89144a159757feb539e4a6b0d2bbface">ROOT::Math::Transform3D</a>, (rotations and then translation) described by a 3x4 matrix (12 numbers)</li>
</ul>
</li>
<li>Lorentz Rotations and Boost<ul>
<li><a class="el" href="classROOT_1_1Math_1_1LorentzRotation.html" title="Lorentz transformation class with the (4D) transformation represented by a 4x4 orthosymplectic matrix...">ROOT::Math::LorentzRotation</a> , 4D rotation (3D rotation plus a boost) described by a 4x4 matrix</li>
<li><a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">ROOT::Math::Boost</a>, a Lorentz boost in an arbitrary direction and described by a 4x4 symmetrix matrix (10 numbers)</li>
<li><a class="el" href="classROOT_1_1Math_1_1BoostX.html" title="Class representing a Lorentz Boost along the X axis, by beta. ">ROOT::Math::BoostX</a>, a boost in the X axis direction</li>
<li><a class="el" href="classROOT_1_1Math_1_1BoostY.html" title="Class representing a Lorentz Boost along the Y axis, by beta. ">ROOT::Math::BoostY</a>, a boost in the Y axis direction</li>
<li><a class="el" href="classROOT_1_1Math_1_1BoostZ.html" title="Class representing a Lorentz Boost along the Z axis, by beta. ">ROOT::Math::BoostZ</a>, a boost in the Z axis direction</li>
</ul>
</li>
</ul>
<h4>Constructors</h4>
<p>All rotations and transformations are default constructible (giving the identity transformation). All rotations are constructible taking a number of scalar argumnts matching the number (and order of components)</p>
<pre>Rotation3D    rI;                                // create a summy rotation (Identity matrix)
RotationX     rX(M_PI);                          // create a rotationX with an angle PI
EulerAngles   rE(phi, theta, psi);               // create a Euler rotation with phi,theta,psi angles
XYZVector     u(ux,uy,uz);
AxisAngle     rA(u, delta);                      // create a rotation based on direction u with delta angle
</pre><p>In addition, all rotations and transformations (other than the axial rotations) and transformations are constructible from (begin,end) iterators or from pointers whicih behave like iterators.</p>
<pre>double          data[9];
Rotation3D      r(data, data+9);                 // create a rotation from a rotation matrix
std::vector &lt;double&gt;w(12);
Transform3D     t(w.begin(),w.end());            // create a Transform3D from the content of a std::vector&lt;/double&gt; </pre><p>All rotations, except the axial rotations, are constructible and assigned from any other type of rotation (including the axial):</p>
<pre>Rotation3D    r(ROOT::Math::RotationX(PI));      // create a rotation 3D from a rotation along X axis of angle PI
EulerAngles   r2(r);                             // construct an Euler Rotation from A Rotation3D
AxisAngle     r3; r3 = r2;                       // assign an Axis Rotation from an Euler Rotation;
</pre><p>Transform3D (rotation + translation) can be constructed from a rotation and a translation vector</p>
<pre>Rotation3D r; XYZVector v;
Transform3D   t1(r,v);                           // construct from rotation and then translation
Transform3D   t2(v,r);                           // construct inverse from first translation then rotation
Transform3D   t3(r);                             // construct from only a rotation (zero translation)
Transform3D   t4(v);                             // construct from only translation (identity rotation)
</pre><h4>Operations</h4>
<p>All transformations can be applied to vector and points using the <em>operator *</em> or using the <em>operator()</em></p>
<pre>XYZVector  v1(...);
Rotation3D r(...);
XYZVector v2 = r*v1;                             // rotate vector v1 using r
v2 = r(v1)                                       // equivalent
</pre><p>Transformations can be combined using the operator * . Note that the rotations are not commutative ans therefore the order is important</p>
<pre>Rotation3D     r1(...);
Rotation3D     r2(...);
Rotation3D  r3 = r2*r1;                          // obtain a combine rotation r3 by applying first r1 then r2
</pre><p>We can combine rotations of different types, like Rotation3D with any other type of rotations. The product of two different axial rotations return a Rotation3D:</p>
<pre>RotationX        rx(1.);
RotationY        ry(2.);
Rotation3D  r = ry * rx;                         // rotation along X and then Y axis
</pre><p>It is also possible to invert all the transformation or return the inverse of a transformation</p>
<pre>Rotation3D           r1(...);
                 <a class="el" href="namespaceROOT_1_1Minuit2.html#a3d7791001fe4298059c858771fba35db">r1.Invert()</a>;                    // invert the rotation modifying its content
Rotation3D  r2 =<a class="el" href="namespaceROOT_1_1Minuit2.html#a4163d7cf474589409964652083eb5379" title="LAPACK Algebra functions specialize the Invert function for LASymMatrix. ">r1.Inverse()</a>;                    // return the inverse in a new rotation class
</pre><p>We have used rotation as examples, but all these operations can be applied to all the transformation classes. Rotation3D, Transform3D and Translation3D classes can all be combined via the <em>operator *</em>.</p>
<pre>Rotation3D     r(AxisAngle(phi,ux,uy,uz));   // rotation of an angle phi around u.
Translation3D  <a class="el" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d(dx,dy,dz)</a>;                  // translation of a vector d
Transform3D    t1 = d * r;                   // transformation obtained applying first the rotation
Transform3D    t2 = r * d;                   // transformation obtained applying first the translation
</pre><h4>Set/GetComponents methods</h4>
<p>Common methods to all the transformations are the Get and SetComponents. They can be used to retrieve all the scalar values on which the trasformation is based. They can be used with a signature based iterators or by using any foreign matrix which implements the <em>operator(i,j)</em> or a different signatures depending on the transformation type.</p>
<pre>RotationX  rx;  rx.SetComponents(1.)           // set agle of the X rotation
double d[9] = {........}
Rotation3D r;   r.SetComponents(d,d+9);        // set 9 components of 3D rotation
double d[16];
LorentzRotation lr;
lr.GetComponents( d, d+16);                    // get 16 components of a LorentzRotation
TMatrixD(3,4) m;
Transform3D t;  t.GetComponens(m);             // fill matrix of size 3x4 with components of the transform3D t
</pre><p>For more detailed documentation on all methods see the reference doc for the specific transformation class.</p>
<p>*/ </p>
</div></div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:10:40 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
