<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: math/smatrix/doc/SMatrixClass.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">math/smatrix/doc/SMatrixClass.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="SMatrixClass_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;\page SMatrixDoc SMatrix Class Properties</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;The template ROOT::Math::SMatrix class has 4 template parameters which define, at compile time, its properties. These are:</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;*   type of the contained elements, T, for example _float_ or _double_;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;*   number of rows;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;*   number of columns;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;*   representation type (\ref MatRep). This is a class describing the underlined storage model of the Matrix. Presently exists only two types of this class:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    1.  ROOT::Math::MatRepStd for a general nrows x ncols matrix. This class is itself a template on the contained type T, the number of rows and the number of columns. Its data member is an array T[nrows*ncols] containing the matrix data. The data are stored in the row-major C convention. For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$ are stored in the following order: \f[ M = \left( \begin{array}{ccc} a_0 &amp; a_1 &amp; a_2 \\ a_3 &amp; a_4 &amp; a_5 \\ a_6 &amp; a_7 &amp; a_8 \end{array} \right) \f]</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    2.  ROOT::Math::MatRepSym for a symmetric matrix of size NxN. This class is a template on the contained type and on the symmetric matrix size, N. It has as data member an array of type T of size N*(N+1)/2, containing the lower diagonal block of the matrix. The order follows the lower diagonal block, still in a row-major convention. For example for a symmetric 3x3 matrix the order of the 6 elements \f$ \left[a_0,a_1.....a_5 \right]\f$ is: \f[ M = \left( \begin{array}{ccc} a_0 &amp; a_1 &amp; a_3 \\ a_1 &amp; a_2 &amp; a_4 \\ a_3 &amp; a_4 &amp; a_5 \end{array} \right) \f]</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;### Creating a matrix</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;The following constructors are available to create a matrix:</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;*   Default constructor for a zero matrix (all elements equal to zero).</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;*   Constructor of an identity matrix.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;*   Copy constructor (and assignment) for a matrix with the same representation, or from a different one when possible, for example from a symmetric to a general matrix.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;*   Constructor (and assignment) from a matrix expression, like D = A*B + C. Due to the expression template technique, no temporary objects are created in this operation. In the case of an operation like A = A*B + C, a temporary object is needed and it is created automatically to store the intermediary result in order to preserve the validity of this operation.</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;*   Constructor from a generic STL-like iterator copying the data referred by the iterator, following its order. It is both possible to specify the _begin_ and _end_ of the iterator or the _begin_ and the size. In case of a symmetric matrix, it is required only the triangular block and the user can specify whether giving a block representing the lower (default case) or the upper diagonal part.</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;*   Constructor of a symmetric matrix NxN passing a ROOT::Math::SVector with dimension N*(N+1)/2 containing the lower (or upper) block data elements.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;Here are some examples on how to create a matrix. We use _typedef&#39;s_ in the following examples to avoid the full C++ names for the matrix classes. Notice that for a general matrix the representation has the default value, ROOT::Math::MatRepStd, and it is not needed to be specified. Furtheremore, for a general square matrix, the number of column may be as well omitted.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;~~~ {.cpp}</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;// typedef definitions used in the following declarations</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;typedef ROOT::Math::SMatrix&lt;double,3&gt;                                       SMatrix33;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;typedef ROOT::Math::SMatrix&lt;double,2&gt;                                       SMatrix22;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;typedef ROOT::Math::SMatrix&lt;double,3,3,ROOT::Math::MatRepSym&lt;double,3&gt; &gt;    SMatrixSym3;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;typedef ROOT::Math::SVector&gt;double,2&gt;                                       SVector2;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;typedef ROOT::Math::SVector&gt;double,3&gt;                                       SVector3;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;typedef ROOT::Math::SVector&gt;double,6&gt;                                       SVector6;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;SMatrix33   m0;                         // create a zero 3x3 matrix</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;// create an 3x3 identity matrix</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;SMatrix33   i = ROOT::Math::SMatrixIdentity();</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;double   a[9] = {1,2,3,4,5,6,7,8,9};    // input matrix data</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;SMatrix33   m(a,9);                     // create a matrix using the a[] data</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;// this will produce the 3x3 matrix</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;//    (  1    2    3</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;//       4    5    6</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;//       7    8    9  )</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;~~~</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;Example to create a symmetric matrix from an _std::vector_:</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;~~~ {.cpp}</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;std::vector&lt;double&gt; v(6);</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;for (int i = 0; i&lt;6; ++i) v[i] = double(i+1);</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;SMatrixSym3  s(v.begin(),v.end())</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;// this will produce the symmetric  matrix</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;//    (  1    2    4</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;//       2    3    5</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;//       4    5    6  )</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;// create a a general matrix from a symmetric matrix. The opposite will not compile</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;SMatrix33    m2 = s;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;~~~</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;Example to create a symmetric matrix from a ROOT::Math::SVector contining the lower/upper data block:</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;~~~ {.cpp}</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;ROOT::Math::SVectorr&lt;double, 6&gt; v(1,2,3,4,5,6);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;SMatrixSym3 s1(v);  // lower block (default)</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;// this will produce the symmetric  matrix</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;//    (  1    2    4</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;//       2    3    5</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;//       4    5    6  )</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;SMatrixSym3 s2(v,false);  // upper block</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;// this will produce the symmetric  matrix</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;//    (  1    2    3</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;//       2    4    5</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;//       3    5    6  )</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;~~~</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;### Accessing and Setting Methods</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;The matrix elements can be set using the _operator()(irow,icol)_, where irow and icol are the row and column indexes or by using the iterator interface. Notice that the indexes start from zero and not from one as in FORTRAN. All the matrix elements can be set also by using the ROOT::Math::SetElements function passing a generic iterator.</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;The elements can be accessed by these same methods and also by using the ROOT::Math::SMatrix::apply function. The _apply(i)_ function has exactly the same behavior for general and symmetric matrices, in contrast to the iterator access methods which behave differently (it follows the data order).</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;~~~ {.cpp}</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;SMatrix33   m;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;m(0,0)  = 1;                          // set the element in first row and first column</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;*(m.**begin**()+1) = 2;                    // set the second element (0,1)</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;double d[9]={1,2,3,4,5,6,7,8,9};</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;m.SetElements(d,d+9);                  // set the d[] values in m</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;double x = m(2,1);                     // return the element in third row and first column</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;x = m.**apply**(7);                        // return the 8-th element (row=2,col=1)</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;x = *(m.**begin**()+7);                    // return the 8-th element (row=2,col=1)</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;// symmetric matrices (note the difference in behavior between apply and the iterators)</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;x = *(m.**begin**()+4)                     // return the element (row=2,col=1).</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;x = m.**apply**(7);                        // returns again the (row=2,col=1) element</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;~~~</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;There are methods to place and/or retrieve ROOT::Math::SVector objects as rows or columns in (from) a matrix. In addition one can put (get) a sub-matrix as another ROOT::Math::SMatrix object in a matrix. If the size of the the sub-vector or sub-matrix are larger than the matrix size a static assert ( a compilation error) is produced. The non-const methods are:</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;~~~ {.cpp}</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;SMatrix33            m;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;SVector2       v2(1,2);</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;// place a vector of size 2 in the first row starting from element (0,1) : m(0,1) = v2[0]</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;m.**Place_in_row**(v2,0,1);</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;// place the vector in the second column from (0,1) : m(0,1) = v2[0]</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;m.**Place in_col**(v2,0,1);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;SMatrix22           m2;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;// place the sub-matrix m2 in m starting from the element (1,1) : m(1,1) = m2(0,0)</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;m.**Place_at**(m2,1,1);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;SVector3     v3(1,2,3);</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;// set v3 as the diagonal elements of m  : m(i,i) = v3[i] for i=0,1,2</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;m.**SetDiagonal**(v3)</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;~~~</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;The const methods retrieving contents (getting slices of a matrix) are:</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;~~~ {.cpp}</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;a = {1,2,3,4,5,6,7,8,9};</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;SMatrix33       m(a,a+9);</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;SVector3 irow = m.**Row**(0);             // return as vector the first matrix row</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;SVector3 jcol = m.**Col**(1);            // return as vector the second matrix column</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;// return a slice of the first row from element (0,1) : r2[0] = m(0,1); r2[1] = m(0,2)</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;SVector2 r2   =  m.**SubRow**&lt;SVector2&gt; (0,1);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;// return a slice of the second column from element (0,1) : c2[0] = m(0,1); c2[1] = m(1,1);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;SVector2 c2   =  m.**SubCol**&lt;SVector2&gt; (1,0);</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;// return a sub-matrix 2x2 with the upper left corner at the values (1,1)</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;SMatrix22 subM = m.**Sub**&lt;SMatrix22&gt;   (1,1);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;// return the diagonal element in a SVector</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;SVector3  diag = m.**Diagonal**();</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;// return the upper(lower) block of the matrix m</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;SVector6 vub = m.**UpperBlock**();        //  vub = [ 1, 2, 3, 5, 6, 9 ]</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;SVector6 vlb = m.**LowerBlock**();       //  vlb = [ 1, 4, 5, 7, 8, 9 ]</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;~~~</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;### Linear Algebra Functions</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;Only limited linear algebra functionality is available for SMatrix. It is possible</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;for squared matrices NxN, to find the inverse or to calculate the determinant.</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;Different inversion algorithms are used if the matrix is smaller than 6x6 or if it</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;is symmetric. In the case of a small matrix, a faster direct inversion is used.</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;For a large (N &gt; 6) symmetric matrix the Bunch-Kaufman diagonal pivoting method</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;is used while for a large (N &gt; 6) general matrix an LU factorization is performed</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;using the same algorithm as in the CERNLIB routine</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;[dinv](https://cern-tex.web.cern.ch/cern-tex/shortwrupsdir/f010/top.html).</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;~~~ {.cpp}</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;//  Invert a NxN matrix. The inverted matrix replace the existing one and returns if the result is successful</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;bool ret = m.**Invert**()</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;// return the inverse matrix of m. If the inversion fails ifail is different than zero</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;int ifail = 0;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;mInv = m.**Inverse**(ifail);</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;~~~</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;The determinant of a square matrix can be obtained as follows:</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;~~~ {.cpp}</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;double det;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;// calculate the determinant modifying the matrix content. Returns if the calculation was successful</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;bool ret = m.**Det**(det);</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;// calculate the determinant using a temporary matrix but preserving the matrix content</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;bool ret = n.**Det2**(det);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;~~~</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;For additional Matrix functionality see the \ref MatVecFunctions page</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:09:32 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
