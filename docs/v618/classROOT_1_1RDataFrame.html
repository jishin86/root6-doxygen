<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: ROOT::RDataFrame Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceROOT.html">ROOT</a></li><li class="navelem"><a class="el" href="classROOT_1_1RDataFrame.html">RDataFrame</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classROOT_1_1RDataFrame-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classROOT_1_1RDataFrame-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ROOT::RDataFrame Class Reference<div class="ingroups"><a class="el" href="group__dataframe.html">DataFrame</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<div class="textblock"><p><br />
</p>
<p><a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a>'s <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> offers a high level interface for analyses of data stored in <code><a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a></code>s, CSV's and other data formats. </p>
<p>In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available on their machines completely transparently.<br />
 Skip to the <a href="#reference">class reference</a> or keep reading for the user guide.</p>
<p>In a nutshell: </p><div class="fragment"><div class="line"><a class="code" href="namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f">ROOT::EnableImplicitMT</a>(); <span class="comment">// Tell ROOT you want to go parallel</span></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html">ROOT::RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file_*.root&quot;</span>); <span class="comment">// Interface to TTree and TChain</span></div><div class="line"><span class="keyword">auto</span> myHisto = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Histo1D(<span class="stringliteral">&quot;Branch_A&quot;</span>); <span class="comment">// This happens in parallel!</span></div><div class="line">myHisto-&gt;Draw();</div></div><!-- fragment --><p>Calculations are expressed in terms of a type-safe <em>functional chain of actions and transformations</em>, <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> takes care of their execution. The implementation automatically puts in place several low level optimisations such as multi-thread parallelisation and caching.</p>
<p> 
<a href="https://doi.org/10.5281/zenodo.260230"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg"
alt="DOI"></a>
</p>
<h2>For the impatient user</h2>
<p>You can directly see <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> in action through its <a href="https://root.cern.ch/doc/master/group__tutorial__dataframe.html">code examples</a>, both in C++ and Python.</p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#cheatsheet">Cheat sheet</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#crash-course">Crash course</a></li>
<li><a href="#more-features">More features</a></li>
<li><a href="#transformations">Transformations</a> &ndash; manipulating data</li>
<li><a href="#actions">Actions</a> &ndash; getting results</li>
<li><a href="#parallel-execution">Parallel execution</a> &ndash; how to use it and common pitfalls</li>
<li><a href="#reference">Class reference</a> &ndash; most methods are implemented in the <a href="https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html">RInterface</a> base class</li>
</ul>
<h2><a class="anchor" id="cheatsheet"></a>Cheat sheet</h2>
<p>These are the operations which can be performed with <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></p>
<h3>Transformations</h3>
<p>Transformations are a way to manipulate the data.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Transformation</b>  </th><th class="markdownTableHeadNone"><b>Description</b>   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a7d48eb23b4378e99ebccb35e94ad025a">Define</a>  </td><td class="markdownTableBodyNone">Creates a new column in the dataset.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#acaacf727b8a41d27c6bb4513348ac892">DefineSlot</a>  </td><td class="markdownTableBodyNone">Same as <code>Define</code>, but the user-defined function must take an extra <code>unsigned int slot</code> as its first parameter. <code>slot</code> will take a different value, <code>0</code> to <code>nThreads - 1</code>, for each thread of execution. This is meant as a helper in writing thread-safe <code>Define</code> transformation when using <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> after <code><a class="el" href="namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f" title="Enable ROOT&#39;s implicit multi-threading for all objects and methods that provide an internal paralleli...">ROOT::EnableImplicitMT()</a></code>. <code>DefineSlot</code> works just as well with single-thread execution: in that case <code>slot</code> will always be <code>0</code>.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a4f17074d5771916e3df18f8458186de7">DefineSlotEntry</a>  </td><td class="markdownTableBodyNone">Same as <code>DefineSlot</code>, but the entry number is passed in addition to the slot number. This is meant as a helper in case some dependency on the entry number needs to be honoured.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a70284a3bedc72b19610aaa91b5007ebd">Filter</a>  </td><td class="markdownTableBodyNone">Filter the rows of the dataset.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a1b36b7868831de2375e061bb06cfc225">Range</a>  </td><td class="markdownTableBodyNone">Creates a node that filters entries based on range of entries   </td></tr>
</table>
<h3>Actions</h3>
<p>Actions are a way to produce a result out of the data. Each one is described in more detail in the reference guide.</p>
<p>In the following, whenever we say an action "returns" something, we always mean it returns a smart pointer to it. Also note that all actions are only executed for events that pass all preceding filters.</p>
<p>Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to produce several different results in one event loop. Instant actions trigger the event loop instantly.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Lazy action</b>  </th><th class="markdownTableHeadNone"><b>Description</b>   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#ae540b00addc441f9b504cbae0ef0a24d">Aggregate</a>  </td><td class="markdownTableBodyNone">Execute a user-defined accumulation operation on the processed column values.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a9b2f61f3333d1669e57055b9ae8be9d9">Book</a>  </td><td class="markdownTableBodyNone">Book execution of a custom action using a user-defined helper object.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9">Cache</a>  </td><td class="markdownTableBodyNone">Caches in contiguous memory columns' entries. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a37f9e00c2ece7f53fae50b740adc1456">Count</a>  </td><td class="markdownTableBodyNone">Return the number of events processed.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#aee68f4411f16f00a1d46eccb6d296f01">Display</a>  </td><td class="markdownTableBodyNone">Obtains the events in the dataset for the requested columns. The method returns a <a href="classROOT_1_1RDF_1_1RDisplay.html">RDisplay</a> instance which can be queried to get a compressed tabular representation on the standard output or a complete representation as a string.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a0cac4d08297c23d16de81ff25545440a">Fill</a>  </td><td class="markdownTableBodyNone">Fill a user-defined object with the values of the specified branches, as if by calling `Obj.Fill(branch1, branch2, ...).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a804b466ebdbddef5c7e3400cc6b89301">Graph</a>  </td><td class="markdownTableBodyNone">Fills a <a class="el" href="classTGraph.html" title="A Graph is a graphics object made of two arrays X and Y with npoints each. ">TGraph</a> with the two columns provided. If Multithread is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a247ca3aeb7ce5b95015b7fae72983055">Histo{1D,2D,3D}</a>  </td><td class="markdownTableBodyNone">Fill a {one,two,three}-dimensional histogram with the processed branch values.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a057179b1e77599466a0b02200d5cd8c3">Max</a>  </td><td class="markdownTableBodyNone">Return the maximum of processed branch values. If the type of the column is inferred, the return type is <code>double</code>, the type of the column otherwise.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#ade6b020284f2f4fe9d3b09246b5f376a">Mean</a>  </td><td class="markdownTableBodyNone">Return the mean of processed branch values.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a7005702189e601972b6d19ecebcdc80c">Min</a>  </td><td class="markdownTableBodyNone">Return the minimum of processed branch values. If the type of the column is inferred, the return type is <code>double</code>, the type of the column otherwise.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a8ef7dc16b0e9f7bc9cfbe2d9e5de0cef">Profile{1D,2D}</a>  </td><td class="markdownTableBodyNone">Fill a {one,two}-dimensional profile with the branch values that passed all filters.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a118e723ae29834df8f2a992ded347354">Reduce</a>  </td><td class="markdownTableBodyNone">Reduce (e.g. sum, merge) entries using the function (lambda, functor...) passed as argument. The function must have signature <code>T(T,T)</code> where <code>T</code> is the type of the branch. Return the final result of the reduction operation. An optional parameter allows initialization of the result object to non-default values.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a94f322531dcb25beb8f53a602e5d6332">Report</a>  </td><td class="markdownTableBodyNone">Obtains statistics on how many entries have been accepted and rejected by the filters. See the section on <a href="#named-filters-and-cutflow-reports">named filters</a> for a more detailed explanation. The method returns a RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a482c4e4f81fe1e421c016f89cd281572">StdDev</a>  </td><td class="markdownTableBodyNone">Return the unbiased standard deviation of the processed branch values.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a61d03407459120df6749af43ed506891">Sum</a>  </td><td class="markdownTableBodyNone">Return the sum of the values in the column. If the type of the column is inferred, the return type is <code>double</code>, the type of the column otherwise.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a4fd694773a2931b6b07737ddcd1e73b4">Take</a>  </td><td class="markdownTableBodyNone">Extract a column from the dataset as a collection of values. If the type of the column is a C-style array, the type stored in the return container is a <code><a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">ROOT::VecOps::RVec</a>&lt;T&gt;</code> to guarantee the lifetime of the data involved.   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Instant action</b>  </th><th class="markdownTableHeadNone"><b>Description</b>   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#ad2822a7ccb8a9afdf3e5b2ea321886ca">Foreach</a>  </td><td class="markdownTableBodyNone">Execute a user-defined function on each entry. Users are responsible for the thread-safety of this lambda when executing with implicit multi-threading enabled.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a3650ca30aae1ccd0d92bf3d680314129">ForeachSlot</a>  </td><td class="markdownTableBodyNone">Same as <code>Foreach</code>, but the user-defined function must take an extra <code>unsigned int slot</code> as its first parameter. <code>slot</code> will take a different value, <code>0</code> to <code>nThreads - 1</code>, for each thread of execution. This is meant as a helper in writing thread-safe <code>Foreach</code> actions when using <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> after <code><a class="el" href="namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f" title="Enable ROOT&#39;s implicit multi-threading for all objects and methods that provide an internal paralleli...">ROOT::EnableImplicitMT()</a></code>. <code>ForeachSlot</code> works just as well with single-thread execution: in that case <code>slot</code> will always be <code>0</code>.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8">Snapshot</a>  </td><td class="markdownTableBodyNone">Writes processed data-set to disk, in a new <code><a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a></code> and <code><a class="el" href="classTFile.html" title="A ROOT file is a suite of consecutive data records (TKey instances) with a well defined format...">TFile</a></code>. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. <code>Snapshot</code> can be made <em>lazy</em> setting the appropriate flage in the snapshot options.   </td></tr>
</table>
<h3>Other Operations</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Operation</b>  </th><th class="markdownTableHeadNone"><b>Description</b>   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a31ca327e4a192dcc05a4aac240e1a725">Alias</a>  </td><td class="markdownTableBodyNone">Introduce an alias for a particular column name.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a951fe60b74d3a9fda37df59fd1dac186">GetColumnNames</a>  </td><td class="markdownTableBodyNone">Get the names of all the available columns of the dataset.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#ad5c3fab8155aae8f614735df68430c58">GetDefinedColumnNames</a>  </td><td class="markdownTableBodyNone">Get the names of all the defined columns   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#ad3ccd813d9fed014ae6a080411c5b5a8">GetColumnType</a>  </td><td class="markdownTableBodyNone">Return the type of a given column as a string.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a951fe60b74d3a9fda37df59fd1dac186">GetColumnTypeNamesList</a>  </td><td class="markdownTableBodyNone">Return the list of type names of columns in the dataset.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a25026681111897058299161a70ad9bb2">GetFilterNames</a>  </td><td class="markdownTableBodyNone">Get all the filters defined. If called on a root node, all filters will be returned. For any other node, only the filters upstream of that node.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="classROOT_1_1RDF_1_1RInterface.html#a652f9ab3e8d2da9335b347b540a9a941">Display</a>  </td><td class="markdownTableBodyNone">Provides an ASCII representation of the columns types and contents of the dataset printable by the user.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="namespaceROOT_1_1RDF.html#adc17882b283c3d3ba85b1a236197c533">SaveGraph</a>  </td><td class="markdownTableBodyNone">Store the computation graph of an <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> in graphviz format for easy inspection.   </td></tr>
</table>
<h2><a class="anchor" id="introduction"></a>Introduction</h2>
<p>Users define their analysis as a sequence of operations to be performed on the data-frame object; the framework takes care of the management of the loop over entries as well as low-level details such as I/O and parallelisation. <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> provides methods to perform most common operations required by <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> analyses; at the same time, users can just as easily specify custom code that will be executed in the event loop.</p>
<p><code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> is built with a <em>modular</em> and <em>flexible</em> workflow in mind, summarised as follows:</p>
<ol type="1">
<li><b>build a data-frame</b> object by specifying your data-set</li>
<li><b>apply a series of transformations</b> to your data<ol type="a">
<li><b>filter</b> (e.g. apply some cuts) or</li>
<li><b>define</b> a new column (e.g. the result of an expensive computation on branches)</li>
</ol>
</li>
<li><b>apply actions</b> to the transformed data to produce results (e.g. fill a histogram)</li>
</ol>
<p>The following table shows how analyses based on <code><a class="el" href="classTTreeReader.html" title=" A simple, robust and fast interface to read values from ROOT columnar datasets such as TTree...">TTreeReader</a></code> and <code><a class="el" href="classTTree.html#ac4016b174665a086fe16695aad3356e2" title="Default Draw method for all objects. ">TTree::Draw</a></code> translate to <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code>. Follow the <a href="#crash-course">crash course</a> to discover more idiomatic and flexible ways to express analyses with <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code>. </p><table class="doxtable">
<tr>
<td><b><a class="el" href="classTTreeReader.html" title=" A simple, robust and fast interface to read values from ROOT columnar datasets such as TTree...">TTreeReader</a></b>  </td><td><b><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">ROOT::RDataFrame</a></b>   </td></tr>
<tr>
<td><div class="fragment"><div class="line"><a class="code" href="classTTreeReader.html">TTreeReader</a> reader(<span class="stringliteral">&quot;myTree&quot;</span>, <a class="code" href="namespacefile.html">file</a>);</div><div class="line"><a class="code" href="classTTreeReaderValue.html">TTreeReaderValue&lt;A_t&gt;</a> <a class="code" href="textangle_8C.html#a655a1c2a1ec25e8fcfb713772281e8f5">a</a>(reader, <span class="stringliteral">&quot;A&quot;</span>);</div><div class="line"><a class="code" href="classTTreeReaderValue.html">TTreeReaderValue&lt;B_t&gt;</a> <a class="code" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>(reader, <span class="stringliteral">&quot;B&quot;</span>);</div><div class="line"><a class="code" href="classTTreeReaderValue.html">TTreeReaderValue&lt;C_t&gt;</a> <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>(reader, <span class="stringliteral">&quot;C&quot;</span>);</div><div class="line"><span class="keywordflow">while</span>(reader.Next()) {</div><div class="line">   <span class="keywordflow">if</span>(IsGoodEvent(*<a class="code" href="textangle_8C.html#a655a1c2a1ec25e8fcfb713772281e8f5">a</a>, *<a class="code" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>, *<a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>))</div><div class="line">      DoStuff(*<a class="code" href="textangle_8C.html#a655a1c2a1ec25e8fcfb713772281e8f5">a</a>, *<a class="code" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>, *<a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>);</div><div class="line">}</div></div><!-- fragment -->  </td><td><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html">ROOT::RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <a class="code" href="namespacefile.html">file</a>, {<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>});</div><div class="line"><a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Filter(IsGoodEvent).Foreach(DoStuff);</div></div><!-- fragment -->   </td></tr>
<tr>
<td><b><a class="el" href="classTTree.html#ac4016b174665a086fe16695aad3356e2" title="Default Draw method for all objects. ">TTree::Draw</a></b>  </td><td><b><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">ROOT::RDataFrame</a></b>   </td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keyword">auto</span> t = <a class="code" href="namespacefile.html">file</a>-&gt;Get&lt;<a class="code" href="classTTree.html">TTree</a>&gt;(<span class="stringliteral">&quot;myTree&quot;</span>);</div><div class="line">t-&gt;<a class="code" href="classTTree.html#ac4016b174665a086fe16695aad3356e2">Draw</a>(<span class="stringliteral">&quot;x&quot;</span>, <span class="stringliteral">&quot;y &gt; 2&quot;</span>);</div></div><!-- fragment -->  </td><td><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html">ROOT::RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <a class="code" href="namespacefile.html">file</a>);</div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#acf9942d15f0dd0ac4fc5ca66096a3f6d">h</a> = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Filter(<span class="stringliteral">&quot;y &gt; 2&quot;</span>).Histo1D(<span class="stringliteral">&quot;x&quot;</span>);</div></div><!-- fragment -->   </td></tr>
</table>
<h2><a class="anchor" id="crash-course"></a> Crash course</h2>
<p>All snippets of code presented in the crash course can be executed in the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> interpreter. Simply precede them with </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT.html">ROOT</a>; <span class="comment">// RDataFrame&#39;s namespace</span></div></div><!-- fragment --><p> which is omitted for brevity. The terms "column" and "branch" are used interchangeably.</p>
<h3>Creating a <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></h3>
<p><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a>'s constructor is where the user specifies the dataset and, optionally, a default set of columns that operations should work with. Here are the most common methods to construct a <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> object: </p><div class="fragment"><div class="line"><span class="comment">// single file -- all ctors are equivalent</span></div><div class="line"><a class="code" href="classTFile.html">TFile</a> *<a class="code" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a> = <a class="code" href="classTFile.html#aec5f3fae0774aabfc615ebb4b00fe5e0">TFile::Open</a>(<span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><span class="keyword">auto</span> t = <a class="code" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>.Get&lt;<a class="code" href="classTTree.html">TTree</a>&gt;(<span class="stringliteral">&quot;treeName&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> d1(<span class="stringliteral">&quot;treeName&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> d2(<span class="stringliteral">&quot;treeName&quot;</span>, <a class="code" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>); <span class="comment">// same as TTreeReader</span></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> d3(*t); <span class="comment">// TTreeReader takes a pointer, RDF takes a reference</span></div><div class="line"></div><div class="line"><span class="comment">// multiple files -- all ctors are equivalent</span></div><div class="line">std::vector&lt;std::string&gt; files = {<span class="stringliteral">&quot;file1.root&quot;</span>, <span class="stringliteral">&quot;file2.root&quot;</span>};</div><div class="line"><a class="code" href="classTChain.html">TChain</a> chain(<span class="stringliteral">&quot;myTree&quot;</span>);</div><div class="line">chain.Add(<span class="stringliteral">&quot;file1.root&quot;</span>);</div><div class="line">chain.Add(<span class="stringliteral">&quot;file2.root&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> d4(<span class="stringliteral">&quot;myTree&quot;</span>, {<span class="stringliteral">&quot;file1.root&quot;</span>, <span class="stringliteral">&quot;file2.root&quot;</span>});</div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> d5(<span class="stringliteral">&quot;myTree&quot;</span>, files);</div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> d6(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file*.root&quot;</span>); <span class="comment">// see TRegexp&#39;s documentation for a list of valid regexes</span></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> d7(chain);</div></div><!-- fragment --><p> Additionally, users can construct a <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> specifying just an integer number. This is the number of "events" that will be generated by this <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a>. </p><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(10); <span class="comment">// a RDF with 10 entries (and no columns/branches, for now)</span></div><div class="line"><a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Foreach([] { <span class="keyword">static</span> <span class="keywordtype">int</span> i = 0; std::cout &lt;&lt; i++ &lt;&lt; std::endl; }); <span class="comment">// silly example usage: count to ten</span></div></div><!-- fragment --><p> This is useful to generate simple data-sets on the fly: the contents of each event can be specified via the <code>Define</code> transformation (explained below). For example, we have used this method to generate Pythia events (with a <code>Define</code> transformation) and write them to disk in parallel (with the <code>Snapshot</code> action).</p>
<h3>Filling a histogram</h3>
<p>Let's now tackle a very common task, filling a histogram: </p><div class="fragment"><div class="line"><span class="comment">// Fill a TH1D with the &quot;MET&quot; branch</span></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#acf9942d15f0dd0ac4fc5ca66096a3f6d">h</a> = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Histo1D(<span class="stringliteral">&quot;MET&quot;</span>);</div><div class="line"><a class="code" href="RSha256_8hxx.html#acf9942d15f0dd0ac4fc5ca66096a3f6d">h</a>-&gt;Draw();</div></div><!-- fragment --><p> The first line creates a <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> associated to the <code><a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a></code> "myTree". This tree has a branch named "MET".</p>
<p><code>Histo1D</code> is an <em>action</em>; it returns a smart pointer (a <code>RResultPtr</code> to be precise) to a <code><a class="el" href="classTH1D.html" title="1-D histogram with a double per channel (see TH1 documentation)} ">TH1D</a></code> histogram filled with the <code>MET</code> of all events. If the quantity stored in the branch is a collection (e.g. a vector or an array), the histogram is filled with its elements.</p>
<p>You can use the objects returned by actions as if they were pointers to the desired results. There are many other possible <a href="#overview">actions</a>, and all their results are wrapped in smart pointers; we'll see why in a minute.</p>
<h3>Applying a filter</h3>
<p>Let's say we want to cut over the value of branch "MET" and count how many events pass this cut. This is one way to do it: </p><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a> = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Filter(<span class="stringliteral">&quot;MET &gt; 4.&quot;</span>).Count();</div><div class="line">std::cout &lt;&lt; *<a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a> &lt;&lt; std::endl;</div></div><!-- fragment --><p> The filter string (which must contain a valid c++ expression) is applied to the specified branches for each event; the name and types of the columns are inferred automatically. The string expression is required to return a <code>bool</code> which signals whether the event passes the filter (<code>true</code>) or not (<code>false</code>).</p>
<p>You can think of your data as "flowing" through the chain of calls, being transformed, filtered and finally used to perform actions. Multiple <code>Filter</code> calls can be chained one after another.</p>
<p>Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small runtime overhead, as <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> needs to just-in-time compile the string into C++ code. When more freedom is required or runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet, but it can be any kind of function or even a functor class), together with a list of branch names. This snippet is analogous to the one above: </p><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><span class="keyword">auto</span> metCut = [](<span class="keywordtype">double</span> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>) { <span class="keywordflow">return</span> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a> &gt; 4.; }; <span class="comment">// a c++11 lambda function checking &quot;x &gt; 4&quot;</span></div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a> = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Filter(metCut, {<span class="stringliteral">&quot;MET&quot;</span>}).<a class="code" href="classROOT_1_1RDF_1_1RInterface.html#a37f9e00c2ece7f53fae50b740adc1456">Count</a>();</div><div class="line">std::cout &lt;&lt; *<a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a> &lt;&lt; std::endl;</div></div><!-- fragment --><p>An example of a more complex filter expressed as a string containing C++ code is shown below</p>
<div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><span class="keyword">auto</span> df = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Define(<span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;std::array&lt;double, 4&gt; p{px, py, pz}; return p;&quot;</span>)</div><div class="line">           .Filter(<span class="stringliteral">&quot;double p2 = 0.0; for (auto&amp;&amp; x : p) p2 += x*x; return sqrt(p2) &lt; 10.0;&quot;</span>);</div></div><!-- fragment --><p>The code snippet above defines a column <code>p</code> that is a fixed-size array using the component column names and then filters on its magnitude by looping over its elements. It must be noted that the usage of strings to define columns like the one above is a major advantage when using <a class="el" href="namespacePyROOT.html">PyROOT</a>. However, only constants and data coming from other columns in the dataset can be involved in the code passed as a string. Local variables and functions cannot be used, since the interpreter will not know how to find them. When capturing local state is necessary, a C++ callable can be used.</p>
<p>More information on filters and how to use them to automatically generate cutflow reports can be found <a href="#Filters">below</a>.</p>
<h3>Defining custom columns</h3>
<p>Let's now consider the case in which "myTree" contains two quantities "x" and "y", but our analysis relies on a derived quantity <code>z = sqrt(x*x + y*y)</code>. Using the <code>Define</code> transformation, we can create a new column in the data-set containing the variable "z": </p><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><span class="keyword">auto</span> sqrtSum = [](<span class="keywordtype">double</span> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>, <span class="keywordtype">double</span> <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>) { <span class="keywordflow">return</span> <a class="code" href="TMath_8h.html#acdb55c1010a6c379a49db0201bf55d89">sqrt</a>(<a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>*<a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a> + <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>*<a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>); };</div><div class="line"><span class="keyword">auto</span> zMean = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Define(<span class="stringliteral">&quot;z&quot;</span>, sqrtSum, {<span class="stringliteral">&quot;x&quot;</span>,<span class="stringliteral">&quot;y&quot;</span>}).<a class="code" href="classROOT_1_1RDF_1_1RInterface.html#ade6b020284f2f4fe9d3b09246b5f376a">Mean</a>(<span class="stringliteral">&quot;z&quot;</span>);</div><div class="line">std::cout &lt;&lt; *zMean &lt;&lt; std::endl;</div></div><!-- fragment --><p> <code>Define</code> creates the variable "z" by applying <code>sqrtSum</code> to "x" and "y". Later in the chain of calls we refer to variables created with <code>Define</code> as if they were actual tree branches/columns, but they are evaluated on demand, at most once per event. As with filters, <code>Define</code> calls can be chained with other transformations to create multiple custom columns. <code>Define</code> and <code>Filter</code> transformations can be concatenated and intermixed at will.</p>
<p>As with filters, it is possible to specify new columns as string expressions. This snippet is analogous to the one above: </p><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><span class="keyword">auto</span> zMean = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Define(<span class="stringliteral">&quot;z&quot;</span>, <span class="stringliteral">&quot;sqrt(x*x + y*y)&quot;</span>).Mean(<span class="stringliteral">&quot;z&quot;</span>);</div><div class="line">std::cout &lt;&lt; *zMean &lt;&lt; std::endl;</div></div><!-- fragment --><p> Again the names of the branches used in the expression and their types are inferred automatically. The string must be valid c++ and is just-in-time compiled by the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> interpreter, cling &ndash; the process has a small runtime overhead.</p>
<p>Previously, when showing the different ways a <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> can be created, we showed a constructor that only takes a number of entries a parameter. In the following example we show how to combine such an "empty" <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> with <code>Define</code> transformations to create a data-set on the fly. We then save the generated data on disk using the <code>Snapshot</code> action. </p><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(100); <span class="comment">// a RDF that will generate 100 entries (currently empty)</span></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a> = -1;</div><div class="line"><span class="keyword">auto</span> d_with_columns = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Define(<span class="stringliteral">&quot;x&quot;</span>, [&amp;<a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>] { <span class="keywordflow">return</span> ++<a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>; })</div><div class="line">                       .<a class="code" href="classROOT_1_1RDF_1_1RInterface.html#a7d48eb23b4378e99ebccb35e94ad025a">Define</a>(<span class="stringliteral">&quot;xx&quot;</span>, [&amp;<a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>] { <span class="keywordflow">return</span> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>*<a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>; });</div><div class="line">d_with_columns.Snapshot(<span class="stringliteral">&quot;myNewTree&quot;</span>, <span class="stringliteral">&quot;newfile.root&quot;</span>);</div></div><!-- fragment --><p> This example is slightly more advanced than what we have seen so far: for starters, it makes use of lambda captures (a simple way to make external variables available inside the body of c++ lambdas) to act on the same variable <code>x</code> from both <code>Define</code> transformations. Secondly we have <em>stored</em> the transformed data-frame in a variable. This is always possible: at each point of the transformation chain, users can store the status of the data-frame for further use (more on this <a href="#callgraphs">below</a>).</p>
<p>You can read more about defining new columns <a href="#custom-columns">here</a>.</p>
<div class="image">
<img src="RDF_Graph.png" alt="RDF_Graph.png"/>
<div class="caption">
A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action.</div></div>
 <h3>Running on a range of entries</h3>
<p>It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> offers the concept of ranges as a node of the <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> chain of transformations; this means that filters, columns and actions can be concatenated to and intermixed with <code>Range</code>s. If a range is specified after a filter, the range will act exclusively on the entries passing the filter &ndash; it will not even count the other entries! The same goes for a <code>Range</code> hanging from another <code>Range</code>. Here are some commented examples: </p><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><span class="comment">// Here we store a data-frame that loops over only the first 30 entries in a variable</span></div><div class="line"><span class="keyword">auto</span> d30 = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Range(30);</div><div class="line"><span class="comment">// This is how you pick all entries from 15 onwards</span></div><div class="line"><span class="keyword">auto</span> d15on = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Range(15, 0);</div><div class="line"><span class="comment">// We can specify a stride too, in this case we pick an event every 3</span></div><div class="line"><span class="keyword">auto</span> d15each3 = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Range(0, 15, 3);</div></div><!-- fragment --><p> Note that ranges are not available when multi-threading is enabled. More information on ranges is available <a href="#ranges">here</a>.</p>
<h3>Executing multiple actions in the same event loop</h3>
<p>As a final example let us apply two different cuts on branch "MET" and fill two different histograms with the "pt\_v" of the filtered events. By now, you should be able to easily understand what's happening: </p><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;treeName&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line"><span class="keyword">auto</span> <a class="code" href="legend1_8C.html#aaf2545ecc018288fcf442904a5af9e83">h1</a> = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Filter(<span class="stringliteral">&quot;MET &gt; 10&quot;</span>).Histo1D(<span class="stringliteral">&quot;pt_v&quot;</span>);</div><div class="line"><span class="keyword">auto</span> h2 = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Histo1D(<span class="stringliteral">&quot;pt_v&quot;</span>);</div><div class="line"><a class="code" href="legend1_8C.html#aaf2545ecc018288fcf442904a5af9e83">h1</a>-&gt;<a class="code" href="classTH1.html#aa53a024a9e94d5ec91e3ef49e49563da">Draw</a>();       <span class="comment">// event loop is run once here</span></div><div class="line">h2-&gt;Draw(<span class="stringliteral">&quot;SAME&quot;</span>); <span class="comment">// no need to run the event loop again</span></div></div><!-- fragment --><p> <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> executes all above actions by <b>running the event-loop only once</b>. The trick is that actions are not executed at the moment they are called, but they are <b>lazy</b>, i.e. delayed until the moment one of their results is accessed through the smart pointer. At that time, the event loop is triggered and <em>all</em> results are produced simultaneously.</p>
<p>It is therefore good practice to declare all your transformations and actions <em>before</em> accessing their results, allowing <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> to run the loop once and produce all results in one go.</p>
<h3>Going parallel</h3>
<p>Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores. The only modification required to the snippets would be the addition of this line <em>before</em> constructing the main data-frame object: </p><div class="fragment"><div class="line"><a class="code" href="namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f">ROOT::EnableImplicitMT</a>();</div></div><!-- fragment --><p> Simple as that. More details are given <a href="#parallel-execution">below</a>.</p>
<h2><a class="anchor" id="more-features"></a>More features</h2>
<p>Here is a list of the most important features that have been omitted in the "Crash course" for brevity. You don't need to read all these to start using <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code>, but they are useful to save typing time and runtime.</p>
<h3>Programmatically get the list of column names</h3>
<p>The <code>GetColumnsNames()</code> method returns the list of valid column names for the dataset: </p><div class="fragment"><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>);</div><div class="line">std::vector&lt;std::string&gt; colNames = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.GetColumnNames();</div></div><!-- fragment --><h3>Reading and manipulating collections</h3>
<p>When using <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> to read data from a <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> file, users can specify that the type of a branch is <code>RVec&lt;T&gt;</code> to indicate the branch is a c-style array, a <code>std::vector</code> or any other collection type associated to a contiguous storage in memory.</p>
<p>Column values of type <code>RVec&lt;T&gt;</code> perform no copy of the underlying array data and offer a rich interface to operate on the array elements in a vectorised fashion.</p>
<p>The <code>RVec&lt;T&gt;</code> type signals to <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> that a special behaviour needs to be adopted when snapshotting a dataset on disk. Indeed, if columns which are variable size C arrays are treated via the <code>RVec&lt;T&gt;</code>, <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> will correctly persistify them - if anything else is adopted, for example <code>std::span</code>, only the first element of the array will be written.</p>
<p>Learn more on <a href="https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html">RVec</a>.</p>
<h3>Callbacks</h3>
<p>It's possible to schedule execution of arbitrary functions (callbacks) during the event loop. Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running, drawing a partially-filled histogram every time a certain number of new entries is processed, or event displaying a progress bar while the event loop runs.</p>
<p>For example one can draw an up-to-date version of a result histogram every 100 entries like this: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#acf9942d15f0dd0ac4fc5ca66096a3f6d">h</a> = tdf.Histo1D(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><a class="code" href="classTCanvas.html">TCanvas</a> <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>(<span class="stringliteral">&quot;c&quot;</span>,<span class="stringliteral">&quot;x hist&quot;</span>);</div><div class="line"><a class="code" href="RSha256_8hxx.html#acf9942d15f0dd0ac4fc5ca66096a3f6d">h</a>.OnPartialResult(100, [&amp;<a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>](<a class="code" href="classTH1D.html">TH1D</a> &amp;h_) { <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>.cd(); h_.<a class="code" href="classTH1.html#aa53a024a9e94d5ec91e3ef49e49563da">Draw</a>(); <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>.Update(); });</div><div class="line"><a class="code" href="RSha256_8hxx.html#acf9942d15f0dd0ac4fc5ca66096a3f6d">h</a>-&gt;Draw(); <span class="comment">// event loop runs here, this `Draw` is executed after the event loop is finished</span></div></div><!-- fragment --><p>Callbacks are registered to a RResultPtr and must be callables that takes a reference to the result type as argument and return nothing. <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> will invoke registered callbacks passing partial action results as arguments to them (e.g. a histogram filled with a part of the selected events).</p>
<p>Read more on RResultPtr::OnPartialResult().</p>
<h3>Default branch lists</h3>
<p>When constructing a <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> object, it is possible to specify a <b>default column list</b> for your analysis, in the usual form of a list of strings representing branch/column names. The default column list will be used as a fallback whenever a list specific to the transformation/action is not present. <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> will take as many of these columns as needed, ignoring trailing extra names if present. </p><div class="fragment"><div class="line"><span class="comment">// use &quot;b1&quot; and &quot;b2&quot; as default branches</span></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> d1(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>, {<span class="stringliteral">&quot;b1&quot;</span>,<span class="stringliteral">&quot;b2&quot;</span>});</div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#acf9942d15f0dd0ac4fc5ca66096a3f6d">h</a> = d1.Filter([](<span class="keywordtype">int</span> b1, <span class="keywordtype">int</span> b2) { <span class="keywordflow">return</span> b1 &gt; b2; }) <span class="comment">// will act on &quot;b1&quot; and &quot;b2&quot;</span></div><div class="line">           .<a class="code" href="classROOT_1_1RDF_1_1RInterface.html#a247ca3aeb7ce5b95015b7fae72983055">Histo1D</a>(); <span class="comment">// will act on &quot;b1&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// just one default branch this time</span></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> d2(<span class="stringliteral">&quot;myTree&quot;</span>, <span class="stringliteral">&quot;file.root&quot;</span>, {<span class="stringliteral">&quot;b1&quot;</span>});</div><div class="line"><span class="keyword">auto</span> min = d2.Filter([](<span class="keywordtype">double</span> b2) { <span class="keywordflow">return</span> b2 &gt; 0; }, {<span class="stringliteral">&quot;b2&quot;</span>}) <span class="comment">// we can still specify non-default branch lists</span></div><div class="line">             .<a class="code" href="classROOT_1_1RDF_1_1RInterface.html#a7005702189e601972b6d19ecebcdc80c">Min</a>(); <span class="comment">// returns the minimum value of &quot;b1&quot; for the filtered entries</span></div></div><!-- fragment --><h3><a class="anchor" id="ImplicitColumns"></a> Implicit Columns</h3>
<p>Every instance of <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> is created with two special columns called <code>rdfentry_</code> and <code>rdfslot_</code>. The <code>rdfentry_</code> column is an unsigned 64-bit integer holding the current entry number while <code>rdfslot_</code> is an unsigned 32-bit integer holding the index of the current data processing slot. For backwards compatibility reasons, the names <code>tdfentry_</code> and <code>tdfslot_</code> are also accepted. These columns are not considered by operations such as <a href="classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9">Cache</a> or <a href="classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8">Snapshot</a>. The <em>cached</em> or <em>snapshot</em> data frame provides "its own" values for these columns which do not necessarily correspond to the ones of the mother data frame. This is most notably the case where filters are used before deriving a cached/persistified dataframe.</p>
<p>Note that in multi-thread event loops the values of <code>rdfentry_</code> <em>do not</em> correspond to what would be the entry numbers of a <a class="el" href="classTChain.html" title="A chain is a collection of files containing TTree objects. ">TChain</a> constructed over the same set of <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> files, as the entries are processed in an unspecified order.</p>
<h3>Branch type guessing and explicit declaration of branch types</h3>
<p>C++ is a statically typed language: all types must be known at compile-time. This includes the types of the <code><a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a></code> branches we want to work on. For filters, temporary columns and some of the actions, <b>branch types are deduced from the signature</b> of the relevant filter function/temporary column expression/action function: </p><div class="fragment"><div class="line"><span class="comment">// here b1 is deduced to be `int` and b2 to be `double`</span></div><div class="line">dataFrame.Filter([](<span class="keywordtype">int</span> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>, <span class="keywordtype">double</span> <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>) { <span class="keywordflow">return</span> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a> &gt; 0 &amp;&amp; <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a> &lt; 0.; }, {<span class="stringliteral">&quot;b1&quot;</span>, <span class="stringliteral">&quot;b2&quot;</span>});</div></div><!-- fragment --><p> If we specify an incorrect type for one of the branches, an exception with an informative message will be thrown at runtime, when the branch value is actually read from the <code><a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a></code>: <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> detects type mismatches. The same would happen if we swapped the order of "b1" and "b2" in the branch list passed to <code>Filter</code>.</p>
<p>Certain actions, on the other hand, do not take a function as argument (e.g. <code>Histo1D</code>), so we cannot deduce the type of the branch at compile-time. In this case **<code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> infers the type of the branch** from the <code><a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a></code> itself. This is why we never needed to specify the branch types for all actions in the above snippets.</p>
<p>When the branch type is not a common one such as <code>int</code>, <code>double</code>, <code>char</code> or <code>float</code> it is nonetheless good practice to specify it as a template parameter to the action itself, like this: </p><div class="fragment"><div class="line">dataFrame.Histo1D(<span class="stringliteral">&quot;b1&quot;</span>); <span class="comment">// OK, the type of &quot;b1&quot; is deduced at runtime</span></div><div class="line">dataFrame.Min&lt;MyNumber_t&gt;(<span class="stringliteral">&quot;myObject&quot;</span>); <span class="comment">// OK, &quot;myObject&quot; is deduced to be of type `MyNumber_t`</span></div></div><!-- fragment --><p>Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.</p>
<h3>Generic actions</h3>
<p><code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> strives to offer a comprehensive set of standard actions that can be performed on each event. At the same time, it <b>allows users to execute arbitrary code (i.e. a generic action) inside the event loop</b> through the <code>Foreach</code> and <code>ForeachSlot</code> actions.</p>
<p><code>Foreach(f, columnList)</code> takes a function <code>f</code> (lambda expression, free function, functor...) and a list of columns, and executes <code>f</code> on those columns for each event. The function passed must return nothing (i.e. <code>void</code>). It can be used to perform actions that are not already available in the interface. For example, the following snippet evaluates the root mean square of column "b": </p><div class="fragment"><div class="line"><span class="comment">// Single-thread evaluation of RMS of column &quot;b&quot; using Foreach</span></div><div class="line"><span class="keywordtype">double</span> sumSq = 0.;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="legend1_8C.html#a16daaa7b596941b23915a1ac1be5b42c">n</a> = 0;</div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;bTree&quot;</span>, bFilePtr);</div><div class="line"><a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Foreach([&amp;sumSq, &amp;<a class="code" href="legend1_8C.html#a16daaa7b596941b23915a1ac1be5b42c">n</a>](<span class="keywordtype">double</span> <a class="code" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>) { ++<a class="code" href="legend1_8C.html#a16daaa7b596941b23915a1ac1be5b42c">n</a>; sumSq += <a class="code" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>*<a class="code" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>; }, {<span class="stringliteral">&quot;b&quot;</span>});</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;rms of b: &quot;</span> &lt;&lt; <a class="code" href="TMath_8h.html#acdb55c1010a6c379a49db0201bf55d89">std::sqrt</a>(sumSq / <a class="code" href="legend1_8C.html#a16daaa7b596941b23915a1ac1be5b42c">n</a>) &lt;&lt; std::endl;</div></div><!-- fragment --><p> When executing on multiple threads, users are responsible for the thread-safety of the expression passed to <code>Foreach</code>: each thread will execute the expression multiple times (once per entry) in an unspecified order. The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of <code>rms</code>; but this is probably too much head-scratch for such a simple operation.</p>
<p><code>ForeachSlot</code> can help in this situation. It is an alternative version of <code>Foreach</code> for which the function takes an additional parameter besides the columns it should be applied to: an <code>unsigned int slot</code> parameter, where <code>slot</code> is a number indicating which thread (0, 1, 2 , ..., poolSize - 1) the function is being run in. More specifically, <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> guarantees that <code>ForeachSlot</code> will invoke the user expression with different <code>slot</code> parameters for different concurrent executions (there is no guarantee that a certain slot number will always correspond to a given thread id, though). We can take advantage of <code>ForeachSlot</code> to evaluate a thread-safe root mean square of branch "b": </p><div class="fragment"><div class="line"><span class="comment">// Thread-safe evaluation of RMS of branch &quot;b&quot; using ForeachSlot</span></div><div class="line"><a class="code" href="namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f">ROOT::EnableImplicitMT</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSlots = <a class="code" href="namespaceROOT.html#a93a60d5e8722b29ac3c6c15b6f947152">ROOT::GetImplicitMTPoolSize</a>();</div><div class="line">std::vector&lt;double&gt; sumSqs(nSlots, 0.);</div><div class="line">std::vector&lt;unsigned int&gt; <a class="code" href="namespaceTGeant4Unit.html#a9b0630f8addb68eecc990baa3a5e6e15">ns</a>(nSlots, 0);</div><div class="line"></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(<span class="stringliteral">&quot;bTree&quot;</span>, bFilePtr);</div><div class="line"><a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.ForeachSlot([&amp;sumSqs, &amp;<a class="code" href="namespaceTGeant4Unit.html#a9b0630f8addb68eecc990baa3a5e6e15">ns</a>](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> slot, <span class="keywordtype">double</span> <a class="code" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>) { sumSqs[slot] += <a class="code" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>*<a class="code" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>; <a class="code" href="namespaceTGeant4Unit.html#a9b0630f8addb68eecc990baa3a5e6e15">ns</a>[slot] += 1; }, {<span class="stringliteral">&quot;b&quot;</span>});</div><div class="line"><span class="keywordtype">double</span> sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); <span class="comment">// sum all squares</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="legend1_8C.html#a16daaa7b596941b23915a1ac1be5b42c">n</a> = std::accumulate(<a class="code" href="namespaceTGeant4Unit.html#a9b0630f8addb68eecc990baa3a5e6e15">ns</a>.begin(), <a class="code" href="namespaceTGeant4Unit.html#a9b0630f8addb68eecc990baa3a5e6e15">ns</a>.end(), 0); <span class="comment">// sum all counts</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;rms of b: &quot;</span> &lt;&lt; <a class="code" href="TMath_8h.html#acdb55c1010a6c379a49db0201bf55d89">std::sqrt</a>(sumSq / <a class="code" href="legend1_8C.html#a16daaa7b596941b23915a1ac1be5b42c">n</a>) &lt;&lt; std::endl;</div></div><!-- fragment --><p> You see how we created one <code>double</code> variable for each thread in the pool, and later merged their results via <code>std::accumulate</code>.</p>
<h3>Friend trees</h3>
<p>Friend trees are supported by <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a>. In order to deal with friend trees with <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a>, the user is required to build the tree and its friends and instantiate a <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> with it. </p><div class="fragment"><div class="line"><a class="code" href="classTTree.html">TTree</a> t([...]);</div><div class="line"><a class="code" href="classTTree.html">TTree</a> ft([...]);</div><div class="line">t.AddFriend(ft, <span class="stringliteral">&quot;myFriend&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(t);</div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a> = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Filter(<span class="stringliteral">&quot;myFriend.MyCol == 42&quot;</span>);</div></div><!-- fragment --><h3>Reading file formats different from <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a>'s</h3>
<p><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> can be interfaced with RDataSources. The RDataSource interface defines an API that <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> can use to read arbitrary data formats.</p>
<p>A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure methods) provides an adaptor that <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> can leverage to read any kind of tabular data formats. <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or "cursors" for selected columns and to advance the readers to the desired data entry. Some predefined RDataSources are natively provided by <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> such as the <code>RCsvDS</code> which allows to read comma separated files: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tdf = <a class="code" href="namespaceROOT_1_1RDF.html#adfcf71db735afb58ee3f3c478d04a8af">ROOT::RDF::MakeCsvDataFrame</a>(<span class="stringliteral">&quot;MuRun2010B.csv&quot;</span>);</div><div class="line"><span class="keyword">auto</span> filteredEvents =</div><div class="line">   tdf.Filter(<span class="stringliteral">&quot;Q1 * Q2 == -1&quot;</span>)</div><div class="line">      .Define(<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))&quot;</span>);</div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#acf9942d15f0dd0ac4fc5ca66096a3f6d">h</a> = filteredEvents.Histo1D(<span class="stringliteral">&quot;m&quot;</span>);</div><div class="line"><a class="code" href="RSha256_8hxx.html#acf9942d15f0dd0ac4fc5ca66096a3f6d">h</a>-&gt;Draw();</div></div><!-- fragment --><h3><a class="anchor" id="callgraphs"></a>Call graphs (storing and reusing sets of transformations)</h3>
<p>Sets of transformations can be stored as variables** and reused multiple times to create <b>call graphs</b> in which several paths of filtering/creation of columns are executed simultaneously; we often refer to this as "storing the
state of the chain".</p>
<p>This feature can be used, for example, to create a temporary column once and use it in several subsequent filters or actions, or to apply a strict filter to the data-set <em>before</em> executing several other transformations and actions, effectively reducing the amount of events processed.</p>
<p>Let's try to make this clearer with a commented example: </p><div class="fragment"><div class="line"><span class="comment">// build the data-frame and specify a default column list</span></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>(treeName, filePtr, {<span class="stringliteral">&quot;var1&quot;</span>, <span class="stringliteral">&quot;var2&quot;</span>, <span class="stringliteral">&quot;var3&quot;</span>});</div><div class="line"></div><div class="line"><span class="comment">// apply a cut and save the state of the chain</span></div><div class="line"><span class="keyword">auto</span> filtered = <a class="code" href="RSha256_8hxx.html#a23b5b0a85bf5762c93a855f40c0343ce">d</a>.Filter(myBigCut);</div><div class="line"></div><div class="line"><span class="comment">// plot branch &quot;var1&quot; at this point of the chain</span></div><div class="line"><span class="keyword">auto</span> <a class="code" href="legend1_8C.html#aaf2545ecc018288fcf442904a5af9e83">h1</a> = filtered.Histo1D(<span class="stringliteral">&quot;var1&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// create a new branch &quot;vec&quot; with a vector extracted from a complex object (only for filtered entries)</span></div><div class="line"><span class="comment">// and save the state of the chain</span></div><div class="line"><span class="keyword">auto</span> newBranchFiltered = filtered.Define(<span class="stringliteral">&quot;vec&quot;</span>, [](<span class="keyword">const</span> Obj&amp; o) { <span class="keywordflow">return</span> o.getVector(); }, {<span class="stringliteral">&quot;obj&quot;</span>});</div><div class="line"></div><div class="line"><span class="comment">// apply a cut and fill a histogram with &quot;vec&quot;</span></div><div class="line"><span class="keyword">auto</span> h2 = newBranchFiltered.Filter(cut1).Histo1D(<span class="stringliteral">&quot;vec&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// apply a different cut and fill a new histogram</span></div><div class="line"><span class="keyword">auto</span> h3 = newBranchFiltered.Filter(cut2).Histo1D(<span class="stringliteral">&quot;vec&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Inspect results</span></div><div class="line">h2-&gt;<a class="code" href="classTH1.html#aa53a024a9e94d5ec91e3ef49e49563da">Draw</a>(); <span class="comment">// first access to an action result: run event-loop!</span></div><div class="line">h3-&gt;Draw(<span class="stringliteral">&quot;SAME&quot;</span>); <span class="comment">// event loop does not need to be run again here..</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Entries in h1: &quot;</span> &lt;&lt; <a class="code" href="legend1_8C.html#aaf2545ecc018288fcf442904a5af9e83">h1</a>-&gt;<a class="code" href="classTH1.html#a9b9fc72d52be07372979ab74d1365fcf">GetEntries</a>() &lt;&lt; std::endl; <span class="comment">// ..or here</span></div></div><!-- fragment --><p> <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> detects when several actions use the same filter or the same temporary column, and <b>only evaluates each filter or temporary column once per event</b>, regardless of how many times that result is used down the call graph. Objects read from each column are <b>built once and never copied</b>, for maximum efficiency. When "upstream" filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated, so it might be advisable to put the strictest filters first in the chain.</p>
<h3><a class="anchor" id="representgraph"></a>Printing the computation graph</h3>
<p>It is possible to print the computation graph from any node to obtain a dot representation either on the standard output or in a file.</p>
<p>Invoking the function <a class="el" href="namespaceROOT_1_1RDF.html#ac06a36e745255fb8744b1e0a563074c9" title="Create a graphviz representation of the dataframe computation graph, return it as a string...">ROOT::RDF::SaveGraph()</a> on any node that is not the head node, the computation graph of the branch the node belongs to is printed. By using the head node, the entire computation graph is printed.</p>
<p>Following there is an example of usage: </p><div class="fragment"><div class="line"><span class="comment">// First, a sample computational graph is built</span></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html">ROOT::RDataFrame</a> df(<span class="stringliteral">&quot;tree&quot;</span>, <span class="stringliteral">&quot;f.root&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> df2 = df.Define(<span class="stringliteral">&quot;x&quot;</span>, []() { <span class="keywordflow">return</span> 1; })</div><div class="line">             .<a class="code" href="classROOT_1_1RDF_1_1RInterface.html#a70284a3bedc72b19610aaa91b5007ebd">Filter</a>(<span class="stringliteral">&quot;col0 % 1 == col0&quot;</span>)</div><div class="line">             .Filter([](<span class="keywordtype">int</span> b1) { <span class="keywordflow">return</span> b1 &lt;2; }, {<span class="stringliteral">&quot;cut1&quot;</span>})</div><div class="line">             .<a class="code" href="classROOT_1_1RDF_1_1RInterface.html#a7d48eb23b4378e99ebccb35e94ad025a">Define</a>(<span class="stringliteral">&quot;y&quot;</span>, []() { <span class="keywordflow">return</span> 1; });</div><div class="line"></div><div class="line"><span class="keyword">auto</span> count =  df2.Count();</div><div class="line"></div><div class="line"><span class="comment">// Prints the graph to the rd1.dot file in the current directory</span></div><div class="line"><a class="code" href="namespaceROOT_1_1RDF.html#ac06a36e745255fb8744b1e0a563074c9">ROOT::RDF::SaveGraph</a>(rd1, <span class="stringliteral">&quot;./mydot.dot&quot;</span>);</div><div class="line"><span class="comment">// Prints the graph to standard output</span></div><div class="line"><a class="code" href="namespaceROOT_1_1RDF.html#ac06a36e745255fb8744b1e0a563074c9">ROOT::RDF::SaveGraph</a>(rd1);</div></div><!-- fragment --><h3><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> variables as function arguments and return values</h3>
<p><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into) functions and to return them from functions. However, in general each dataframe node will have a different C++ type, which includes all available compile-time information about what that node does. One way to cope with this complication is to use template functions and/or C++14 auto return types: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RDF&gt;</div><div class="line"><span class="keyword">auto</span> ApplySomeFilters(RDF df)</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> df.Filter(<span class="stringliteral">&quot;x &gt; 0&quot;</span>).Filter([](<span class="keywordtype">int</span> <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>) { <span class="keywordflow">return</span> <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a> &lt; 0; }, {<span class="stringliteral">&quot;y&quot;</span>});</div><div class="line">}</div></div><!-- fragment --><p>A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be converted to the common type <a class="el" href="namespaceROOT_1_1RDF.html#a2ddba8d440832e128b144b06b264263f">ROOT::RDF::RNode</a>: </p><div class="fragment"><div class="line"><span class="comment">// a function that conditionally adds a Range to a RDataFrame node.</span></div><div class="line"><a class="code" href="namespaceROOT_1_1RDF.html#a2ddba8d440832e128b144b06b264263f">RNode</a> MaybeAddRange(<a class="code" href="namespaceROOT_1_1RDF.html#a2ddba8d440832e128b144b06b264263f">RNode</a> df, <span class="keywordtype">bool</span> mustAddRange)</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> mustAddRange ? df.Range(1) : df;</div><div class="line">}</div><div class="line"><span class="comment">// use as :</span></div><div class="line"><a class="code" href="classROOT_1_1RDataFrame.html">ROOT::RDataFrame</a> df(10);</div><div class="line"><span class="keyword">auto</span> maybeRangedDF = MaybeAddRange(df, <span class="keyword">true</span>);</div></div><!-- fragment --><p>The conversion to <a class="el" href="namespaceROOT_1_1RDF.html#a2ddba8d440832e128b144b06b264263f">ROOT::RDF::RNode</a> is cheap, but it will introduce an extra virtual call during the <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> event loop (in most cases, the resulting performance impact should be negligible).</p>
<p>As a final note, remember that <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> actions do not return another dataframe, but a RResultPtr&lt;T&gt;, where T is the type of the result of the action.</p>
<p>Read more on this topic <a href="https://root.cern.ch/doc/master/classROOT_1_1RDF_1_1RInterface.html#a6909f04c05723de79f97a14b092318b1">here</a>.</p>
<h2><a class="anchor" id="transformations"></a>Transformations</h2>
<h3><a class="anchor" id="Filters"></a> Filters</h3>
<p>A filter is defined through a call to <code>Filter(f, columnList)</code>. <code>f</code> can be a function, a lambda expression, a functor class, or any other callable object. It must return a <code>bool</code> signalling whether the event has passed the selection (<code>true</code>) or not (<code>false</code>). It must perform "read-only" actions on the columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correct results when implicit multi-threading is active.</p>
<p><code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> only evaluates filters when necessary: if multiple filters are chained one after another, they are executed in order and the first one returning <code>false</code> causes the event to be discarded and triggers the processing of the next entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for each entry: after the first access it simply serves a cached result.</p>
<h4><a class="anchor" id="named-filters-and-cutflow-reports"></a>Named filters and cutflow reports</h4>
<p>An optional string parameter <code>name</code> can be passed to the <code>Filter</code> method to create a <b>named filter</b>. Named filters work as usual, but also keep track of how many entries they accept and reject.</p>
<p>Statistics are retrieved through a call to the <code>Report</code> method:</p>
<ul>
<li>when <code>Report</code> is called on the main <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> object, it returns a RResultPtr&lt;RCutFlowReport&gt; relative to all named filters declared up to that point</li>
<li>when called on a specific node (e.g. the result of a <code>Define</code> or <code>Filter</code>), it returns a RResultPtr&lt;RCutFlowReport&gt; relative all named filters in the section of the chain between the main <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> and that node (included).</li>
</ul>
<p>Stats are stored in the same order as named filters have been added to the graph, and <em>refer to the latest event-loop</em> that has been run using the relevant <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code>.</p>
<h3><a class="anchor" id="ranges"></a>Ranges</h3>
<p>When <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> is not being used in a multi-thread environment (i.e. no call to <code>EnableImplicitMT</code> was made), <code>Range</code> transformations are available. These act very much like filters but instead of basing their decision on a filter expression, they rely on <code>begin</code>,<code>end</code> and <code>stride</code> parameters.</p>
<ul>
<li><code>begin</code>: initial entry number considered for this range.</li>
<li><code>end</code>: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.</li>
<li><code>stride</code>: process one entry of the [begin, end) range every <code>stride</code> entries. Must be strictly greater than 0.</li>
</ul>
<p>The actual number of entries processed downstream of a <code>Range</code> node will be <code>(end - begin)/stride</code> (or less if less entries than that are available).</p>
<p>Note that ranges act "locally", not based on the global entry count: <code>Range(10,50)</code> means "skip the first 10 entries
 that reach this node*, let the next 40 entries pass, then stop processing". If a range node hangs from a filter node, and the range has a <code>begin</code> parameter of 10, that means the range will skip the first 10 entries <em>that pass the preceding filter</em>.</p>
<p>Ranges allow "early quitting": if all branches of execution of a functional graph reached their <code>end</code> value of processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations.</p>
<h3><a class="anchor" id="custom-columns"></a> Custom columns</h3>
<p>Custom columns are created by invoking <code>Define(name, f, columnList)</code>. As usual, <code>f</code> can be any callable object (function, lambda expression, functor class...); it takes the values of the columns listed in <code>columnList</code> (a list of strings) as parameters, in the same order as they are listed in <code>columnList</code>. <code>f</code> must return the value that will be assigned to the temporary column.</p>
<p>A new variable is created called <code>name</code>, accessible as if it was contained in the dataset from subsequent transformations/actions.</p>
<p>Use cases include:</p><ul>
<li>caching the results of complex calculations for easy and efficient multiple access</li>
<li>extraction of quantities of interest from complex objects</li>
<li>branch aliasing, i.e. changing the name of a branch</li>
</ul>
<p>An exception is thrown if the <code>name</code> of the new column/branch is already in use for another branch in the <code><a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a></code>.</p>
<p>It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method <code>Define(name, expression)</code>. For example this invocation</p>
<div class="fragment"><div class="line">tdf.Define(<span class="stringliteral">&quot;pt&quot;</span>, <span class="stringliteral">&quot;sqrt(px*px + py*py)&quot;</span>);</div></div><!-- fragment --><p>will create a new column called "pt" the value of which is calculated starting from the columns px and py. The system builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches from the names of the variables specified by the user.</p>
<h4>Custom columns as function of slot and entry number</h4>
<p>It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can be invoked are:</p><ul>
<li><code>DefineSlot(name, f, columnList)</code>. In this case the callable f has this signature <code><a class="el" href="namespaceROOT_1_1R.html" title="  namespace associated R package for ROOT. ">R</a>(unsigned int, T1, T2, ...)</code>: the first parameter is the slot number which ranges from 0 to <a class="el" href="namespaceROOT.html#a93a60d5e8722b29ac3c6c15b6f947152" title="Returns the size of the pool used for implicit multi-threading. ">ROOT::GetImplicitMTPoolSize()</a> - 1.</li>
<li><code>DefineSlotEntry(name, f, columnList)</code>. In this case the callable f has this signature <code><a class="el" href="namespaceROOT_1_1R.html" title="  namespace associated R package for ROOT. ">R</a>(unsigned int, ULong64_t, T1, T2, ...)</code>: the first parameter is the slot number while the second one the number of the entry being processed.</li>
</ul>
<h2><a class="anchor" id="actions"></a>Actions</h2>
<h3>Instant and lazy actions</h3>
<p>Actions can be <b>instant</b> or <b>lazy</b>. Instant actions are executed as soon as they are called, while lazy actions are executed whenever the object they return is accessed for the first time. As a rule of thumb, actions with a return value are lazy, the others are instant.</p>
<h2><a class="anchor" id="parallel-execution"></a>Parallel execution</h2>
<p>As pointed out before in this document, <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> can transparently perform multi-threaded event loops to speed up the execution of its actions. Users have to call <code><a class="el" href="namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f" title="Enable ROOT&#39;s implicit multi-threading for all objects and methods that provide an internal paralleli...">ROOT::EnableImplicitMT()</a></code> <em>before</em> constructing the <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> object to indicate that it should take advantage of a pool of worker threads. <b>Each worker thread processes a distinct subset of entries</b>, and their partial results are merged before returning the final values to the user. More specifically, the dataset will be divided in batches of entries, and threads will divide among themselves the processing of these batches. There are no guarantees on the order the batches are processed, i.e. no guarantees in the order entries of the dataset are processed. Note that this in turn means that, for multi-thread event loops, there is no guarantee on the order in which <code>Snapshot</code> will <em>write</em> entries: they could be scrambled with respect to the input dataset.</p>
<h3>Thread-safety of user-defined expressions</h3>
<p><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> operations such as <code>Histo1D</code> or <code>Snapshot</code> are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to <code>Filter</code>, <code>Define</code>, <code>Foreach</code>, <code>Reduce</code> or <code>Aggregate</code> will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.</p>
<p>Note that simple <code>Filter</code> and <code>Define</code> transformations will inherently satisfy this requirement: <code>Filter</code>/<code>Define</code> expressions will often be <em>pure</em> in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.</p>
<p>In order to facilitate writing of thread-safe operations, some <a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a> features such as <code>Foreach</code>, <code>Define</code> or <code>OnPartialResult</code> offer thread-aware counterparts (<code>ForeachSlot</code>, <code>DefineSlot</code>, <code>OnPartialResultSlot</code>): their only difference is that they will pass an extra <code>slot</code> argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, <code><a class="el" href="classROOT_1_1RDataFrame.html" title=" ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&#39;s and other data formats. ">RDataFrame</a></code> guarantees that different threads will employ different values of the <code>slot</code> parameter, where <code>slot</code> will be a number between 0 and <code><a class="el" href="namespaceROOT.html#a93a60d5e8722b29ac3c6c15b6f947152" title="Returns the size of the pool used for implicit multi-threading. ">ROOT::GetImplicitMTPoolSize()</a> - 1</code>. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be associated to different threads over the course of a single event loop, but two threads will never receive the same slot at the same time. This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different processing slot*, e.g. a different element of a list. See <a href="#generic-actions">here</a> for an example usage of <code>ForeachSlot</code>.</p>
<p><a class="anchor" id="reference"></a> </p>

<p class="definition">Definition at line <a class="el" href="RDataFrame_8hxx_source.html#l00042">42</a> of file <a class="el" href="RDataFrame_8hxx_source.html">RDataFrame.hxx</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a149222c853bd18aceace5e86a0ac02ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> = RDFDetail::ColumnNames_t</td></tr>
<tr class="separator:a149222c853bd18aceace5e86a0ac02ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0813d17002d46c962513acb96ddc8d57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> treeName, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> filenameglob, const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;defaultBranches={})</td></tr>
<tr class="memdesc:a0813d17002d46c962513acb96ddc8d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the dataframe.  <a href="#a0813d17002d46c962513acb96ddc8d57">More...</a><br /></td></tr>
<tr class="separator:a0813d17002d46c962513acb96ddc8d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcebb79c00694365296d054626e87742"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDataFrame.html#adcebb79c00694365296d054626e87742">RDataFrame</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> treename, const std::vector&lt; std::string &gt; &amp;filenames, const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;defaultBranches={})</td></tr>
<tr class="memdesc:adcebb79c00694365296d054626e87742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the dataframe.  <a href="#adcebb79c00694365296d054626e87742">More...</a><br /></td></tr>
<tr class="separator:adcebb79c00694365296d054626e87742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d1d227daca2ab9c25ddfe1520d4ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDataFrame.html#ac23d1d227daca2ab9c25ddfe1520d4ed">RDataFrame</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> treeName, ::<a class="el" href="classTDirectory.html">TDirectory</a> *dirPtr, const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;defaultBranches={})</td></tr>
<tr class="separator:ac23d1d227daca2ab9c25ddfe1520d4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a45ce7601ffbca837f6773cd55a3e72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDataFrame.html#a6a45ce7601ffbca837f6773cd55a3e72">RDataFrame</a> (<a class="el" href="classTTree.html">TTree</a> &amp;tree, const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;defaultBranches={})</td></tr>
<tr class="memdesc:a6a45ce7601ffbca837f6773cd55a3e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the dataframe.  <a href="#a6a45ce7601ffbca837f6773cd55a3e72">More...</a><br /></td></tr>
<tr class="separator:a6a45ce7601ffbca837f6773cd55a3e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90daba6a8ab4a0590e12d5eda3b1aec7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDataFrame.html#a90daba6a8ab4a0590e12d5eda3b1aec7">RDataFrame</a> (<a class="el" href="RtypesCore_8h.html#aec5c78ee1411360ee0f2dc942f475c63">ULong64_t</a> numEntries)</td></tr>
<tr class="memdesc:a90daba6a8ab4a0590e12d5eda3b1aec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a dataframe that generates numEntries entries.  <a href="#a90daba6a8ab4a0590e12d5eda3b1aec7">More...</a><br /></td></tr>
<tr class="separator:a90daba6a8ab4a0590e12d5eda3b1aec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1644efe41e76c2cdb9a6bc9ade8b9d0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDataFrame.html#a1644efe41e76c2cdb9a6bc9ade8b9d0c">RDataFrame</a> (std::unique_ptr&lt; <a class="el" href="classROOT_1_1RDF_1_1RDataSource.html">ROOT::RDF::RDataSource</a> &gt;, const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;defaultBranches={})</td></tr>
<tr class="memdesc:a1644efe41e76c2cdb9a6bc9ade8b9d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build dataframe associated to datasource.  <a href="#a1644efe41e76c2cdb9a6bc9ade8b9d0c">More...</a><br /></td></tr>
<tr class="separator:a1644efe41e76c2cdb9a6bc9ade8b9d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classROOT_1_1RDF_1_1RInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classROOT_1_1RDF_1_1RInterface.html">ROOT::RDF::RInterface&lt; RDFDetail::RLoopManager &gt;</a></td></tr>
<tr class="memitem:a031ea99681fd4042976f939b6860194e inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a031ea99681fd4042976f939b6860194e">RInterface</a> (const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a> &amp;)=default</td></tr>
<tr class="memdesc:a031ea99681fd4042976f939b6860194e inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-ctor for RInterface.  <a href="classROOT_1_1RDF_1_1RInterface.html#a031ea99681fd4042976f939b6860194e">More...</a><br /></td></tr>
<tr class="separator:a031ea99681fd4042976f939b6860194e inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90f4c7c6b3937367179386a0c9df3dd inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ad90f4c7c6b3937367179386a0c9df3dd">RInterface</a> (<a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:ad90f4c7c6b3937367179386a0c9df3dd inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-ctor for RInterface.  <a href="classROOT_1_1RDF_1_1RInterface.html#ad90f4c7c6b3937367179386a0c9df3dd">More...</a><br /></td></tr>
<tr class="separator:ad90f4c7c6b3937367179386a0c9df3dd inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2934e42aedc189a8f594ce164a4fb89a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a2934e42aedc189a8f594ce164a4fb89a">RInterface</a> (const std::shared_ptr&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a> &gt; &amp;proxied)</td></tr>
<tr class="memdesc:a2934e42aedc189a8f594ce164a4fb89a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only enabled when building a RInterface&lt;RLoopManager&gt;  <a href="classROOT_1_1RDF_1_1RInterface.html#a2934e42aedc189a8f594ce164a4fb89a">More...</a><br /></td></tr>
<tr class="separator:a2934e42aedc189a8f594ce164a4fb89a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae540b00addc441f9b504cbae0ef0a24d inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae540b00addc441f9b504cbae0ef0a24d">Aggregate</a> (AccFun aggregator, MergeFun merger, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName, const U &amp;aggIdentity)</td></tr>
<tr class="memdesc:ae540b00addc441f9b504cbae0ef0a24d inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a user-defined accumulation operation on the processed column values in each processing slot.  <a href="classROOT_1_1RDF_1_1RInterface.html#ae540b00addc441f9b504cbae0ef0a24d">More...</a><br /></td></tr>
<tr class="separator:ae540b00addc441f9b504cbae0ef0a24d inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d82cb96013d9fe75cf4cc4a57f6d692 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a7d82cb96013d9fe75cf4cc4a57f6d692">Aggregate</a> (AccFun aggregator, MergeFun merger, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName=&quot;&quot;)</td></tr>
<tr class="memdesc:a7d82cb96013d9fe75cf4cc4a57f6d692 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a user-defined accumulation operation on the processed column values in each processing slot.  <a href="classROOT_1_1RDF_1_1RInterface.html#a7d82cb96013d9fe75cf4cc4a57f6d692">More...</a><br /></td></tr>
<tr class="separator:a7d82cb96013d9fe75cf4cc4a57f6d692 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ca327e4a192dcc05a4aac240e1a725 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a>, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a31ca327e4a192dcc05a4aac240e1a725">Alias</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> alias, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName)</td></tr>
<tr class="memdesc:a31ca327e4a192dcc05a4aac240e1a725 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow to refer to a column with a different name.  <a href="classROOT_1_1RDF_1_1RInterface.html#a31ca327e4a192dcc05a4aac240e1a725">More...</a><br /></td></tr>
<tr class="separator:a31ca327e4a192dcc05a4aac240e1a725 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed8313806398d106bfc2390301c0408 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; typename Helper::Result_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a9ed8313806398d106bfc2390301c0408">Book</a> (Helper &amp;&amp;helper, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columns={})</td></tr>
<tr class="memdesc:a9ed8313806398d106bfc2390301c0408 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Book execution of a custom action using a user-defined helper object.  <a href="classROOT_1_1RDF_1_1RInterface.html#a9ed8313806398d106bfc2390301c0408">More...</a><br /></td></tr>
<tr class="separator:a9ed8313806398d106bfc2390301c0408 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa0a7bb8eb21315d8daa08c3e25f6c9 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9">Cache</a> (const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columnList)</td></tr>
<tr class="memdesc:aaaa0a7bb8eb21315d8daa08c3e25f6c9 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save selected columns in memory.  <a href="classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9">More...</a><br /></td></tr>
<tr class="separator:aaaa0a7bb8eb21315d8daa08c3e25f6c9 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad065ec3f3353fa2f3b66b8849a0c963f inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ad065ec3f3353fa2f3b66b8849a0c963f">Cache</a> (const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columnList)</td></tr>
<tr class="memdesc:ad065ec3f3353fa2f3b66b8849a0c963f inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save selected columns in memory.  <a href="classROOT_1_1RDF_1_1RInterface.html#ad065ec3f3353fa2f3b66b8849a0c963f">More...</a><br /></td></tr>
<tr class="separator:ad065ec3f3353fa2f3b66b8849a0c963f inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b0917b7fc68a5f6e0bce3918f04d4c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a01b0917b7fc68a5f6e0bce3918f04d4c">Cache</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnNameRegexp=&quot;&quot;)</td></tr>
<tr class="memdesc:a01b0917b7fc68a5f6e0bce3918f04d4c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save selected columns in memory.  <a href="classROOT_1_1RDF_1_1RInterface.html#a01b0917b7fc68a5f6e0bce3918f04d4c">More...</a><br /></td></tr>
<tr class="separator:a01b0917b7fc68a5f6e0bce3918f04d4c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75657d20d27cc4fb027b82deead2716e inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a75657d20d27cc4fb027b82deead2716e">Cache</a> (std::initializer_list&lt; std::string &gt; columnList)</td></tr>
<tr class="memdesc:a75657d20d27cc4fb027b82deead2716e inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save selected columns in memory.  <a href="classROOT_1_1RDF_1_1RInterface.html#a75657d20d27cc4fb027b82deead2716e">More...</a><br /></td></tr>
<tr class="separator:a75657d20d27cc4fb027b82deead2716e inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f9e00c2ece7f53fae50b740adc1456 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="RtypesCore_8h.html#aec5c78ee1411360ee0f2dc942f475c63">ULong64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a37f9e00c2ece7f53fae50b740adc1456">Count</a> ()</td></tr>
<tr class="memdesc:a37f9e00c2ece7f53fae50b740adc1456 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of entries processed (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a37f9e00c2ece7f53fae50b740adc1456">More...</a><br /></td></tr>
<tr class="separator:a37f9e00c2ece7f53fae50b740adc1456 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d48eb23b4378e99ebccb35e94ad025a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a>, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a7d48eb23b4378e99ebccb35e94ad025a">Define</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> name, <a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> expression, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columns={})</td></tr>
<tr class="memdesc:a7d48eb23b4378e99ebccb35e94ad025a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom column.  <a href="classROOT_1_1RDF_1_1RInterface.html#a7d48eb23b4378e99ebccb35e94ad025a">More...</a><br /></td></tr>
<tr class="separator:a7d48eb23b4378e99ebccb35e94ad025a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd0d480704c0c39c599c28666c713d2 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a>, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#aefd0d480704c0c39c599c28666c713d2">Define</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> expression)</td></tr>
<tr class="memdesc:aefd0d480704c0c39c599c28666c713d2 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom column.  <a href="classROOT_1_1RDF_1_1RInterface.html#aefd0d480704c0c39c599c28666c713d2">More...</a><br /></td></tr>
<tr class="separator:aefd0d480704c0c39c599c28666c713d2 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaacf727b8a41d27c6bb4513348ac892 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a>, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#acaacf727b8a41d27c6bb4513348ac892">DefineSlot</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> name, <a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> expression, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columns={})</td></tr>
<tr class="memdesc:acaacf727b8a41d27c6bb4513348ac892 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom column with a value dependent on the processing slot.  <a href="classROOT_1_1RDF_1_1RInterface.html#acaacf727b8a41d27c6bb4513348ac892">More...</a><br /></td></tr>
<tr class="separator:acaacf727b8a41d27c6bb4513348ac892 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f17074d5771916e3df18f8458186de7 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a>, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a4f17074d5771916e3df18f8458186de7">DefineSlotEntry</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> name, <a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> expression, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columns={})</td></tr>
<tr class="memdesc:a4f17074d5771916e3df18f8458186de7 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom column with a value dependent on the processing slot and the current entry.  <a href="classROOT_1_1RDF_1_1RInterface.html#a4f17074d5771916e3df18f8458186de7">More...</a><br /></td></tr>
<tr class="separator:a4f17074d5771916e3df18f8458186de7 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652f9ab3e8d2da9335b347b540a9a941 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RDisplay.html">RDisplay</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a652f9ab3e8d2da9335b347b540a9a941">Display</a> (const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columnList, const int &amp;nRows=5)</td></tr>
<tr class="memdesc:a652f9ab3e8d2da9335b347b540a9a941 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a representation of the columns in the dataset.  <a href="classROOT_1_1RDF_1_1RInterface.html#a652f9ab3e8d2da9335b347b540a9a941">More...</a><br /></td></tr>
<tr class="separator:a652f9ab3e8d2da9335b347b540a9a941 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa871144a9f78b884f91447bc3878ca2c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RDisplay.html">RDisplay</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#aa871144a9f78b884f91447bc3878ca2c">Display</a> (const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columnList, const int &amp;nRows=5)</td></tr>
<tr class="memdesc:aa871144a9f78b884f91447bc3878ca2c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a representation of the columns in the dataset.  <a href="classROOT_1_1RDF_1_1RInterface.html#aa871144a9f78b884f91447bc3878ca2c">More...</a><br /></td></tr>
<tr class="separator:aa871144a9f78b884f91447bc3878ca2c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee68f4411f16f00a1d46eccb6d296f01 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RDisplay.html">RDisplay</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#aee68f4411f16f00a1d46eccb6d296f01">Display</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnNameRegexp=&quot;&quot;, const int &amp;nRows=5)</td></tr>
<tr class="memdesc:aee68f4411f16f00a1d46eccb6d296f01 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a representation of the columns in the dataset.  <a href="classROOT_1_1RDF_1_1RInterface.html#aee68f4411f16f00a1d46eccb6d296f01">More...</a><br /></td></tr>
<tr class="separator:aee68f4411f16f00a1d46eccb6d296f01 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafef6d563a9fb487845d79b37a6e3071 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RDisplay.html">RDisplay</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#aafef6d563a9fb487845d79b37a6e3071">Display</a> (std::initializer_list&lt; std::string &gt; columnList, const int &amp;nRows=5)</td></tr>
<tr class="memdesc:aafef6d563a9fb487845d79b37a6e3071 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a representation of the columns in the dataset.  <a href="classROOT_1_1RDF_1_1RInterface.html#aafef6d563a9fb487845d79b37a6e3071">More...</a><br /></td></tr>
<tr class="separator:aafef6d563a9fb487845d79b37a6e3071 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cac4d08297c23d16de81ff25545440a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a0cac4d08297c23d16de81ff25545440a">Fill</a> (T &amp;&amp;model, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columnList)</td></tr>
<tr class="memdesc:a0cac4d08297c23d16de81ff25545440a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an object of type T on which <code>T::Fill</code> will be called once per event (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a0cac4d08297c23d16de81ff25545440a">More...</a><br /></td></tr>
<tr class="separator:a0cac4d08297c23d16de81ff25545440a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0928d08b21aa01ef4fed67880894ebc inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ac0928d08b21aa01ef4fed67880894ebc">Fill</a> (T &amp;&amp;model, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;bl)</td></tr>
<tr class="memdesc:ac0928d08b21aa01ef4fed67880894ebc inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an object of type T on which <code>T::Fill</code> will be called once per event (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#ac0928d08b21aa01ef4fed67880894ebc">More...</a><br /></td></tr>
<tr class="separator:ac0928d08b21aa01ef4fed67880894ebc inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70284a3bedc72b19610aaa91b5007ebd inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RFilter.html">RDFDetail::RFilter</a>&lt; <a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>, <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a> &gt;, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a70284a3bedc72b19610aaa91b5007ebd">Filter</a> (<a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> <a class="el" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columns={}, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> name=&quot;&quot;)</td></tr>
<tr class="memdesc:a70284a3bedc72b19610aaa91b5007ebd inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a filter to the call graph.  <a href="classROOT_1_1RDF_1_1RInterface.html#a70284a3bedc72b19610aaa91b5007ebd">More...</a><br /></td></tr>
<tr class="separator:a70284a3bedc72b19610aaa91b5007ebd inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76102fd25c9769ea818f1a56c10fc760 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RFilter.html">RDFDetail::RFilter</a>&lt; <a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>, <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a> &gt;, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a76102fd25c9769ea818f1a56c10fc760">Filter</a> (<a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> <a class="el" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> name)</td></tr>
<tr class="memdesc:a76102fd25c9769ea818f1a56c10fc760 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a filter to the call graph.  <a href="classROOT_1_1RDF_1_1RInterface.html#a76102fd25c9769ea818f1a56c10fc760">More...</a><br /></td></tr>
<tr class="separator:a76102fd25c9769ea818f1a56c10fc760 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d4473744625d5fc707ee5a4e0aa037 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RFilter.html">RDFDetail::RFilter</a>&lt; <a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>, <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a> &gt;, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab1d4473744625d5fc707ee5a4e0aa037">Filter</a> (<a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> <a class="el" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>, const std::initializer_list&lt; std::string &gt; &amp;columns)</td></tr>
<tr class="memdesc:ab1d4473744625d5fc707ee5a4e0aa037 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a filter to the call graph.  <a href="classROOT_1_1RDF_1_1RInterface.html#ab1d4473744625d5fc707ee5a4e0aa037">More...</a><br /></td></tr>
<tr class="separator:ab1d4473744625d5fc707ee5a4e0aa037 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af415d0a369aaa449492563f47a13fd37 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RJittedFilter.html">RDFDetail::RJittedFilter</a>, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#af415d0a369aaa449492563f47a13fd37">Filter</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> expression, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> name=&quot;&quot;)</td></tr>
<tr class="memdesc:af415d0a369aaa449492563f47a13fd37 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a filter to the call graph.  <a href="classROOT_1_1RDF_1_1RInterface.html#af415d0a369aaa449492563f47a13fd37">More...</a><br /></td></tr>
<tr class="separator:af415d0a369aaa449492563f47a13fd37 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2822a7ccb8a9afdf3e5b2ea321886ca inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ad2822a7ccb8a9afdf3e5b2ea321886ca">Foreach</a> (<a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> <a class="el" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columns={})</td></tr>
<tr class="memdesc:ad2822a7ccb8a9afdf3e5b2ea321886ca inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a user-defined function on each entry (<em>instant action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#ad2822a7ccb8a9afdf3e5b2ea321886ca">More...</a><br /></td></tr>
<tr class="separator:ad2822a7ccb8a9afdf3e5b2ea321886ca inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3650ca30aae1ccd0d92bf3d680314129 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a3650ca30aae1ccd0d92bf3d680314129">ForeachSlot</a> (<a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> <a class="el" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columns={})</td></tr>
<tr class="memdesc:a3650ca30aae1ccd0d92bf3d680314129 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a user-defined function requiring a processing slot index on each entry (<em>instant action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a3650ca30aae1ccd0d92bf3d680314129">More...</a><br /></td></tr>
<tr class="separator:a3650ca30aae1ccd0d92bf3d680314129 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951fe60b74d3a9fda37df59fd1dac186 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a951fe60b74d3a9fda37df59fd1dac186">GetColumnNames</a> ()</td></tr>
<tr class="memdesc:a951fe60b74d3a9fda37df59fd1dac186 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of the available columns.  <a href="classROOT_1_1RDF_1_1RInterface.html#a951fe60b74d3a9fda37df59fd1dac186">More...</a><br /></td></tr>
<tr class="separator:a951fe60b74d3a9fda37df59fd1dac186 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ccd813d9fed014ae6a080411c5b5a8 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ad3ccd813d9fed014ae6a080411c5b5a8">GetColumnType</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> column)</td></tr>
<tr class="memdesc:ad3ccd813d9fed014ae6a080411c5b5a8 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of a given column as a string.  <a href="classROOT_1_1RDF_1_1RInterface.html#ad3ccd813d9fed014ae6a080411c5b5a8">More...</a><br /></td></tr>
<tr class="separator:ad3ccd813d9fed014ae6a080411c5b5a8 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c3fab8155aae8f614735df68430c58 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ad5c3fab8155aae8f614735df68430c58">GetDefinedColumnNames</a> ()</td></tr>
<tr class="memdesc:ad5c3fab8155aae8f614735df68430c58 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of the defined columns.  <a href="classROOT_1_1RDF_1_1RInterface.html#ad5c3fab8155aae8f614735df68430c58">More...</a><br /></td></tr>
<tr class="separator:ad5c3fab8155aae8f614735df68430c58 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25026681111897058299161a70ad9bb2 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a25026681111897058299161a70ad9bb2">GetFilterNames</a> ()</td></tr>
<tr class="memdesc:a25026681111897058299161a70ad9bb2 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of the filters created.  <a href="classROOT_1_1RDF_1_1RInterface.html#a25026681111897058299161a70ad9bb2">More...</a><br /></td></tr>
<tr class="separator:a25026681111897058299161a70ad9bb2 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289f087fb7127585193be47290915c06 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a289f087fb7127585193be47290915c06">GetNSlots</a> () const</td></tr>
<tr class="memdesc:a289f087fb7127585193be47290915c06 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of data processing slots.  <a href="classROOT_1_1RDF_1_1RInterface.html#a289f087fb7127585193be47290915c06">More...</a><br /></td></tr>
<tr class="separator:a289f087fb7127585193be47290915c06 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804b466ebdbddef5c7e3400cc6b89301 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTGraph.html">TGraph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a804b466ebdbddef5c7e3400cc6b89301">Graph</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v1Name=&quot;&quot;, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v2Name=&quot;&quot;)</td></tr>
<tr class="memdesc:a804b466ebdbddef5c7e3400cc6b89301 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a graph (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a804b466ebdbddef5c7e3400cc6b89301">More...</a><br /></td></tr>
<tr class="separator:a804b466ebdbddef5c7e3400cc6b89301 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d6e219cb2a2078d6a36345caa4b72c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae1d6e219cb2a2078d6a36345caa4b72c">HasColumn</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName)</td></tr>
<tr class="memdesc:ae1d6e219cb2a2078d6a36345caa4b72c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a column is present in the dataset.  <a href="classROOT_1_1RDF_1_1RInterface.html#ae1d6e219cb2a2078d6a36345caa4b72c">More...</a><br /></td></tr>
<tr class="separator:ae1d6e219cb2a2078d6a36345caa4b72c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247ca3aeb7ce5b95015b7fae72983055 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH1D.html">TH1D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a247ca3aeb7ce5b95015b7fae72983055">Histo1D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TH1DModel.html">TH1DModel</a> &amp;model={&quot;&quot;, &quot;&quot;, 128u, 0., 0.}, std::string_view vName=&quot;&quot;)</td></tr>
<tr class="memdesc:a247ca3aeb7ce5b95015b7fae72983055 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a one-dimensional histogram with the values of a column (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a247ca3aeb7ce5b95015b7fae72983055">More...</a><br /></td></tr>
<tr class="separator:a247ca3aeb7ce5b95015b7fae72983055 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310ec330a8acba62675f540eb9721778 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH1D.html">TH1D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a310ec330a8acba62675f540eb9721778">Histo1D</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> vName)</td></tr>
<tr class="memdesc:a310ec330a8acba62675f540eb9721778 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a one-dimensional histogram with the values of a column (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a310ec330a8acba62675f540eb9721778">More...</a><br /></td></tr>
<tr class="separator:a310ec330a8acba62675f540eb9721778 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bcf54c19722331078ae00bc05c758b inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH1D.html">TH1D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a67bcf54c19722331078ae00bc05c758b">Histo1D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TH1DModel.html">TH1DModel</a> &amp;model, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> vName, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> wName)</td></tr>
<tr class="memdesc:a67bcf54c19722331078ae00bc05c758b inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a one-dimensional histogram with the weighted values of a column (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a67bcf54c19722331078ae00bc05c758b">More...</a><br /></td></tr>
<tr class="separator:a67bcf54c19722331078ae00bc05c758b inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002f3e55d90785f7ea7a9973bacc5b16 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH1D.html">TH1D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a002f3e55d90785f7ea7a9973bacc5b16">Histo1D</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> vName, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> wName)</td></tr>
<tr class="memdesc:a002f3e55d90785f7ea7a9973bacc5b16 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a one-dimensional histogram with the weighted values of a column (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a002f3e55d90785f7ea7a9973bacc5b16">More...</a><br /></td></tr>
<tr class="separator:a002f3e55d90785f7ea7a9973bacc5b16 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d5b68ad31a83802914651aaf25c9a0 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH1D.html">TH1D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ac9d5b68ad31a83802914651aaf25c9a0">Histo1D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TH1DModel.html">TH1DModel</a> &amp;model={&quot;&quot;, &quot;&quot;, 128u, 0., 0.})</td></tr>
<tr class="memdesc:ac9d5b68ad31a83802914651aaf25c9a0 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a one-dimensional histogram with the weighted values of a column (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#ac9d5b68ad31a83802914651aaf25c9a0">More...</a><br /></td></tr>
<tr class="separator:ac9d5b68ad31a83802914651aaf25c9a0 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9d25cf058ce859b97d5dab42837d30 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH2D.html">TH2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a1b9d25cf058ce859b97d5dab42837d30">Histo2D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TH2DModel.html">TH2DModel</a> &amp;model, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v1Name=&quot;&quot;, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v2Name=&quot;&quot;)</td></tr>
<tr class="memdesc:a1b9d25cf058ce859b97d5dab42837d30 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a two-dimensional histogram (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a1b9d25cf058ce859b97d5dab42837d30">More...</a><br /></td></tr>
<tr class="separator:a1b9d25cf058ce859b97d5dab42837d30 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57b916098a13d09a3fb2a6c8ba73c19 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH2D.html">TH2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#af57b916098a13d09a3fb2a6c8ba73c19">Histo2D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TH2DModel.html">TH2DModel</a> &amp;model, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v1Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v2Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> wName)</td></tr>
<tr class="memdesc:af57b916098a13d09a3fb2a6c8ba73c19 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a weighted two-dimensional histogram (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#af57b916098a13d09a3fb2a6c8ba73c19">More...</a><br /></td></tr>
<tr class="separator:af57b916098a13d09a3fb2a6c8ba73c19 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfab96814fdbb5ebdd56efc92c037f8a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH2D.html">TH2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#acfab96814fdbb5ebdd56efc92c037f8a">Histo2D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TH2DModel.html">TH2DModel</a> &amp;model)</td></tr>
<tr class="separator:acfab96814fdbb5ebdd56efc92c037f8a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eaf45ea89fac0359019a3cfa23ad006 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH3D.html">TH3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a4eaf45ea89fac0359019a3cfa23ad006">Histo3D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TH3DModel.html">TH3DModel</a> &amp;model, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v1Name=&quot;&quot;, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v2Name=&quot;&quot;, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v3Name=&quot;&quot;)</td></tr>
<tr class="memdesc:a4eaf45ea89fac0359019a3cfa23ad006 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a three-dimensional histogram (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a4eaf45ea89fac0359019a3cfa23ad006">More...</a><br /></td></tr>
<tr class="separator:a4eaf45ea89fac0359019a3cfa23ad006 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932960e1e8cd7d963f26c2a19b94f807 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH3D.html">TH3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a932960e1e8cd7d963f26c2a19b94f807">Histo3D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TH3DModel.html">TH3DModel</a> &amp;model, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v1Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v2Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v3Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> wName)</td></tr>
<tr class="memdesc:a932960e1e8cd7d963f26c2a19b94f807 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a three-dimensional histogram (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a932960e1e8cd7d963f26c2a19b94f807">More...</a><br /></td></tr>
<tr class="separator:a932960e1e8cd7d963f26c2a19b94f807 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3efd5ea870be96f4fa3c1baa4750532 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTH3D.html">TH3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae3efd5ea870be96f4fa3c1baa4750532">Histo3D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TH3DModel.html">TH3DModel</a> &amp;model)</td></tr>
<tr class="separator:ae3efd5ea870be96f4fa3c1baa4750532 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057179b1e77599466a0b02200d5cd8c3 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; RDFDetail::MaxReturnType_t&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a057179b1e77599466a0b02200d5cd8c3">Max</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName=&quot;&quot;)</td></tr>
<tr class="memdesc:a057179b1e77599466a0b02200d5cd8c3 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum of processed column values (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a057179b1e77599466a0b02200d5cd8c3">More...</a><br /></td></tr>
<tr class="separator:a057179b1e77599466a0b02200d5cd8c3 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6b020284f2f4fe9d3b09246b5f376a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ade6b020284f2f4fe9d3b09246b5f376a">Mean</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName=&quot;&quot;)</td></tr>
<tr class="memdesc:ade6b020284f2f4fe9d3b09246b5f376a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mean of processed column values (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#ade6b020284f2f4fe9d3b09246b5f376a">More...</a><br /></td></tr>
<tr class="separator:ade6b020284f2f4fe9d3b09246b5f376a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7005702189e601972b6d19ecebcdc80c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; RDFDetail::MinReturnType_t&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a7005702189e601972b6d19ecebcdc80c">Min</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName=&quot;&quot;)</td></tr>
<tr class="memdesc:a7005702189e601972b6d19ecebcdc80c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum of processed column values (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a7005702189e601972b6d19ecebcdc80c">More...</a><br /></td></tr>
<tr class="separator:a7005702189e601972b6d19ecebcdc80c inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6909f04c05723de79f97a14b092318b1 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a6909f04c05723de79f97a14b092318b1">operator RNode</a> () const</td></tr>
<tr class="memdesc:a6909f04c05723de79f97a14b092318b1 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any RDataFrame node to a common type <a class="el" href="namespaceROOT_1_1RDF.html#a2ddba8d440832e128b144b06b264263f">ROOT::RDF::RNode</a>.  <a href="classROOT_1_1RDF_1_1RInterface.html#a6909f04c05723de79f97a14b092318b1">More...</a><br /></td></tr>
<tr class="separator:a6909f04c05723de79f97a14b092318b1 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451f03972bffeb6a879c8d63ac3f9da5 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a451f03972bffeb6a879c8d63ac3f9da5">operator=</a> (const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a> &amp;)=default</td></tr>
<tr class="memdesc:a451f03972bffeb6a879c8d63ac3f9da5 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assignment operator for RInterface.  <a href="classROOT_1_1RDF_1_1RInterface.html#a451f03972bffeb6a879c8d63ac3f9da5">More...</a><br /></td></tr>
<tr class="separator:a451f03972bffeb6a879c8d63ac3f9da5 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef7dc16b0e9f7bc9cfbe2d9e5de0cef inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTProfile.html">TProfile</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a8ef7dc16b0e9f7bc9cfbe2d9e5de0cef">Profile1D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TProfile1DModel.html">TProfile1DModel</a> &amp;model, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v1Name=&quot;&quot;, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v2Name=&quot;&quot;)</td></tr>
<tr class="memdesc:a8ef7dc16b0e9f7bc9cfbe2d9e5de0cef inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a one-dimensional profile (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a8ef7dc16b0e9f7bc9cfbe2d9e5de0cef">More...</a><br /></td></tr>
<tr class="separator:a8ef7dc16b0e9f7bc9cfbe2d9e5de0cef inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7b7e3b72fbea9ccf5893bd90767a02 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTProfile.html">TProfile</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a4d7b7e3b72fbea9ccf5893bd90767a02">Profile1D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TProfile1DModel.html">TProfile1DModel</a> &amp;model, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v1Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v2Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> wName)</td></tr>
<tr class="memdesc:a4d7b7e3b72fbea9ccf5893bd90767a02 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a one-dimensional profile (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a4d7b7e3b72fbea9ccf5893bd90767a02">More...</a><br /></td></tr>
<tr class="separator:a4d7b7e3b72fbea9ccf5893bd90767a02 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c48f563fe7a230d70983f3ba44acafd inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTProfile.html">TProfile</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a2c48f563fe7a230d70983f3ba44acafd">Profile1D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TProfile1DModel.html">TProfile1DModel</a> &amp;model)</td></tr>
<tr class="separator:a2c48f563fe7a230d70983f3ba44acafd inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c180a8f3bf92379e563ee4fdb26f4f inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTProfile2D.html">TProfile2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ac5c180a8f3bf92379e563ee4fdb26f4f">Profile2D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TProfile2DModel.html">TProfile2DModel</a> &amp;model, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v1Name=&quot;&quot;, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v2Name=&quot;&quot;, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v3Name=&quot;&quot;)</td></tr>
<tr class="memdesc:ac5c180a8f3bf92379e563ee4fdb26f4f inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a two-dimensional profile (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#ac5c180a8f3bf92379e563ee4fdb26f4f">More...</a><br /></td></tr>
<tr class="separator:ac5c180a8f3bf92379e563ee4fdb26f4f inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc354e0f3179e592a6b4e740ee202711 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTProfile2D.html">TProfile2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#adc354e0f3179e592a6b4e740ee202711">Profile2D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TProfile2DModel.html">TProfile2DModel</a> &amp;model, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v1Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v2Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> v3Name, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> wName)</td></tr>
<tr class="memdesc:adc354e0f3179e592a6b4e740ee202711 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill and return a two-dimensional profile (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#adc354e0f3179e592a6b4e740ee202711">More...</a><br /></td></tr>
<tr class="separator:adc354e0f3179e592a6b4e740ee202711 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259f720c814ae8d63b85da606c6f108a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt;::<a class="el" href="classTProfile2D.html">TProfile2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a259f720c814ae8d63b85da606c6f108a">Profile2D</a> (const <a class="el" href="structROOT_1_1RDF_1_1TProfile2DModel.html">TProfile2DModel</a> &amp;model)</td></tr>
<tr class="separator:a259f720c814ae8d63b85da606c6f108a inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b36b7868831de2375e061bb06cfc225 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RRange.html">RDFDetail::RRange</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a> &gt;, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a1b36b7868831de2375e061bb06cfc225">Range</a> (unsigned int begin, unsigned int end, unsigned int stride=1)</td></tr>
<tr class="memdesc:a1b36b7868831de2375e061bb06cfc225 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a node that filters entries based on range: [begin, end)  <a href="classROOT_1_1RDF_1_1RInterface.html#a1b36b7868831de2375e061bb06cfc225">More...</a><br /></td></tr>
<tr class="separator:a1b36b7868831de2375e061bb06cfc225 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e9f5665ba9971f715a322b775464a7 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RRange.html">RDFDetail::RRange</a>&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a> &gt;, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a856e120e2bf6759838d92593ff00b0eb">DS_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a25e9f5665ba9971f715a322b775464a7">Range</a> (unsigned int end)</td></tr>
<tr class="memdesc:a25e9f5665ba9971f715a322b775464a7 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a node that filters entries based on range.  <a href="classROOT_1_1RDF_1_1RInterface.html#a25e9f5665ba9971f715a322b775464a7">More...</a><br /></td></tr>
<tr class="separator:a25e9f5665ba9971f715a322b775464a7 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118e723ae29834df8f2a992ded347354 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a118e723ae29834df8f2a992ded347354">Reduce</a> (<a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> <a class="el" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName=&quot;&quot;)</td></tr>
<tr class="memdesc:a118e723ae29834df8f2a992ded347354 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a user-defined reduce operation on the values of a column.  <a href="classROOT_1_1RDF_1_1RInterface.html#a118e723ae29834df8f2a992ded347354">More...</a><br /></td></tr>
<tr class="separator:a118e723ae29834df8f2a992ded347354 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616702fcf428f96a2c34e0baccf5cb1f inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a616702fcf428f96a2c34e0baccf5cb1f">Reduce</a> (<a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> <a class="el" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName, const T &amp;redIdentity)</td></tr>
<tr class="memdesc:a616702fcf428f96a2c34e0baccf5cb1f inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a user-defined reduce operation on the values of a column.  <a href="classROOT_1_1RDF_1_1RInterface.html#a616702fcf428f96a2c34e0baccf5cb1f">More...</a><br /></td></tr>
<tr class="separator:a616702fcf428f96a2c34e0baccf5cb1f inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f322531dcb25beb8f53a602e5d6332 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RCutFlowReport.html">RCutFlowReport</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a94f322531dcb25beb8f53a602e5d6332">Report</a> ()</td></tr>
<tr class="memdesc:a94f322531dcb25beb8f53a602e5d6332 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather filtering statistics.  <a href="classROOT_1_1RDF_1_1RInterface.html#a94f322531dcb25beb8f53a602e5d6332">More...</a><br /></td></tr>
<tr class="separator:a94f322531dcb25beb8f53a602e5d6332 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233b7723e498967f4340705d2c4db7f8 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8">Snapshot</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> treename, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> filename, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columnList, const <a class="el" href="structROOT_1_1RDF_1_1RSnapshotOptions.html">RSnapshotOptions</a> &amp;options=<a class="el" href="structROOT_1_1RDF_1_1RSnapshotOptions.html">RSnapshotOptions</a>())</td></tr>
<tr class="memdesc:a233b7723e498967f4340705d2c4db7f8 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save selected columns to disk, in a new <a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a> <code>treename</code> in file <code>filename</code>.  <a href="classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8">More...</a><br /></td></tr>
<tr class="separator:a233b7723e498967f4340705d2c4db7f8 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0f0ddd8987659b650feec126cabd68 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a9e0f0ddd8987659b650feec126cabd68">Snapshot</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> treename, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> filename, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columnList, const <a class="el" href="structROOT_1_1RDF_1_1RSnapshotOptions.html">RSnapshotOptions</a> &amp;options=<a class="el" href="structROOT_1_1RDF_1_1RSnapshotOptions.html">RSnapshotOptions</a>())</td></tr>
<tr class="memdesc:a9e0f0ddd8987659b650feec126cabd68 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save selected columns to disk, in a new <a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a> <code>treename</code> in file <code>filename</code>.  <a href="classROOT_1_1RDF_1_1RInterface.html#a9e0f0ddd8987659b650feec126cabd68">More...</a><br /></td></tr>
<tr class="separator:a9e0f0ddd8987659b650feec126cabd68 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a3bd7cb047e771eb8458fa150df238 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a38a3bd7cb047e771eb8458fa150df238">Snapshot</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> treename, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> filename, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnNameRegexp=&quot;&quot;, const <a class="el" href="structROOT_1_1RDF_1_1RSnapshotOptions.html">RSnapshotOptions</a> &amp;options=<a class="el" href="structROOT_1_1RDF_1_1RSnapshotOptions.html">RSnapshotOptions</a>())</td></tr>
<tr class="memdesc:a38a3bd7cb047e771eb8458fa150df238 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save selected columns to disk, in a new <a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a> <code>treename</code> in file <code>filename</code>.  <a href="classROOT_1_1RDF_1_1RInterface.html#a38a3bd7cb047e771eb8458fa150df238">More...</a><br /></td></tr>
<tr class="separator:a38a3bd7cb047e771eb8458fa150df238 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e24605b8a3c02fa3a6ed63e61e17c35 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html">RInterface</a>&lt; <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a5e24605b8a3c02fa3a6ed63e61e17c35">Snapshot</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> treename, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> filename, std::initializer_list&lt; std::string &gt; columnList, const <a class="el" href="structROOT_1_1RDF_1_1RSnapshotOptions.html">RSnapshotOptions</a> &amp;options=<a class="el" href="structROOT_1_1RDF_1_1RSnapshotOptions.html">RSnapshotOptions</a>())</td></tr>
<tr class="memdesc:a5e24605b8a3c02fa3a6ed63e61e17c35 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save selected columns to disk, in a new <a class="el" href="classTTree.html" title="A TTree represents a columnar dataset. ">TTree</a> <code>treename</code> in file <code>filename</code>.  <a href="classROOT_1_1RDF_1_1RInterface.html#a5e24605b8a3c02fa3a6ed63e61e17c35">More...</a><br /></td></tr>
<tr class="separator:a5e24605b8a3c02fa3a6ed63e61e17c35 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8fafb75abfa4faed4da18dcde01568 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classTStatistic.html">TStatistic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a9e8fafb75abfa4faed4da18dcde01568">Stats</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> value=&quot;&quot;)</td></tr>
<tr class="memdesc:a9e8fafb75abfa4faed4da18dcde01568 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classTStatistic.html" title="Statistical variable, defined by its mean and variance (RMS). ">TStatistic</a> object, filled once per event (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a9e8fafb75abfa4faed4da18dcde01568">More...</a><br /></td></tr>
<tr class="separator:a9e8fafb75abfa4faed4da18dcde01568 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19e0dc32bcc8f7919615b9f89eaebda inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; <a class="el" href="classTStatistic.html">TStatistic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#af19e0dc32bcc8f7919615b9f89eaebda">Stats</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> value, <a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> weight)</td></tr>
<tr class="memdesc:af19e0dc32bcc8f7919615b9f89eaebda inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classTStatistic.html" title="Statistical variable, defined by its mean and variance (RMS). ">TStatistic</a> object, filled once per event (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#af19e0dc32bcc8f7919615b9f89eaebda">More...</a><br /></td></tr>
<tr class="separator:af19e0dc32bcc8f7919615b9f89eaebda inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482c4e4f81fe1e421c016f89cd281572 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a482c4e4f81fe1e421c016f89cd281572">StdDev</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName=&quot;&quot;)</td></tr>
<tr class="memdesc:a482c4e4f81fe1e421c016f89cd281572 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unbiased standard deviation of processed column values (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a482c4e4f81fe1e421c016f89cd281572">More...</a><br /></td></tr>
<tr class="separator:a482c4e4f81fe1e421c016f89cd281572 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d03407459120df6749af43ed506891 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; RDFDetail::SumReturnType_t&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a61d03407459120df6749af43ed506891">Sum</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> columnName=&quot;&quot;, const RDFDetail::SumReturnType_t&lt; T &gt; &amp;initValue=RDFDetail::SumReturnType_t&lt; T &gt;{})</td></tr>
<tr class="memdesc:a61d03407459120df6749af43ed506891 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of processed column values (<em>lazy action</em>)  <a href="classROOT_1_1RDF_1_1RInterface.html#a61d03407459120df6749af43ed506891">More...</a><br /></td></tr>
<tr class="separator:a61d03407459120df6749af43ed506891 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd694773a2931b6b07737ddcd1e73b4 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RResultPtr.html">RResultPtr</a>&lt; COLL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a4fd694773a2931b6b07737ddcd1e73b4">Take</a> (<a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a> column=&quot;&quot;)</td></tr>
<tr class="memdesc:a4fd694773a2931b6b07737ddcd1e73b4 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a collection of values of a column (<em>lazy action</em>, returns a std::vector by default)  <a href="classROOT_1_1RDF_1_1RInterface.html#a4fd694773a2931b6b07737ddcd1e73b4">More...</a><br /></td></tr>
<tr class="separator:a4fd694773a2931b6b07737ddcd1e73b4 inherit pub_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classROOT_1_1RDF_1_1RInterface"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classROOT_1_1RDF_1_1RInterface')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classROOT_1_1RDF_1_1RInterface.html">ROOT::RDF::RInterface&lt; RDFDetail::RLoopManager &gt;</a></td></tr>
<tr class="memitem:a0ec14f3211e950214e428656fe0e49cd inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a0ec14f3211e950214e428656fe0e49cd">RInterface</a> (const std::shared_ptr&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a> &gt; &amp;proxied, <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> &amp;lm, const <a class="el" href="classROOT_1_1Internal_1_1RDF_1_1RBookedCustomColumns.html">RDFInternal::RBookedCustomColumns</a> &amp;columns, <a class="el" href="classROOT_1_1RDF_1_1RDataSource.html">RDataSource</a> *ds)</td></tr>
<tr class="separator:a0ec14f3211e950214e428656fe0e49cd inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94df5ca315cc036c7e114cbaf280cd7e inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Internal_1_1RDF_1_1RBookedCustomColumns.html">RDFInternal::RBookedCustomColumns</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a94df5ca315cc036c7e114cbaf280cd7e">CheckAndFillDSColumns</a> (<a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> validCols, std::index_sequence&lt; S... &gt;, TTraits::TypeList&lt; ColumnTypes... &gt;)</td></tr>
<tr class="separator:a94df5ca315cc036c7e114cbaf280cd7e inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a7516adcf1c64c08b1b59b8eddba5d inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ab3cf1f75173ab4a9cab67aaa38fe1e54">RLoopManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a44a7516adcf1c64c08b1b59b8eddba5d">GetLoopManager</a> () const</td></tr>
<tr class="separator:a44a7516adcf1c64c08b1b59b8eddba5d inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbc83aa8c2589aba0525c17a46ae44c inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RDFDetail::RLoopManager</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#aafbc83aa8c2589aba0525c17a46ae44c">GetProxiedPtr</a> () const</td></tr>
<tr class="separator:aafbc83aa8c2589aba0525c17a46ae44c inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdc5bf7895b03cfd31d6c87e00949fc inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1RDF_1_1RInterface.html#a5cdc5bf7895b03cfd31d6c87e00949fc">GetValidatedColumnNames</a> (const unsigned int nColumns, const <a class="el" href="classROOT_1_1RDF_1_1RInterface.html#ae74192e63ed7b0b498b4afe17f86db36">ColumnNames_t</a> &amp;columns)</td></tr>
<tr class="memdesc:a5cdc5bf7895b03cfd31d6c87e00949fc inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the call to the GetValidatedColumnNames routine, making sure that GetBranchNames, which is expensive in terms of runtime, is called at most once.  <a href="classROOT_1_1RDF_1_1RInterface.html#a5cdc5bf7895b03cfd31d6c87e00949fc">More...</a><br /></td></tr>
<tr class="separator:a5cdc5bf7895b03cfd31d6c87e00949fc inherit pro_methods_classROOT_1_1RDF_1_1RInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

<p><code>#include &lt;<a class="el" href="RDataFrame_8hxx_source.html">ROOT/RDataFrame.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ROOT::RDataFrame:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classROOT_1_1RDataFrame__inherit__graph.svg" width="232" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a149222c853bd18aceace5e86a0ac02ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149222c853bd18aceace5e86a0ac02ff">&#9670;&nbsp;</a></span>ColumnNames_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ROOT::RDataFrame::ColumnNames_t</a> =  RDFDetail::ColumnNames_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RDataFrame_8hxx_source.html#l00044">44</a> of file <a class="el" href="RDataFrame_8hxx_source.html">RDataFrame.hxx</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0813d17002d46c962513acb96ddc8d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0813d17002d46c962513acb96ddc8d57">&#9670;&nbsp;</a></span>RDataFrame() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROOT::RDataFrame::RDataFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a>&#160;</td>
          <td class="paramname"><em>treeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a>&#160;</td>
          <td class="paramname"><em>filenameglob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultBranches</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the dataframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeName</td><td>Name of the tree contained in the directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filenameglob</td><td><a class="el" href="classTDirectory.html" title="Describe directory structure in memory. ">TDirectory</a> where the tree is stored, e.g. a <a class="el" href="classTFile.html" title="A ROOT file is a suite of consecutive data records (TKey instances) with a well defined format...">TFile</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultBranches</td><td>Collection of default branches.</td></tr>
  </table>
  </dd>
</dl>
<p>The filename globbing supports the same type of expressions as <a class="el" href="classTChain.html#a9510cc7fc76ff28c30e6775bd9085d6e" title="Add all files referenced by the passed chain to this chain. ">TChain::Add()</a>. The default branches are looked at in case no branch is specified in the booking of actions or transformations. See RInterface for the documentation of the methods available. </p>

<p class="definition">Definition at line <a class="el" href="RDataFrame_8cxx_source.html#l00828">828</a> of file <a class="el" href="RDataFrame_8cxx_source.html">RDataFrame.cxx</a>.</p>

</div>
</div>
<a id="adcebb79c00694365296d054626e87742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcebb79c00694365296d054626e87742">&#9670;&nbsp;</a></span>RDataFrame() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROOT::RDataFrame::RDataFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a>&#160;</td>
          <td class="paramname"><em>treeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileglobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultBranches</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the dataframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeName</td><td>Name of the tree contained in the directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileglobs</td><td>Collection of file names of filename globs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultBranches</td><td>Collection of default branches.</td></tr>
  </table>
  </dd>
</dl>
<p>The filename globbing supports the same type of expressions as <a class="el" href="classTChain.html#a9510cc7fc76ff28c30e6775bd9085d6e" title="Add all files referenced by the passed chain to this chain. ">TChain::Add()</a>. The default branches are looked at in case no branch is specified in the booking of actions or transformations. See RInterface for the documentation of the methods available. </p>

<p class="definition">Definition at line <a class="el" href="RDataFrame_8cxx_source.html#l00847">847</a> of file <a class="el" href="RDataFrame_8cxx_source.html">RDataFrame.cxx</a>.</p>

</div>
</div>
<a id="ac23d1d227daca2ab9c25ddfe1520d4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23d1d227daca2ab9c25ddfe1520d4ed">&#9670;&nbsp;</a></span>RDataFrame() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROOT::RDataFrame::RDataFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libcpp__string__view_8h.html#a17e3ff7f9ac2b8f068f719b829890036">std::string_view</a>&#160;</td>
          <td class="paramname"><em>treeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classTDirectory.html">TDirectory</a> *&#160;</td>
          <td class="paramname"><em>dirPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultBranches</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a45ce7601ffbca837f6773cd55a3e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a45ce7601ffbca837f6773cd55a3e72">&#9670;&nbsp;</a></span>RDataFrame() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROOT::RDataFrame::RDataFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTTree.html">TTree</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultBranches</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the dataframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>The tree or chain to be studied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultBranches</td><td>Collection of default column names to fall back to when none is specified.</td></tr>
  </table>
  </dd>
</dl>
<p>The default branches are looked at in case no branch is specified in the booking of actions or transformations. See RInterface for the documentation of the methods available. </p>

<p class="definition">Definition at line <a class="el" href="RDataFrame_8cxx_source.html#l00866">866</a> of file <a class="el" href="RDataFrame_8cxx_source.html">RDataFrame.cxx</a>.</p>

</div>
</div>
<a id="a90daba6a8ab4a0590e12d5eda3b1aec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90daba6a8ab4a0590e12d5eda3b1aec7">&#9670;&nbsp;</a></span>RDataFrame() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROOT::RDataFrame::RDataFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="RtypesCore_8h.html#aec5c78ee1411360ee0f2dc942f475c63">ULong64_t</a>&#160;</td>
          <td class="paramname"><em>numEntries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a dataframe that generates numEntries entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numEntries</td><td>The number of entries to generate.</td></tr>
  </table>
  </dd>
</dl>
<p>An empty-source dataframe constructed with a number of entries will generate those entries on the fly when some action is triggered, and it will do so for all the previously-defined temporary branches. See RInterface for the documentation of the methods available. </p>

<p class="definition">Definition at line <a class="el" href="RDataFrame_8cxx_source.html#l00879">879</a> of file <a class="el" href="RDataFrame_8cxx_source.html">RDataFrame.cxx</a>.</p>

</div>
</div>
<a id="a1644efe41e76c2cdb9a6bc9ade8b9d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1644efe41e76c2cdb9a6bc9ade8b9d0c">&#9670;&nbsp;</a></span>RDataFrame() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROOT::RDataFrame::RDataFrame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classROOT_1_1RDF_1_1RDataSource.html">ROOT::RDF::RDataSource</a> &gt;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultBranches</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build dataframe associated to datasource. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>The data-source object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultBranches</td><td>Collection of default column names to fall back to when none is specified.</td></tr>
  </table>
  </dd>
</dl>
<p>A dataframe associated to a datasource will query it to access column values. See RInterface for the documentation of the methods available. </p>

<p class="definition">Definition at line <a class="el" href="RDataFrame_8cxx_source.html#l00892">892</a> of file <a class="el" href="RDataFrame_8cxx_source.html">RDataFrame.cxx</a>.</p>

</div>
</div>
<div class="dynheader">
Libraries for ROOT::RDataFrame:</div>
<div class="dyncontent">
<div class="center"><img src="classROOT_1_1RDataFrame__coll__graph.svg" width="299pt" height="800pt"></div>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>tree/dataframe/inc/ROOT/<a class="el" href="RDataFrame_8hxx_source.html">RDataFrame.hxx</a></li>
<li>tree/dataframe/src/<a class="el" href="RDataFrame_8cxx_source.html">RDataFrame.cxx</a></li>
</ul>
</div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:11:52 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
