<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: ROOT::Math::VectorUtil Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceROOT.html">ROOT</a></li><li class="navelem"><a class="el" href="namespaceROOT_1_1Math.html">Math</a></li><li class="navelem"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html">VectorUtil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ROOT::Math::VectorUtil Namespace Reference<div class="ingroups"><a class="el" href="group__Math.html">Math</a> &raquo; <a class="el" href="group__GenVector.html">GenVector</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><br />
Global Helper functions for generic Vector classes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42489baffb667066878250e6d80f2d24"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:a42489baffb667066878250e6d80f2d24"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a42489baffb667066878250e6d80f2d24">Angle</a> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:a42489baffb667066878250e6d80f2d24"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Find Angle between two vectors.  <a href="#a42489baffb667066878250e6d80f2d24">More...</a><br /></td></tr>
<tr class="separator:a42489baffb667066878250e6d80f2d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421c8e59ccf765d83def701c1ff8fa76"><td class="memTemplParams" colspan="2">template&lt;class LVector , class BoostVector &gt; </td></tr>
<tr class="memitem:a421c8e59ccf765d83def701c1ff8fa76"><td class="memTemplItemLeft" align="right" valign="top">LVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a421c8e59ccf765d83def701c1ff8fa76">boost</a> (const LVector &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, const BoostVector &amp;<a class="el" href="TRolke_8cxx.html#a1a2354f40e332ad13673b70afc2c0dbf">b</a>)</td></tr>
<tr class="memdesc:a421c8e59ccf765d83def701c1ff8fa76"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">Boost</a> a generic Lorentz Vector class using a generic 3D Vector class describing the boost The only requirement on the vector is that implements the X(), Y(), Z(), <a class="el" href="namespaceROOT_1_1Math_1_1Chebyshev.html#ae8cd7615ee993748f2b39d07561f83ba">T()</a> and SetXYZT methods.  <a href="#a421c8e59ccf765d83def701c1ff8fa76">More...</a><br /></td></tr>
<tr class="separator:a421c8e59ccf765d83def701c1ff8fa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae322107daebad70d9d8a3cb5d8226e9a"><td class="memTemplParams" colspan="2">template&lt;class LVector , class T &gt; </td></tr>
<tr class="memitem:ae322107daebad70d9d8a3cb5d8226e9a"><td class="memTemplItemLeft" align="right" valign="top">LVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#ae322107daebad70d9d8a3cb5d8226e9a">boostX</a> (const LVector &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, T <a class="el" href="group__SpecFunc.html#ga2e8e07d8b34ecc9d76106eba4d6d9f8d">beta</a>)</td></tr>
<tr class="memdesc:ae322107daebad70d9d8a3cb5d8226e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">Boost</a> a generic Lorentz Vector class along the X direction with a factor beta The only requirement on the vector is that implements the X(), Y(), Z(), <a class="el" href="namespaceROOT_1_1Math_1_1Chebyshev.html#ae8cd7615ee993748f2b39d07561f83ba">T()</a> and SetXYZT methods.  <a href="#ae322107daebad70d9d8a3cb5d8226e9a">More...</a><br /></td></tr>
<tr class="separator:ae322107daebad70d9d8a3cb5d8226e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2897caa55368ccb382c189865b205901"><td class="memTemplParams" colspan="2">template&lt;class LVector &gt; </td></tr>
<tr class="memitem:a2897caa55368ccb382c189865b205901"><td class="memTemplItemLeft" align="right" valign="top">LVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a2897caa55368ccb382c189865b205901">boostY</a> (const LVector &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, double <a class="el" href="group__SpecFunc.html#ga2e8e07d8b34ecc9d76106eba4d6d9f8d">beta</a>)</td></tr>
<tr class="memdesc:a2897caa55368ccb382c189865b205901"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">Boost</a> a generic Lorentz Vector class along the Y direction with a factor beta The only requirement on the vector is that implements the X(), Y(), Z(), <a class="el" href="namespaceROOT_1_1Math_1_1Chebyshev.html#ae8cd7615ee993748f2b39d07561f83ba">T()</a> methods and be constructed from x,y,z,t values The beta of the boost must be &lt;= 1 or a nul Lorentz Vector will be returned  <a href="#a2897caa55368ccb382c189865b205901">More...</a><br /></td></tr>
<tr class="separator:a2897caa55368ccb382c189865b205901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb12fe093cad805805207f70014b70e6"><td class="memTemplParams" colspan="2">template&lt;class LVector &gt; </td></tr>
<tr class="memitem:adb12fe093cad805805207f70014b70e6"><td class="memTemplItemLeft" align="right" valign="top">LVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#adb12fe093cad805805207f70014b70e6">boostZ</a> (const LVector &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, double <a class="el" href="group__SpecFunc.html#ga2e8e07d8b34ecc9d76106eba4d6d9f8d">beta</a>)</td></tr>
<tr class="memdesc:adb12fe093cad805805207f70014b70e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">Boost</a> a generic Lorentz Vector class along the Z direction with a factor beta The only requirement on the vector is that implements the X(), Y(), Z(), <a class="el" href="namespaceROOT_1_1Math_1_1Chebyshev.html#ae8cd7615ee993748f2b39d07561f83ba">T()</a> methods and be constructed from x,y,z,t values The beta of the boost must be &lt;= 1 or a nul Lorentz Vector will be returned  <a href="#adb12fe093cad805805207f70014b70e6">More...</a><br /></td></tr>
<tr class="separator:adb12fe093cad805805207f70014b70e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fd155aa424c996bb1fcae7b72a4084"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:a66fd155aa424c996bb1fcae7b72a4084"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a66fd155aa424c996bb1fcae7b72a4084">CosTheta</a> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:a66fd155aa424c996bb1fcae7b72a4084"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Find CosTheta Angle between two generic 3D vectors pre-requisite: vectors implement the X(), Y() and Z()  <a href="#a66fd155aa424c996bb1fcae7b72a4084">More...</a><br /></td></tr>
<tr class="separator:a66fd155aa424c996bb1fcae7b72a4084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f74a2dc97e8c37450913d922caee6a"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:a36f74a2dc97e8c37450913d922caee6a"><td class="memTemplItemLeft" align="right" valign="top">Vector1::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a36f74a2dc97e8c37450913d922caee6a">DeltaPhi</a> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:a36f74a2dc97e8c37450913d922caee6a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Find aximutal Angle difference between two generic vectors ( v2.Phi() - v1.Phi() ) The only requirements on the Vector classes is that they implement the Phi() method  <a href="#a36f74a2dc97e8c37450913d922caee6a">More...</a><br /></td></tr>
<tr class="separator:a36f74a2dc97e8c37450913d922caee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9ac828260a00ac3bb4fa6c5a2af49c"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:a2f9ac828260a00ac3bb4fa6c5a2af49c"><td class="memTemplItemLeft" align="right" valign="top">Vector1::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a2f9ac828260a00ac3bb4fa6c5a2af49c">DeltaR</a> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:a2f9ac828260a00ac3bb4fa6c5a2af49c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Find difference in pseudorapidity (Eta) and Phi betwen two generic vectors The only requirements on the Vector classes is that they implement the Phi() and Eta() method  <a href="#a2f9ac828260a00ac3bb4fa6c5a2af49c">More...</a><br /></td></tr>
<tr class="separator:a2f9ac828260a00ac3bb4fa6c5a2af49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c46ce45438c1f68e37451bbdb933d1a"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:a1c46ce45438c1f68e37451bbdb933d1a"><td class="memTemplItemLeft" align="right" valign="top">Vector1::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a1c46ce45438c1f68e37451bbdb933d1a">DeltaR2</a> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:a1c46ce45438c1f68e37451bbdb933d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Find square of the difference in pseudorapidity (Eta) and Phi betwen two generic vectors The only requirements on the Vector classes is that they implement the Phi() and Eta() method  <a href="#a1c46ce45438c1f68e37451bbdb933d1a">More...</a><br /></td></tr>
<tr class="separator:a1c46ce45438c1f68e37451bbdb933d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e63d89cff5d8834ed7b8db0f1685d0"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:af5e63d89cff5d8834ed7b8db0f1685d0"><td class="memTemplItemLeft" align="right" valign="top">Vector1::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#af5e63d89cff5d8834ed7b8db0f1685d0">InvariantMass</a> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:af5e63d89cff5d8834ed7b8db0f1685d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
return the invariant mass of two <a class="el" href="classROOT_1_1Math_1_1LorentzVector.html" title="  Class describing a generic LorentzVector in the 4D space-time, using the specified coordinate syste...">LorentzVector</a> The only requirement on the <a class="el" href="classROOT_1_1Math_1_1LorentzVector.html" title="  Class describing a generic LorentzVector in the 4D space-time, using the specified coordinate syste...">LorentzVector</a> is that they need to implement the X() , Y(), Z() and <a class="el" href="namespaceTMath.html#a8a8fbe07e94608dbed9e9260283a442f" title="Base of natural log: . ">E()</a> methods.  <a href="#af5e63d89cff5d8834ed7b8db0f1685d0">More...</a><br /></td></tr>
<tr class="separator:af5e63d89cff5d8834ed7b8db0f1685d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec5e25fcbefda246e013c673aa5492f"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:abec5e25fcbefda246e013c673aa5492f"><td class="memTemplItemLeft" align="right" valign="top">Vector1::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#abec5e25fcbefda246e013c673aa5492f">InvariantMass2</a> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="separator:abec5e25fcbefda246e013c673aa5492f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf11694d6d123a4b9b8c07bf477b95c"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CoordSystem , class U &gt; </td></tr>
<tr class="memitem:afdf11694d6d123a4b9b8c07bf477b95c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1DisplacementVector3D.html">DisplacementVector3D</a>&lt; CoordSystem, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#afdf11694d6d123a4b9b8c07bf477b95c">Mult</a> (const Matrix &amp;<a class="el" href="Dict_8h.html#aa89069a6f0f230ad45ee1a8549231d45">m</a>, const <a class="el" href="classROOT_1_1Math_1_1DisplacementVector3D.html">DisplacementVector3D</a>&lt; CoordSystem, U &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:afdf11694d6d123a4b9b8c07bf477b95c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Multiplications of a generic matrices with a <a class="el" href="classROOT_1_1Math_1_1DisplacementVector3D.html" title=" Class describing a generic displacement vector in 3 dimensions. ">DisplacementVector3D</a> of any coordinate system.  <a href="#afdf11694d6d123a4b9b8c07bf477b95c">More...</a><br /></td></tr>
<tr class="separator:afdf11694d6d123a4b9b8c07bf477b95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054439cacc46cd9135b4e9610291173f"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CoordSystem , class U &gt; </td></tr>
<tr class="memitem:a054439cacc46cd9135b4e9610291173f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1PositionVector3D.html">PositionVector3D</a>&lt; CoordSystem, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a054439cacc46cd9135b4e9610291173f">Mult</a> (const Matrix &amp;<a class="el" href="Dict_8h.html#aa89069a6f0f230ad45ee1a8549231d45">m</a>, const <a class="el" href="classROOT_1_1Math_1_1PositionVector3D.html">PositionVector3D</a>&lt; CoordSystem, U &gt; &amp;p)</td></tr>
<tr class="memdesc:a054439cacc46cd9135b4e9610291173f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Multiplications of a generic matrices with a generic PositionVector Assume that the matrix implements the operator( i,j) and that it has at least 3 columns and 3 rows.  <a href="#a054439cacc46cd9135b4e9610291173f">More...</a><br /></td></tr>
<tr class="separator:a054439cacc46cd9135b4e9610291173f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528c8410a09d91dc9bfadcb328100768"><td class="memTemplParams" colspan="2">template&lt;class CoordSystem , class Matrix &gt; </td></tr>
<tr class="memitem:a528c8410a09d91dc9bfadcb328100768"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1LorentzVector.html">LorentzVector</a>&lt; CoordSystem &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a528c8410a09d91dc9bfadcb328100768">Mult</a> (const Matrix &amp;<a class="el" href="Dict_8h.html#aa89069a6f0f230ad45ee1a8549231d45">m</a>, const <a class="el" href="classROOT_1_1Math_1_1LorentzVector.html">LorentzVector</a>&lt; CoordSystem &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a528c8410a09d91dc9bfadcb328100768"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Multiplications of a generic matrices with a <a class="el" href="classROOT_1_1Math_1_1LorentzVector.html" title="  Class describing a generic LorentzVector in the 4D space-time, using the specified coordinate syste...">LorentzVector</a> described in any coordinate system.  <a href="#a528c8410a09d91dc9bfadcb328100768">More...</a><br /></td></tr>
<tr class="separator:a528c8410a09d91dc9bfadcb328100768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc4268cc95f8121f1833e24175b0ea2"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:a1dc4268cc95f8121f1833e24175b0ea2"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a1dc4268cc95f8121f1833e24175b0ea2">Perp</a> (const Vector1 &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, const Vector2 &amp;u)</td></tr>
<tr class="memdesc:a1dc4268cc95f8121f1833e24175b0ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Find the magnitude of the vector component of v perpendicular to the given direction of u  <a href="#a1dc4268cc95f8121f1833e24175b0ea2">More...</a><br /></td></tr>
<tr class="separator:a1dc4268cc95f8121f1833e24175b0ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941d609c26c5be28090c9c02c1a16814"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:a941d609c26c5be28090c9c02c1a16814"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a941d609c26c5be28090c9c02c1a16814">Perp2</a> (const Vector1 &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, const Vector2 &amp;u)</td></tr>
<tr class="memdesc:a941d609c26c5be28090c9c02c1a16814"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Find the magnitude square of the vector component of v perpendicular to the given direction of u  <a href="#a941d609c26c5be28090c9c02c1a16814">More...</a><br /></td></tr>
<tr class="separator:a941d609c26c5be28090c9c02c1a16814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7503c235c5e71f762d44d253e5f6e9a3"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:a7503c235c5e71f762d44d253e5f6e9a3"><td class="memTemplItemLeft" align="right" valign="top">Vector1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a7503c235c5e71f762d44d253e5f6e9a3">PerpVector</a> (const Vector1 &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, const Vector2 &amp;u)</td></tr>
<tr class="memdesc:a7503c235c5e71f762d44d253e5f6e9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Find the vector component of v perpendicular to the given direction of u  <a href="#a7503c235c5e71f762d44d253e5f6e9a3">More...</a><br /></td></tr>
<tr class="separator:a7503c235c5e71f762d44d253e5f6e9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9753deab64a2f8c42c73693010792a4e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a9753deab64a2f8c42c73693010792a4e">Phi_0_2pi</a> (double phi)</td></tr>
<tr class="memdesc:a9753deab64a2f8c42c73693010792a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Return a phi angle in the interval (0,2*PI]  <a href="#a9753deab64a2f8c42c73693010792a4e">More...</a><br /></td></tr>
<tr class="separator:a9753deab64a2f8c42c73693010792a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdacf515e8ace2751bb117cf9c708a6d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#abdacf515e8ace2751bb117cf9c708a6d">Phi_mpi_pi</a> (double phi)</td></tr>
<tr class="memdesc:abdacf515e8ace2751bb117cf9c708a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Returns phi angle in the interval (-PI,PI]  <a href="#abdacf515e8ace2751bb117cf9c708a6d">More...</a><br /></td></tr>
<tr class="separator:abdacf515e8ace2751bb117cf9c708a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad067df491cad5594499d9a1860a00f4c"><td class="memTemplParams" colspan="2">template&lt;class Vector1 , class Vector2 &gt; </td></tr>
<tr class="memitem:ad067df491cad5594499d9a1860a00f4c"><td class="memTemplItemLeft" align="right" valign="top">Vector1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#ad067df491cad5594499d9a1860a00f4c">ProjVector</a> (const Vector1 &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, const Vector2 &amp;u)</td></tr>
<tr class="memdesc:ad067df491cad5594499d9a1860a00f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Find the projection of v along the given direction u.  <a href="#ad067df491cad5594499d9a1860a00f4c">More...</a><br /></td></tr>
<tr class="separator:ad067df491cad5594499d9a1860a00f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d47baab97e8d43445ccf6de782e45b4"><td class="memTemplParams" colspan="2">template&lt;class Vector , class RotationMatrix &gt; </td></tr>
<tr class="memitem:a9d47baab97e8d43445ccf6de782e45b4"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a9d47baab97e8d43445ccf6de782e45b4">Rotate</a> (const Vector &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, const RotationMatrix &amp;rot)</td></tr>
<tr class="memdesc:a9d47baab97e8d43445ccf6de782e45b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
rotation on a generic vector using a generic rotation class.  <a href="#a9d47baab97e8d43445ccf6de782e45b4">More...</a><br /></td></tr>
<tr class="separator:a9d47baab97e8d43445ccf6de782e45b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58aa896c247454542b858eef9dffd3c5"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a58aa896c247454542b858eef9dffd3c5"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a58aa896c247454542b858eef9dffd3c5">RotateX</a> (const Vector &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, double alpha)</td></tr>
<tr class="memdesc:a58aa896c247454542b858eef9dffd3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
rotation along X axis for a generic vector by an Angle alpha returning a new vector.  <a href="#a58aa896c247454542b858eef9dffd3c5">More...</a><br /></td></tr>
<tr class="separator:a58aa896c247454542b858eef9dffd3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49aaa2a03d0911536f45ef48d8bbe235"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a49aaa2a03d0911536f45ef48d8bbe235"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a49aaa2a03d0911536f45ef48d8bbe235">RotateY</a> (const Vector &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, double alpha)</td></tr>
<tr class="memdesc:a49aaa2a03d0911536f45ef48d8bbe235"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
rotation along Y axis for a generic vector by an Angle alpha returning a new vector.  <a href="#a49aaa2a03d0911536f45ef48d8bbe235">More...</a><br /></td></tr>
<tr class="separator:a49aaa2a03d0911536f45ef48d8bbe235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455479dba72b7f09055f85ace6b19319"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a455479dba72b7f09055f85ace6b19319"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a455479dba72b7f09055f85ace6b19319">RotateZ</a> (const Vector &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, double alpha)</td></tr>
<tr class="memdesc:a455479dba72b7f09055f85ace6b19319"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
rotation along Z axis for a generic vector by an Angle alpha returning a new vector.  <a href="#a455479dba72b7f09055f85ace6b19319">More...</a><br /></td></tr>
<tr class="separator:a455479dba72b7f09055f85ace6b19319"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><br />
Global Helper functions for generic Vector classes. </p>
<p>Any Vector classes implementing some defined member functions, like Phi() or Eta() or mag() can use these functions. The functions returning a scalar value, returns always double precision number even if the vector are based on another precision type </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a42489baffb667066878250e6d80f2d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42489baffb667066878250e6d80f2d24">&#9670;&nbsp;</a></span>Angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ROOT::Math::VectorUtil::Angle </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Find Angle between two vectors. </p>
<p>Use the <a class="el" href="namespaceROOT_1_1Math_1_1VectorUtil.html#a66fd155aa424c996bb1fcae7b72a4084" title=" Find CosTheta Angle between two generic 3D vectors pre-requisite: vectors implement the X()...">CosTheta()</a> function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Vector v1 </td></tr>
    <tr><td class="paramname">v2</td><td>Vector v2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle between the two vectors <p class="formulaDsp">
\[ \theta = \cos ^{-1} \frac { \vec{v1} \cdot \vec{v2} }{ | \vec{v1} | | \vec{v2} | } \]
</p>
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00138">138</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a421c8e59ccf765d83def701c1ff8fa76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421c8e59ccf765d83def701c1ff8fa76">&#9670;&nbsp;</a></span>boost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LVector , class BoostVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LVector ROOT::Math::VectorUtil::boost </td>
          <td>(</td>
          <td class="paramtype">const LVector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoostVector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
<a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">Boost</a> a generic Lorentz Vector class using a generic 3D Vector class describing the boost The only requirement on the vector is that implements the X(), Y(), Z(), <a class="el" href="namespaceROOT_1_1Math_1_1Chebyshev.html#ae8cd7615ee993748f2b39d07561f83ba">T()</a> and SetXYZT methods. </p>
<p>The requirement on the boost vector is that needs to implement the X(), Y() , Z() retorning the vector elements describing the boost The beta of the boost must be &lt;= 1 or a nul Lorentz Vector will be returned </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00327">327</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="ae322107daebad70d9d8a3cb5d8226e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae322107daebad70d9d8a3cb5d8226e9a">&#9670;&nbsp;</a></span>boostX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LVector , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LVector ROOT::Math::VectorUtil::boostX </td>
          <td>(</td>
          <td class="paramtype">const LVector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
<a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">Boost</a> a generic Lorentz Vector class along the X direction with a factor beta The only requirement on the vector is that implements the X(), Y(), Z(), <a class="el" href="namespaceROOT_1_1Math_1_1Chebyshev.html#ae8cd7615ee993748f2b39d07561f83ba">T()</a> and SetXYZT methods. </p>
<p>The beta of the boost must be &lt;= 1 or a nul Lorentz Vector will be returned </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00356">356</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a2897caa55368ccb382c189865b205901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2897caa55368ccb382c189865b205901">&#9670;&nbsp;</a></span>boostY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LVector ROOT::Math::VectorUtil::boostY </td>
          <td>(</td>
          <td class="paramtype">const LVector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
<a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">Boost</a> a generic Lorentz Vector class along the Y direction with a factor beta The only requirement on the vector is that implements the X(), Y(), Z(), <a class="el" href="namespaceROOT_1_1Math_1_1Chebyshev.html#ae8cd7615ee993748f2b39d07561f83ba">T()</a> methods and be constructed from x,y,z,t values The beta of the boost must be &lt;= 1 or a nul Lorentz Vector will be returned </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00377">377</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="adb12fe093cad805805207f70014b70e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb12fe093cad805805207f70014b70e6">&#9670;&nbsp;</a></span>boostZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LVector ROOT::Math::VectorUtil::boostZ </td>
          <td>(</td>
          <td class="paramtype">const LVector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
<a class="el" href="classROOT_1_1Math_1_1Boost.html" title="Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matr...">Boost</a> a generic Lorentz Vector class along the Z direction with a factor beta The only requirement on the vector is that implements the X(), Y(), Z(), <a class="el" href="namespaceROOT_1_1Math_1_1Chebyshev.html#ae8cd7615ee993748f2b39d07561f83ba">T()</a> methods and be constructed from x,y,z,t values The beta of the boost must be &lt;= 1 or a nul Lorentz Vector will be returned </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00397">397</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a66fd155aa424c996bb1fcae7b72a4084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fd155aa424c996bb1fcae7b72a4084">&#9670;&nbsp;</a></span>CosTheta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double ROOT::Math::VectorUtil::CosTheta </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
Find CosTheta Angle between two generic 3D vectors pre-requisite: vectors implement the X(), Y() and Z() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Vector v1 </td></tr>
    <tr><td class="paramname">v2</td><td>Vector v2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cosine of Angle between the two vectors <p class="formulaDsp">
\[ \cos \theta = \frac { \vec{v1} \cdot \vec{v2} }{ | \vec{v1} | | \vec{v2} | } \]
</p>
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00112">112</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a36f74a2dc97e8c37450913d922caee6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f74a2dc97e8c37450913d922caee6a">&#9670;&nbsp;</a></span>DeltaPhi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1::Scalar ROOT::Math::VectorUtil::DeltaPhi </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Find aximutal Angle difference between two generic vectors ( v2.Phi() - v1.Phi() ) The only requirements on the Vector classes is that they implement the Phi() method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Vector of any type implementing the Phi() operator </td></tr>
    <tr><td class="paramname">v2</td><td>Vector of any type implementing the Phi() operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Phi difference <p class="formulaDsp">
\[ \Delta \phi = \phi_2 - \phi_1 \]
</p>
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00059">59</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a2f9ac828260a00ac3bb4fa6c5a2af49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9ac828260a00ac3bb4fa6c5a2af49c">&#9670;&nbsp;</a></span>DeltaR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1::Scalar ROOT::Math::VectorUtil::DeltaR </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Find difference in pseudorapidity (Eta) and Phi betwen two generic vectors The only requirements on the Vector classes is that they implement the Phi() and Eta() method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Vector 1 </td></tr>
    <tr><td class="paramname">v2</td><td>Vector 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle between the two vectors <p class="formulaDsp">
\[ \Delta R = \sqrt{ ( \Delta \phi )^2 + ( \Delta \eta )^2 } \]
</p>
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00095">95</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a1c46ce45438c1f68e37451bbdb933d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c46ce45438c1f68e37451bbdb933d1a">&#9670;&nbsp;</a></span>DeltaR2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1::Scalar ROOT::Math::VectorUtil::DeltaR2 </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Find square of the difference in pseudorapidity (Eta) and Phi betwen two generic vectors The only requirements on the Vector classes is that they implement the Phi() and Eta() method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Vector 1 </td></tr>
    <tr><td class="paramname">v2</td><td>Vector 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle between the two vectors <p class="formulaDsp">
\[ \Delta R2 = ( \Delta \phi )^2 + ( \Delta \eta )^2 \]
</p>
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00080">80</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="af5e63d89cff5d8834ed7b8db0f1685d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e63d89cff5d8834ed7b8db0f1685d0">&#9670;&nbsp;</a></span>InvariantMass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1::Scalar ROOT::Math::VectorUtil::InvariantMass </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
return the invariant mass of two <a class="el" href="classROOT_1_1Math_1_1LorentzVector.html" title="  Class describing a generic LorentzVector in the 4D space-time, using the specified coordinate syste...">LorentzVector</a> The only requirement on the <a class="el" href="classROOT_1_1Math_1_1LorentzVector.html" title="  Class describing a generic LorentzVector in the 4D space-time, using the specified coordinate syste...">LorentzVector</a> is that they need to implement the X() , Y(), Z() and <a class="el" href="namespaceTMath.html#a8a8fbe07e94608dbed9e9260283a442f" title="Base of natural log: . ">E()</a> methods. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>LorenzVector 1 </td></tr>
    <tr><td class="paramname">v2</td><td>LorenzVector 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>invariant mass M <p class="formulaDsp">
\[ M_{12} = \sqrt{ (\vec{v1} + \vec{v2} ) \cdot (\vec{v1} + \vec{v2} ) } \]
</p>
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00215">215</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="abec5e25fcbefda246e013c673aa5492f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec5e25fcbefda246e013c673aa5492f">&#9670;&nbsp;</a></span>InvariantMass2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1::Scalar ROOT::Math::VectorUtil::InvariantMass2 </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00229">229</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="afdf11694d6d123a4b9b8c07bf477b95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf11694d6d123a4b9b8c07bf477b95c">&#9670;&nbsp;</a></span>Mult() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class CoordSystem , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1DisplacementVector3D.html">DisplacementVector3D</a>&lt;CoordSystem,U&gt; ROOT::Math::VectorUtil::Mult </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1DisplacementVector3D.html">DisplacementVector3D</a>&lt; CoordSystem, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Multiplications of a generic matrices with a <a class="el" href="classROOT_1_1Math_1_1DisplacementVector3D.html" title=" Class describing a generic displacement vector in 3 dimensions. ">DisplacementVector3D</a> of any coordinate system. </p>
<p>Assume that the matrix implements the operator( i,j) and that it has at least 3 columns and 3 rows. There is no check on the matrix size !! </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00425">425</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a054439cacc46cd9135b4e9610291173f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054439cacc46cd9135b4e9610291173f">&#9670;&nbsp;</a></span>Mult() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class CoordSystem , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1PositionVector3D.html">PositionVector3D</a>&lt;CoordSystem,U&gt; ROOT::Math::VectorUtil::Mult </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1PositionVector3D.html">PositionVector3D</a>&lt; CoordSystem, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Multiplications of a generic matrices with a generic PositionVector Assume that the matrix implements the operator( i,j) and that it has at least 3 columns and 3 rows. </p>
<p>There is no check on the matrix size !! </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00440">440</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a528c8410a09d91dc9bfadcb328100768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528c8410a09d91dc9bfadcb328100768">&#9670;&nbsp;</a></span>Mult() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CoordSystem , class Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1LorentzVector.html">LorentzVector</a>&lt;CoordSystem&gt; ROOT::Math::VectorUtil::Mult </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1LorentzVector.html">LorentzVector</a>&lt; CoordSystem &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Multiplications of a generic matrices with a <a class="el" href="classROOT_1_1Math_1_1LorentzVector.html" title="  Class describing a generic LorentzVector in the 4D space-time, using the specified coordinate syste...">LorentzVector</a> described in any coordinate system. </p>
<p>Assume that the matrix implements the operator( i,j) and that it has at least 4 columns and 4 rows. There is no check on the matrix size !! </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00457">457</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a1dc4268cc95f8121f1833e24175b0ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc4268cc95f8121f1833e24175b0ea2">&#9670;&nbsp;</a></span>Perp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ROOT::Math::VectorUtil::Perp </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Find the magnitude of the vector component of v perpendicular to the given direction of u </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector v for which the perpendicular component is to be found </td></tr>
    <tr><td class="paramname">u</td><td>Vector specifying the direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the component of v which is perpendicular to u <p class="formulaDsp">
\[ perp = | \vec{v} - \frac{ \vec{v} \cdot \vec{u} }{|\vec{u}|}\vec{u} | \]
</p>
 Precondition is that Vector1 implements Dot function and Vector2 implements X(),Y() and Z() </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00196">196</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a941d609c26c5be28090c9c02c1a16814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941d609c26c5be28090c9c02c1a16814">&#9670;&nbsp;</a></span>Perp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ROOT::Math::VectorUtil::Perp2 </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Find the magnitude square of the vector component of v perpendicular to the given direction of u </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector v for which the perpendicular component is to be found </td></tr>
    <tr><td class="paramname">u</td><td>Vector specifying the direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square value of the component of v which is perpendicular to u <p class="formulaDsp">
\[ perp = | \vec{v} - \frac{ \vec{v} \cdot \vec{u} }{|\vec{u}|}\vec{u} |^2 \]
</p>
 Precondition is that Vector1 implements Dot function and Vector2 implements X(),Y() and Z() </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00180">180</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a7503c235c5e71f762d44d253e5f6e9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7503c235c5e71f762d44d253e5f6e9a3">&#9670;&nbsp;</a></span>PerpVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1 ROOT::Math::VectorUtil::PerpVector </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
Find the vector component of v perpendicular to the given direction of u </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector v for which the perpendicular component is to be found </td></tr>
    <tr><td class="paramname">u</td><td>Vector specifying the direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector component of v which is perpendicular to u <p class="formulaDsp">
\[ \vec{perp} = \vec{v} - \frac{ \vec{v} \cdot \vec{u} }{|\vec{u}|}\vec{u} \]
</p>
 Precondition is that Vector1 implements Dot function and Vector2 implements X(),Y() and Z() </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00167">167</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a9753deab64a2f8c42c73693010792a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9753deab64a2f8c42c73693010792a4e">&#9670;&nbsp;</a></span>Phi_0_2pi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ROOT::Math::VectorUtil::Phi_0_2pi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
Return a phi angle in the interval (0,2*PI] </p>

<p class="definition">Definition at line <a class="el" href="VectorUtil_8cxx_source.html#l00022">22</a> of file <a class="el" href="VectorUtil_8cxx_source.html">VectorUtil.cxx</a>.</p>

</div>
</div>
<a id="abdacf515e8ace2751bb117cf9c708a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdacf515e8ace2751bb117cf9c708a6d">&#9670;&nbsp;</a></span>Phi_mpi_pi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ROOT::Math::VectorUtil::Phi_mpi_pi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
Returns phi angle in the interval (-PI,PI] </p>

<p class="definition">Definition at line <a class="el" href="VectorUtil_8cxx_source.html#l00036">36</a> of file <a class="el" href="VectorUtil_8cxx_source.html">VectorUtil.cxx</a>.</p>

</div>
</div>
<a id="ad067df491cad5594499d9a1860a00f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad067df491cad5594499d9a1860a00f4c">&#9670;&nbsp;</a></span>ProjVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector1 , class Vector2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector1 ROOT::Math::VectorUtil::ProjVector </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
Find the projection of v along the given direction u. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector v for which the propjection is to be found </td></tr>
    <tr><td class="paramname">u</td><td>Vector specifying the direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector projection (same type of v) <p class="formulaDsp">
\[ \vec{proj} = \frac{ \vec{v} \cdot \vec{u} }{|\vec{u}|}\vec{u} \]
</p>
 Precondition is that Vector1 implements Dot function and Vector2 implements X(),Y() and Z() </dd></dl>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00151">151</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a9d47baab97e8d43445ccf6de782e45b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d47baab97e8d43445ccf6de782e45b4">&#9670;&nbsp;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector , class RotationMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector ROOT::Math::VectorUtil::Rotate </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RotationMatrix &amp;&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
rotation on a generic vector using a generic rotation class. </p>
<p>The only requirement on the vector is that implements the X(), Y(), Z() and SetXYZ methods. The requirement on the rotation matrix is that need to implement the (i,j) operator returning the matrix element with <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R(0,0)</a> = xx element </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00306">306</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a58aa896c247454542b858eef9dffd3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58aa896c247454542b858eef9dffd3c5">&#9670;&nbsp;</a></span>RotateX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector ROOT::Math::VectorUtil::RotateX </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
rotation along X axis for a generic vector by an Angle alpha returning a new vector. </p>
<p>The only pre requisite on the Vector is that it has to implement the X() , Y() and Z() and SetXYZ methods. </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00253">253</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a49aaa2a03d0911536f45ef48d8bbe235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49aaa2a03d0911536f45ef48d8bbe235">&#9670;&nbsp;</a></span>RotateY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector ROOT::Math::VectorUtil::RotateY </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
rotation along Y axis for a generic vector by an Angle alpha returning a new vector. </p>
<p>The only pre requisite on the Vector is that it has to implement the X() , Y() and Z() and SetXYZ methods. </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00270">270</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
<a id="a455479dba72b7f09055f85ace6b19319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455479dba72b7f09055f85ace6b19319">&#9670;&nbsp;</a></span>RotateZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector ROOT::Math::VectorUtil::RotateZ </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
rotation along Z axis for a generic vector by an Angle alpha returning a new vector. </p>
<p>The only pre requisite on the Vector is that it has to implement the X() , Y() and Z() and SetXYZ methods. </p>

<p class="definition">Definition at line <a class="el" href="GenVector_2VectorUtil_8h_source.html#l00287">287</a> of file <a class="el" href="GenVector_2VectorUtil_8h_source.html">VectorUtil.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:11:57 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
