<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: math/smatrix/inc/Math/BinaryOperators.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_296d53ceaeaa7e099814a6def439fe8a.html">math</a></li><li class="navelem"><a class="el" href="dir_f43f6ca471f50f263e45baf126f92495.html">smatrix</a></li><li class="navelem"><a class="el" href="dir_e7be667677475218611db0baa5e44928.html">inc</a></li><li class="navelem"><a class="el" href="dir_af26c91ddd6fb3cd05b4f2853b0a22e8.html">Math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BinaryOperators.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="BinaryOpPolicy_8h_source.html">Math/BinaryOpPolicy.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Expression_8h_source.html">Math/Expression.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for BinaryOperators.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="BinaryOperators_8h__incl.svg" width="619" height="291"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="BinaryOperators_8h__dep__incl.svg" width="180" height="499"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1AddOp.html">ROOT::Math::AddOp&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition Operation Class.  <a href="classROOT_1_1Math_1_1AddOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1DivOp.html">ROOT::Math::DivOp&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division (element-wise) Operation Class.  <a href="classROOT_1_1Math_1_1DivOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1MinOp.html">ROOT::Math::MinOp&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction Operation Class.  <a href="classROOT_1_1Math_1_1MinOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1MulOp.html">ROOT::Math::MulOp&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication (element-wise) Operation Class.  <a href="classROOT_1_1Math_1_1MulOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix&lt; T, D1, D2, R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html" title="SMatrix: a generic fixed size D1 x D2 Matrix class. ">SMatrix</a>: a generic fixed size D1 x D2 Matrix class.  <a href="classROOT_1_1Math_1_1SMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SVector.html">ROOT::Math::SVector&lt; T, D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classROOT_1_1Math_1_1SVector.html" title="SVector: a generic fixed size Vector class. ">SVector</a>: a generic fixed size Vector class.  <a href="classROOT_1_1Math_1_1SVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceROOT"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROOT.html">ROOT</a></td></tr>
<tr class="memdesc:namespaceROOT"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for new <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> classes and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceROOT_1_1Math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html">ROOT::Math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadc22f440c2cf71eba66be7d72854187f"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:gadc22f440c2cf71eba66be7d72854187f"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; DivOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#gadc22f440c2cf71eba66be7d72854187f">ROOT::Math::Div</a> (const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadc22f440c2cf71eba66be7d72854187f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division (element wise) of two matrices of the same dimensions: C(i,j) = A(i,j) / B(i,j) returning a matrix expression.  <a href="group__MatrixFunctions.html#gadc22f440c2cf71eba66be7d72854187f">More...</a><br /></td></tr>
<tr class="separator:gadc22f440c2cf71eba66be7d72854187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0d141a05afead7088c1c31ce253002"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a4e0d141a05afead7088c1c31ce253002"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; DivOp&lt; T &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a4e0d141a05afead7088c1c31ce253002">ROOT::Math::Div</a> (const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a4e0d141a05afead7088c1c31ce253002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e1d299b920fb93f2fac680598658c2"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a84e1d299b920fb93f2fac680598658c2"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; DivOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a84e1d299b920fb93f2fac680598658c2">ROOT::Math::Div</a> (const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a84e1d299b920fb93f2fac680598658c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4e9b538607b984c09a4c97371d84da"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:aab4e9b538607b984c09a4c97371d84da"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; DivOp&lt; T &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, Expr&lt; B, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#aab4e9b538607b984c09a4c97371d84da">ROOT::Math::Div</a> (const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const Expr&lt; B, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:aab4e9b538607b984c09a4c97371d84da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71bbb9d37e1dc5a532ea9f9daa09e655"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int D&gt; </td></tr>
<tr class="memitem:ga71bbb9d37e1dc5a532ea9f9daa09e655"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; MulOp&lt; T &gt;, SVector&lt; T, D &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#ga71bbb9d37e1dc5a532ea9f9daa09e655">ROOT::Math::operator*</a> (const SVector&lt; T, D &gt; &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga71bbb9d37e1dc5a532ea9f9daa09e655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element by element vector product v3(i) = v1(i)*v2(i) returning a vector expression.  <a href="group__VectFunction.html#ga71bbb9d37e1dc5a532ea9f9daa09e655">More...</a><br /></td></tr>
<tr class="separator:ga71bbb9d37e1dc5a532ea9f9daa09e655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c8c5114139896ace2b1e14f00b150d"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:ab5c8c5114139896ace2b1e14f00b150d"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; MulOp&lt; T &gt;, Expr&lt; A, T, D &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#ab5c8c5114139896ace2b1e14f00b150d">ROOT::Math::operator*</a> (const VecExpr&lt; A, T, D &gt; &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:ab5c8c5114139896ace2b1e14f00b150d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e461b079e4bc27e8f698f6db813967"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a50e461b079e4bc27e8f698f6db813967"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; MulOp&lt; T &gt;, SVector&lt; T, D &gt;, VecExpr&lt; A, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a50e461b079e4bc27e8f698f6db813967">ROOT::Math::operator*</a> (const SVector&lt; T, D &gt; &amp;lhs, const VecExpr&lt; A, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:a50e461b079e4bc27e8f698f6db813967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3e01d16db2621ec7d6a457d4dbde35"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a7c3e01d16db2621ec7d6a457d4dbde35"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; MulOp&lt; T &gt;, VecExpr&lt; A, T, D &gt;, VecExpr&lt; B, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a7c3e01d16db2621ec7d6a457d4dbde35">ROOT::Math::operator*</a> (const VecExpr&lt; A, T, D &gt; &amp;lhs, const VecExpr&lt; B, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:a7c3e01d16db2621ec7d6a457d4dbde35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b10282cc69c8e5fd5cbd7d187fce987"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a7b10282cc69c8e5fd5cbd7d187fce987"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyR&lt; MulOp&lt; T &gt;, SVector&lt; T, D &gt;, Constant&lt; A &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a7b10282cc69c8e5fd5cbd7d187fce987">ROOT::Math::operator*</a> (const SVector&lt; T, D &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="separator:a7b10282cc69c8e5fd5cbd7d187fce987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaafd025445a076103adff1a1a110085"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:acaafd025445a076103adff1a1a110085"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyL&lt; MulOp&lt; T &gt;, Constant&lt; A &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#acaafd025445a076103adff1a1a110085">ROOT::Math::operator*</a> (const A &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:acaafd025445a076103adff1a1a110085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8953104c00ffca2989558c1b3027e636"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a8953104c00ffca2989558c1b3027e636"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyR&lt; MulOp&lt; T &gt;, VecExpr&lt; B, T, D &gt;, Constant&lt; A &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a8953104c00ffca2989558c1b3027e636">ROOT::Math::operator*</a> (const VecExpr&lt; B, T, D &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="separator:a8953104c00ffca2989558c1b3027e636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049d0c7ebeeb9d77762ff3c5efdf9b85"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a049d0c7ebeeb9d77762ff3c5efdf9b85"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyL&lt; MulOp&lt; T &gt;, Constant&lt; A &gt;, VecExpr&lt; B, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a049d0c7ebeeb9d77762ff3c5efdf9b85">ROOT::Math::operator*</a> (const A &amp;lhs, const VecExpr&lt; B, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:a049d0c7ebeeb9d77762ff3c5efdf9b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a6563c400df3e2cdfac5c643847778"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:gaf3a6563c400df3e2cdfac5c643847778"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyR&lt; MulOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, Constant&lt; A &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#gaf3a6563c400df3e2cdfac5c643847778">ROOT::Math::operator*</a> (const SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="memdesc:gaf3a6563c400df3e2cdfac5c643847778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication (element wise) of a matrix and a scalar, B(i,j) = A(i,j) * s returning a matrix expression.  <a href="group__MatrixFunctions.html#gaf3a6563c400df3e2cdfac5c643847778">More...</a><br /></td></tr>
<tr class="separator:gaf3a6563c400df3e2cdfac5c643847778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0a003419c95f866b51f7c4dc464434"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:ga6f0a003419c95f866b51f7c4dc464434"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyL&lt; MulOp&lt; T &gt;, Constant&lt; A &gt;, SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#ga6f0a003419c95f866b51f7c4dc464434">ROOT::Math::operator*</a> (const A &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6f0a003419c95f866b51f7c4dc464434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication (element wise) of a matrix and a scalar, B(i,j) = s * A(i,j) returning a matrix expression.  <a href="group__MatrixFunctions.html#ga6f0a003419c95f866b51f7c4dc464434">More...</a><br /></td></tr>
<tr class="separator:ga6f0a003419c95f866b51f7c4dc464434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f89e894255555a69514a931e76b92ff"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:a4f89e894255555a69514a931e76b92ff"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyR&lt; MulOp&lt; T &gt;, Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, Constant&lt; A &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a4f89e894255555a69514a931e76b92ff">ROOT::Math::operator*</a> (const Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="separator:a4f89e894255555a69514a931e76b92ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadced605a5ca0962c4a0203037134381"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:aadced605a5ca0962c4a0203037134381"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyL&lt; MulOp&lt; T &gt;, Constant&lt; A &gt;, Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#aadced605a5ca0962c4a0203037134381">ROOT::Math::operator*</a> (const A &amp;lhs, const Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:aadced605a5ca0962c4a0203037134381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f00953d390e1c9696a34202244db0f"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int D&gt; </td></tr>
<tr class="memitem:ga50f00953d390e1c9696a34202244db0f"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; AddOp&lt; T &gt;, SVector&lt; T, D &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#ga50f00953d390e1c9696a34202244db0f">ROOT::Math::operator+</a> (const SVector&lt; T, D &gt; &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga50f00953d390e1c9696a34202244db0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two vectors v3 = v1+v2 returning a vector expression.  <a href="group__VectFunction.html#ga50f00953d390e1c9696a34202244db0f">More...</a><br /></td></tr>
<tr class="separator:ga50f00953d390e1c9696a34202244db0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9fd327f9d69b215bdac12684b5d0ac"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:afd9fd327f9d69b215bdac12684b5d0ac"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; AddOp&lt; T &gt;, VecExpr&lt; A, T, D &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#afd9fd327f9d69b215bdac12684b5d0ac">ROOT::Math::operator+</a> (const VecExpr&lt; A, T, D &gt; &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:afd9fd327f9d69b215bdac12684b5d0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4990f2bd6d1c8cf8c9c947cf4def2f41"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a4990f2bd6d1c8cf8c9c947cf4def2f41"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; AddOp&lt; T &gt;, SVector&lt; T, D &gt;, VecExpr&lt; A, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a4990f2bd6d1c8cf8c9c947cf4def2f41">ROOT::Math::operator+</a> (const SVector&lt; T, D &gt; &amp;lhs, const VecExpr&lt; A, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:a4990f2bd6d1c8cf8c9c947cf4def2f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f9b888edb01b1d7cc8f147a7a4b1fc"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a21f9b888edb01b1d7cc8f147a7a4b1fc"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; AddOp&lt; T &gt;, VecExpr&lt; A, T, D &gt;, VecExpr&lt; B, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a21f9b888edb01b1d7cc8f147a7a4b1fc">ROOT::Math::operator+</a> (const VecExpr&lt; A, T, D &gt; &amp;lhs, const VecExpr&lt; B, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:a21f9b888edb01b1d7cc8f147a7a4b1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8683b98a5f35c18414086190cb78b7e"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:gaf8683b98a5f35c18414086190cb78b7e"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyR&lt; AddOp&lt; T &gt;, SVector&lt; T, D &gt;, Constant&lt; A &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#gaf8683b98a5f35c18414086190cb78b7e">ROOT::Math::operator+</a> (const SVector&lt; T, D &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="memdesc:gaf8683b98a5f35c18414086190cb78b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a scalar to a each vector element: v2(i) = v1(i) + a returning a vector expression.  <a href="group__VectFunction.html#gaf8683b98a5f35c18414086190cb78b7e">More...</a><br /></td></tr>
<tr class="separator:gaf8683b98a5f35c18414086190cb78b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa16f33c7a2b09a76a2c90d08103e38"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:ga3aa16f33c7a2b09a76a2c90d08103e38"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyL&lt; AddOp&lt; T &gt;, Constant&lt; A &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#ga3aa16f33c7a2b09a76a2c90d08103e38">ROOT::Math::operator+</a> (const A &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3aa16f33c7a2b09a76a2c90d08103e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a scalar to each vector element v2(i) = a + v1(i) returning a vector expression.  <a href="group__VectFunction.html#ga3aa16f33c7a2b09a76a2c90d08103e38">More...</a><br /></td></tr>
<tr class="separator:ga3aa16f33c7a2b09a76a2c90d08103e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290dea0cb45930fb8eb8df5be815d330"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a290dea0cb45930fb8eb8df5be815d330"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyR&lt; AddOp&lt; T &gt;, VecExpr&lt; B, T, D &gt;, Constant&lt; A &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a290dea0cb45930fb8eb8df5be815d330">ROOT::Math::operator+</a> (const VecExpr&lt; B, T, D &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="separator:a290dea0cb45930fb8eb8df5be815d330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356981cfb778bd22e2b1d4bbf1603cbb"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a356981cfb778bd22e2b1d4bbf1603cbb"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyL&lt; AddOp&lt; T &gt;, Constant&lt; A &gt;, VecExpr&lt; B, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a356981cfb778bd22e2b1d4bbf1603cbb">ROOT::Math::operator+</a> (const A &amp;lhs, const VecExpr&lt; B, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:a356981cfb778bd22e2b1d4bbf1603cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0bf5d020c65f4603d8dd8fb9d08eaf2"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:gad0bf5d020c65f4603d8dd8fb9d08eaf2"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; AddOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#gad0bf5d020c65f4603d8dd8fb9d08eaf2">ROOT::Math::operator+</a> (const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad0bf5d020c65f4603d8dd8fb9d08eaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two matrices C = A+B returning a matrix expression.  <a href="group__MatrixFunctions.html#gad0bf5d020c65f4603d8dd8fb9d08eaf2">More...</a><br /></td></tr>
<tr class="separator:gad0bf5d020c65f4603d8dd8fb9d08eaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812a48052204da38c0be939328890339"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a812a48052204da38c0be939328890339"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; AddOp&lt; T &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a812a48052204da38c0be939328890339">ROOT::Math::operator+</a> (const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a812a48052204da38c0be939328890339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cc775fd3513eb4ffd95f004056d540"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a64cc775fd3513eb4ffd95f004056d540"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; AddOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a64cc775fd3513eb4ffd95f004056d540">ROOT::Math::operator+</a> (const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a64cc775fd3513eb4ffd95f004056d540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1af8a0415b6ce6c4fdd02662977f7a"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:abe1af8a0415b6ce6c4fdd02662977f7a"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; AddOp&lt; T &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, Expr&lt; B, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#abe1af8a0415b6ce6c4fdd02662977f7a">ROOT::Math::operator+</a> (const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const Expr&lt; B, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:abe1af8a0415b6ce6c4fdd02662977f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686bef57c0f4e10d72b0cd6a8a04d3ad"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:ga686bef57c0f4e10d72b0cd6a8a04d3ad"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyR&lt; AddOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, Constant&lt; A &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#ga686bef57c0f4e10d72b0cd6a8a04d3ad">ROOT::Math::operator+</a> (const SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="memdesc:ga686bef57c0f4e10d72b0cd6a8a04d3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition element by element of matrix and a scalar C(i,j) = A(i,j) + s returning a matrix expression.  <a href="group__MatrixFunctions.html#ga686bef57c0f4e10d72b0cd6a8a04d3ad">More...</a><br /></td></tr>
<tr class="separator:ga686bef57c0f4e10d72b0cd6a8a04d3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95628cd439e9eeb10f4f62b132d79cd7"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:ga95628cd439e9eeb10f4f62b132d79cd7"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyL&lt; AddOp&lt; T &gt;, Constant&lt; A &gt;, SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#ga95628cd439e9eeb10f4f62b132d79cd7">ROOT::Math::operator+</a> (const A &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga95628cd439e9eeb10f4f62b132d79cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition element by element of matrix and a scalar C(i,j) = s + A(i,j) returning a matrix expression.  <a href="group__MatrixFunctions.html#ga95628cd439e9eeb10f4f62b132d79cd7">More...</a><br /></td></tr>
<tr class="separator:ga95628cd439e9eeb10f4f62b132d79cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9a935ec6ad2bb862c288388179c19e"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:aea9a935ec6ad2bb862c288388179c19e"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyR&lt; AddOp&lt; T &gt;, Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, Constant&lt; A &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#aea9a935ec6ad2bb862c288388179c19e">ROOT::Math::operator+</a> (const Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="separator:aea9a935ec6ad2bb862c288388179c19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2551da774c6c34cf337842fb6c91cfb7"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:a2551da774c6c34cf337842fb6c91cfb7"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyL&lt; AddOp&lt; T &gt;, Constant&lt; A &gt;, Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a2551da774c6c34cf337842fb6c91cfb7">ROOT::Math::operator+</a> (const A &amp;lhs, const Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a2551da774c6c34cf337842fb6c91cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d2529b88d1210645e9c143ad5e6ac99"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int D&gt; </td></tr>
<tr class="memitem:ga0d2529b88d1210645e9c143ad5e6ac99"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; MinOp&lt; T &gt;, SVector&lt; T, D &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#ga0d2529b88d1210645e9c143ad5e6ac99">ROOT::Math::operator-</a> (const SVector&lt; T, D &gt; &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0d2529b88d1210645e9c143ad5e6ac99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Subtraction: v3 = v1 - v2 returning a vector expression.  <a href="group__VectFunction.html#ga0d2529b88d1210645e9c143ad5e6ac99">More...</a><br /></td></tr>
<tr class="separator:ga0d2529b88d1210645e9c143ad5e6ac99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c944e1ddb3a093c01f3bca28c987c4"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:aa9c944e1ddb3a093c01f3bca28c987c4"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; MinOp&lt; T &gt;, VecExpr&lt; A, T, D &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#aa9c944e1ddb3a093c01f3bca28c987c4">ROOT::Math::operator-</a> (const VecExpr&lt; A, T, D &gt; &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:aa9c944e1ddb3a093c01f3bca28c987c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f82c88289e58dabf35856dad14e4526"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a3f82c88289e58dabf35856dad14e4526"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; MinOp&lt; T &gt;, SVector&lt; T, D &gt;, VecExpr&lt; A, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a3f82c88289e58dabf35856dad14e4526">ROOT::Math::operator-</a> (const SVector&lt; T, D &gt; &amp;lhs, const VecExpr&lt; A, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:a3f82c88289e58dabf35856dad14e4526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe24e8df39539505861795e4f35a09b6"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:afe24e8df39539505861795e4f35a09b6"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; MinOp&lt; T &gt;, VecExpr&lt; A, T, D &gt;, VecExpr&lt; B, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#afe24e8df39539505861795e4f35a09b6">ROOT::Math::operator-</a> (const VecExpr&lt; A, T, D &gt; &amp;lhs, const VecExpr&lt; B, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:afe24e8df39539505861795e4f35a09b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d79ed35927296ccde8b645294bf517"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:gac4d79ed35927296ccde8b645294bf517"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyR&lt; MinOp&lt; T &gt;, SVector&lt; T, D &gt;, Constant&lt; A &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#gac4d79ed35927296ccde8b645294bf517">ROOT::Math::operator-</a> (const SVector&lt; T, D &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="memdesc:gac4d79ed35927296ccde8b645294bf517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of a scalar from each vector element: v2(i) = v1(i) - a returning a vector expression.  <a href="group__VectFunction.html#gac4d79ed35927296ccde8b645294bf517">More...</a><br /></td></tr>
<tr class="separator:gac4d79ed35927296ccde8b645294bf517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb60eb1c7ce5da594af79b03023726c7"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:gadb60eb1c7ce5da594af79b03023726c7"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyL&lt; MinOp&lt; T &gt;, Constant&lt; A &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#gadb60eb1c7ce5da594af79b03023726c7">ROOT::Math::operator-</a> (const A &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadb60eb1c7ce5da594af79b03023726c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction scalar vector (for each vector element) v2(i) = a - v1(i) returning a vector expression.  <a href="group__VectFunction.html#gadb60eb1c7ce5da594af79b03023726c7">More...</a><br /></td></tr>
<tr class="separator:gadb60eb1c7ce5da594af79b03023726c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df7a4997a5cc08b7641cda45f487de9"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a3df7a4997a5cc08b7641cda45f487de9"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyR&lt; MinOp&lt; T &gt;, VecExpr&lt; B, T, D &gt;, Constant&lt; A &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a3df7a4997a5cc08b7641cda45f487de9">ROOT::Math::operator-</a> (const VecExpr&lt; B, T, D &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="separator:a3df7a4997a5cc08b7641cda45f487de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707e5c55070fef7c2d6fec35a866e3a5"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a707e5c55070fef7c2d6fec35a866e3a5"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyL&lt; MinOp&lt; T &gt;, Constant&lt; A &gt;, VecExpr&lt; B, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a707e5c55070fef7c2d6fec35a866e3a5">ROOT::Math::operator-</a> (const A &amp;lhs, const VecExpr&lt; B, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:a707e5c55070fef7c2d6fec35a866e3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ecfc01a3ef1e471fd3186d53b7e04db"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:ga4ecfc01a3ef1e471fd3186d53b7e04db"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; MinOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#ga4ecfc01a3ef1e471fd3186d53b7e04db">ROOT::Math::operator-</a> (const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4ecfc01a3ef1e471fd3186d53b7e04db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two matrices C = A-B returning a matrix expression.  <a href="group__MatrixFunctions.html#ga4ecfc01a3ef1e471fd3186d53b7e04db">More...</a><br /></td></tr>
<tr class="separator:ga4ecfc01a3ef1e471fd3186d53b7e04db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77691dde9a5937fa56615c41e7e16610"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a77691dde9a5937fa56615c41e7e16610"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; MinOp&lt; T &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a77691dde9a5937fa56615c41e7e16610">ROOT::Math::operator-</a> (const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a77691dde9a5937fa56615c41e7e16610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e2f1a50bc02a6e484ed225645b0de0"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:af9e2f1a50bc02a6e484ed225645b0de0"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; MinOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#af9e2f1a50bc02a6e484ed225645b0de0">ROOT::Math::operator-</a> (const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:af9e2f1a50bc02a6e484ed225645b0de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bef96dca6b29dc67cf25a183a06af0d"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a6bef96dca6b29dc67cf25a183a06af0d"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; MinOp&lt; T &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, Expr&lt; B, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a6bef96dca6b29dc67cf25a183a06af0d">ROOT::Math::operator-</a> (const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const Expr&lt; B, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a6bef96dca6b29dc67cf25a183a06af0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdeef752c55a3c91a41e208aad348c7"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:gaccdeef752c55a3c91a41e208aad348c7"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyR&lt; MinOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, Constant&lt; A &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#gaccdeef752c55a3c91a41e208aad348c7">ROOT::Math::operator-</a> (const SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="memdesc:gaccdeef752c55a3c91a41e208aad348c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of a scalar and a matrix (element wise) B(i,j) = A(i,j) - s returning a matrix expression.  <a href="group__MatrixFunctions.html#gaccdeef752c55a3c91a41e208aad348c7">More...</a><br /></td></tr>
<tr class="separator:gaccdeef752c55a3c91a41e208aad348c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37c50f1854d8e8ca4f0fcd0ec0a9636"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:gaa37c50f1854d8e8ca4f0fcd0ec0a9636"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyL&lt; MinOp&lt; T &gt;, Constant&lt; A &gt;, SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#gaa37c50f1854d8e8ca4f0fcd0ec0a9636">ROOT::Math::operator-</a> (const A &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa37c50f1854d8e8ca4f0fcd0ec0a9636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of a scalar and a matrix (element wise) B(i,j) = s - A(i,j) returning a matrix expression.  <a href="group__MatrixFunctions.html#gaa37c50f1854d8e8ca4f0fcd0ec0a9636">More...</a><br /></td></tr>
<tr class="separator:gaa37c50f1854d8e8ca4f0fcd0ec0a9636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bfca628039356ce838ac260064ad05"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:a08bfca628039356ce838ac260064ad05"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyR&lt; MinOp&lt; T &gt;, Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, Constant&lt; A &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a08bfca628039356ce838ac260064ad05">ROOT::Math::operator-</a> (const Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="separator:a08bfca628039356ce838ac260064ad05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc9407ae2e11891b720bfafd51c61ff"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:abbc9407ae2e11891b720bfafd51c61ff"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyL&lt; MinOp&lt; T &gt;, Constant&lt; A &gt;, Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#abbc9407ae2e11891b720bfafd51c61ff">ROOT::Math::operator-</a> (const A &amp;lhs, const Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:abbc9407ae2e11891b720bfafd51c61ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25254814504fa7934ebc1f69f6bf8762"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int D&gt; </td></tr>
<tr class="memitem:ga25254814504fa7934ebc1f69f6bf8762"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; DivOp&lt; T &gt;, SVector&lt; T, D &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#ga25254814504fa7934ebc1f69f6bf8762">ROOT::Math::operator/</a> (const SVector&lt; T, D &gt; &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga25254814504fa7934ebc1f69f6bf8762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element by element division of vectors of the same dimension: v3(i) = v1(i)/v2(i) returning a vector expression.  <a href="group__VectFunction.html#ga25254814504fa7934ebc1f69f6bf8762">More...</a><br /></td></tr>
<tr class="separator:ga25254814504fa7934ebc1f69f6bf8762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb39844caa9ae85da776965b2cdf0da6"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:adb39844caa9ae85da776965b2cdf0da6"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; DivOp&lt; T &gt;, VecExpr&lt; A, T, D &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#adb39844caa9ae85da776965b2cdf0da6">ROOT::Math::operator/</a> (const VecExpr&lt; A, T, D &gt; &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:adb39844caa9ae85da776965b2cdf0da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf8f03e70764878b90e0171e729e597"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:acdf8f03e70764878b90e0171e729e597"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; DivOp&lt; T &gt;, SVector&lt; T, D &gt;, VecExpr&lt; A, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#acdf8f03e70764878b90e0171e729e597">ROOT::Math::operator/</a> (const SVector&lt; T, D &gt; &amp;lhs, const VecExpr&lt; A, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:acdf8f03e70764878b90e0171e729e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ee8e0b89f2b7382a2c93e964ed9560"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:a67ee8e0b89f2b7382a2c93e964ed9560"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOp&lt; DivOp&lt; T &gt;, VecExpr&lt; A, T, D &gt;, VecExpr&lt; B, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a67ee8e0b89f2b7382a2c93e964ed9560">ROOT::Math::operator/</a> (const VecExpr&lt; A, T, D &gt; &amp;lhs, const VecExpr&lt; B, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:a67ee8e0b89f2b7382a2c93e964ed9560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f4e8e286e91d3a74b98d6c4e3f5533"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:ga18f4e8e286e91d3a74b98d6c4e3f5533"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyR&lt; DivOp&lt; T &gt;, SVector&lt; T, D &gt;, Constant&lt; A &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#ga18f4e8e286e91d3a74b98d6c4e3f5533">ROOT::Math::operator/</a> (const SVector&lt; T, D &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="memdesc:ga18f4e8e286e91d3a74b98d6c4e3f5533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of the vector element by a scalar value: v2(i) = v1(i)/a returning a vector expression.  <a href="group__VectFunction.html#ga18f4e8e286e91d3a74b98d6c4e3f5533">More...</a><br /></td></tr>
<tr class="separator:ga18f4e8e286e91d3a74b98d6c4e3f5533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga976c5196dbfed512caebc160cf272f3a"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:ga976c5196dbfed512caebc160cf272f3a"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyL&lt; DivOp&lt; T &gt;, Constant&lt; A &gt;, SVector&lt; T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VectFunction.html#ga976c5196dbfed512caebc160cf272f3a">ROOT::Math::operator/</a> (const A &amp;lhs, const SVector&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga976c5196dbfed512caebc160cf272f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of a scalar value by the vector element: v2(i) = a/v1(i) returning a vector expression.  <a href="group__VectFunction.html#ga976c5196dbfed512caebc160cf272f3a">More...</a><br /></td></tr>
<tr class="separator:ga976c5196dbfed512caebc160cf272f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a516edc5d6d23c92656fde52d7633e"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:ab2a516edc5d6d23c92656fde52d7633e"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyR&lt; DivOp&lt; T &gt;, VecExpr&lt; B, T, D &gt;, Constant&lt; A &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#ab2a516edc5d6d23c92656fde52d7633e">ROOT::Math::operator/</a> (const VecExpr&lt; B, T, D &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="separator:ab2a516edc5d6d23c92656fde52d7633e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb11aa5d68d0772b885dfc766724c31"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D&gt; </td></tr>
<tr class="memitem:aedb11aa5d68d0772b885dfc766724c31"><td class="memTemplItemLeft" align="right" valign="top">VecExpr&lt; BinaryOpCopyL&lt; DivOp&lt; T &gt;, Constant&lt; A &gt;, VecExpr&lt; B, T, D &gt;, T &gt;, T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#aedb11aa5d68d0772b885dfc766724c31">ROOT::Math::operator/</a> (const A &amp;lhs, const VecExpr&lt; B, T, D &gt; &amp;rhs)</td></tr>
<tr class="separator:aedb11aa5d68d0772b885dfc766724c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12db4fc788f46f6a769af2dd6920bdfe"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:ga12db4fc788f46f6a769af2dd6920bdfe"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyR&lt; DivOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, Constant&lt; A &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#ga12db4fc788f46f6a769af2dd6920bdfe">ROOT::Math::operator/</a> (const SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="memdesc:ga12db4fc788f46f6a769af2dd6920bdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division (element wise) of a matrix and a scalar, B(i,j) = A(i,j) / s returning a matrix expression.  <a href="group__MatrixFunctions.html#ga12db4fc788f46f6a769af2dd6920bdfe">More...</a><br /></td></tr>
<tr class="separator:ga12db4fc788f46f6a769af2dd6920bdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd6040635b7c428c45864f17c078d21"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:ga7bd6040635b7c428c45864f17c078d21"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyL&lt; DivOp&lt; T &gt;, Constant&lt; A &gt;, SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#ga7bd6040635b7c428c45864f17c078d21">ROOT::Math::operator/</a> (const A &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7bd6040635b7c428c45864f17c078d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division (element wise) of a matrix and a scalar, B(i,j) = s / A(i,j) returning a matrix expression.  <a href="group__MatrixFunctions.html#ga7bd6040635b7c428c45864f17c078d21">More...</a><br /></td></tr>
<tr class="separator:ga7bd6040635b7c428c45864f17c078d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0ba0b07d594cf76e23eb23ac46062c"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:a2f0ba0b07d594cf76e23eb23ac46062c"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyR&lt; DivOp&lt; T &gt;, Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, Constant&lt; A &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a2f0ba0b07d594cf76e23eb23ac46062c">ROOT::Math::operator/</a> (const Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;lhs, const A &amp;rhs)</td></tr>
<tr class="separator:a2f0ba0b07d594cf76e23eb23ac46062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf39da9b648014f3b859d03a6cc15e46"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R &gt; </td></tr>
<tr class="memitem:aaf39da9b648014f3b859d03a6cc15e46"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOpCopyL&lt; DivOp&lt; T &gt;, Constant&lt; A &gt;, Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;, T &gt;, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#aaf39da9b648014f3b859d03a6cc15e46">ROOT::Math::operator/</a> (const A &amp;lhs, const Expr&lt; B, T, D, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:aaf39da9b648014f3b859d03a6cc15e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae6247156f904c9f578b1aab4421de3"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:ga8ae6247156f904c9f578b1aab4421de3"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; MulOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions.html#ga8ae6247156f904c9f578b1aab4421de3">ROOT::Math::Times</a> (const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8ae6247156f904c9f578b1aab4421de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element by element matrix multiplication C(i,j) = A(i,j)*B(i,j) returning a matrix expression.  <a href="group__MatrixFunctions.html#ga8ae6247156f904c9f578b1aab4421de3">More...</a><br /></td></tr>
<tr class="separator:ga8ae6247156f904c9f578b1aab4421de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad273d51641fb8e39d5c71df35126bf6"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:aad273d51641fb8e39d5c71df35126bf6"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; MulOp&lt; T &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#aad273d51641fb8e39d5c71df35126bf6">ROOT::Math::Times</a> (const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:aad273d51641fb8e39d5c71df35126bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9b875d831df248c005cbca499cfa55"><td class="memTemplParams" colspan="2">template&lt;class A , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a3f9b875d831df248c005cbca499cfa55"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; MulOp&lt; T &gt;, SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a3f9b875d831df248c005cbca499cfa55">ROOT::Math::Times</a> (const SMatrix&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a3f9b875d831df248c005cbca499cfa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70aeb1ed5d540fdf53c03893437e112f"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class T , unsigned int D, unsigned int D2, class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a70aeb1ed5d540fdf53c03893437e112f"><td class="memTemplItemLeft" align="right" valign="top">Expr&lt; BinaryOp&lt; MulOp&lt; T &gt;, Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt;, Expr&lt; B, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;, T &gt;, T, D, D2, typename AddPolicy&lt; T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a>, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt;::RepType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1Math.html#a70aeb1ed5d540fdf53c03893437e112f">ROOT::Math::Times</a> (const Expr&lt; A, T, D, D2, <a class="el" href="sha1_8inl.html#a2628f8af7bf67ca052200537279f855a">R1</a> &gt; &amp;lhs, const Expr&lt; B, T, D, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a70aeb1ed5d540fdf53c03893437e112f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:10:01 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
