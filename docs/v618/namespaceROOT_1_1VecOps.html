<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: ROOT::VecOps Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceROOT.html">ROOT</a></li><li class="navelem"><a class="el" href="namespaceROOT_1_1VecOps.html">VecOps</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ROOT::VecOps Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
A "std::vector"-like collection of values implementing handy operation to analyse them  <a href="classROOT_1_1VecOps_1_1RVec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0986bfeefd61607a6f0aced1b37a5aa1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0986bfeefd61607a6f0aced1b37a5aa1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a0986bfeefd61607a6f0aced1b37a5aa1">All</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>) -&gt; decltype(<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>[0]==false)</td></tr>
<tr class="memdesc:a0986bfeefd61607a6f0aced1b37a5aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of the elements equate to true, return false otherwise.  <a href="#a0986bfeefd61607a6f0aced1b37a5aa1">More...</a><br /></td></tr>
<tr class="separator:a0986bfeefd61607a6f0aced1b37a5aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67150bb64ec97ec4968d655a515487c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad67150bb64ec97ec4968d655a515487c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#ad67150bb64ec97ec4968d655a515487c">Any</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>) -&gt; decltype(<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>[0]==true)</td></tr>
<tr class="memdesc:ad67150bb64ec97ec4968d655a515487c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of the elements equates to true, return false otherwise.  <a href="#ad67150bb64ec97ec4968d655a515487c">More...</a><br /></td></tr>
<tr class="separator:ad67150bb64ec97ec4968d655a515487c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb36f30def53183079a0b7c1e6fb2d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbb36f30def53183079a0b7c1e6fb2d1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#afbb36f30def53183079a0b7c1e6fb2d1">ArgMax</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:afbb36f30def53183079a0b7c1e6fb2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the greatest element of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> In case of multiple occurrences of the maximum values, the index corresponding to the first occurrence is returned.  <a href="#afbb36f30def53183079a0b7c1e6fb2d1">More...</a><br /></td></tr>
<tr class="separator:afbb36f30def53183079a0b7c1e6fb2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3afbcfaa0b0e38a951297ba74d6112"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed3afbcfaa0b0e38a951297ba74d6112"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#aed3afbcfaa0b0e38a951297ba74d6112">ArgMin</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:aed3afbcfaa0b0e38a951297ba74d6112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the smallest element of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> In case of multiple occurrences of the minimum values, the index corresponding to the first occurrence is returned.  <a href="#aed3afbcfaa0b0e38a951297ba74d6112">More...</a><br /></td></tr>
<tr class="separator:aed3afbcfaa0b0e38a951297ba74d6112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcd060b97f6c82621ba0d8f376ad195"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7dcd060b97f6c82621ba0d8f376ad195"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;::size_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a7dcd060b97f6c82621ba0d8f376ad195">Argsort</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a7dcd060b97f6c82621ba0d8f376ad195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of indices that sort the input <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>.  <a href="#a7dcd060b97f6c82621ba0d8f376ad195">More...</a><br /></td></tr>
<tr class="separator:a7dcd060b97f6c82621ba0d8f376ad195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1d00c2ccb769cc48c6813dbeb132db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a6d1d00c2ccb769cc48c6813dbeb132db">Combinations</a> (const std::size_t size1, const std::size_t size2)</td></tr>
<tr class="memdesc:a6d1d00c2ccb769cc48c6813dbeb132db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the indices that represent all combinations of the elements of two RVecs.  <a href="#a6d1d00c2ccb769cc48c6813dbeb132db">More...</a><br /></td></tr>
<tr class="separator:a6d1d00c2ccb769cc48c6813dbeb132db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2df109b651e06a9dc60a9d88ded7a8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9e2df109b651e06a9dc60a9d88ded7a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="md5_8inl.html#ac16509a75e3d3fc46b9df1726be486ec">T1</a> &gt;::size_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a9e2df109b651e06a9dc60a9d88ded7a8">Combinations</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="md5_8inl.html#ac16509a75e3d3fc46b9df1726be486ec">T1</a> &gt; &amp;v1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="md5_8inl.html#a259c2993ee45e06a4ea8150451a7a70e">T2</a> &gt; &amp;v2)</td></tr>
<tr class="memdesc:a9e2df109b651e06a9dc60a9d88ded7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the indices that represent all combinations of the elements of two RVecs.  <a href="#a9e2df109b651e06a9dc60a9d88ded7a8">More...</a><br /></td></tr>
<tr class="separator:a9e2df109b651e06a9dc60a9d88ded7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbf82257156b750c7b9bdd39a53ee33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbbf82257156b750c7b9bdd39a53ee33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;::size_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#abbbf82257156b750c7b9bdd39a53ee33">Combinations</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, const typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;::size_type <a class="el" href="TGX11_8cxx.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:abbbf82257156b750c7b9bdd39a53ee33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the indices that represent all unique combinations of the elements of a given <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>.  <a href="#abbbf82257156b750c7b9bdd39a53ee33">More...</a><br /></td></tr>
<tr class="separator:abbbf82257156b750c7b9bdd39a53ee33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e298525f7a7c55b510983e3f6ffb833"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename Common_t  = typename std::common_type&lt;T0, T1&gt;::type&gt; </td></tr>
<tr class="memitem:a8e298525f7a7c55b510983e3f6ffb833"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; Common_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a8e298525f7a7c55b510983e3f6ffb833">Concatenate</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T0 &gt; &amp;v0, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="md5_8inl.html#ac16509a75e3d3fc46b9df1726be486ec">T1</a> &gt; &amp;v1)</td></tr>
<tr class="memdesc:a8e298525f7a7c55b510983e3f6ffb833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concatenation of two RVecs.  <a href="#a8e298525f7a7c55b510983e3f6ffb833">More...</a><br /></td></tr>
<tr class="separator:a8e298525f7a7c55b510983e3f6ffb833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8ddd546ccd87fe25dc7626f9d8b67d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args_t&gt; </td></tr>
<tr class="memitem:a0d8ddd546ccd87fe25dc7626f9d8b67d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a0d8ddd546ccd87fe25dc7626f9d8b67d">Construct</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; Args_t &gt; &amp;... args)</td></tr>
<tr class="memdesc:a0d8ddd546ccd87fe25dc7626f9d8b67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of objects starting from RVecs of input to their constructors.  <a href="#a0d8ddd546ccd87fe25dc7626f9d8b67d">More...</a><br /></td></tr>
<tr class="separator:a0d8ddd546ccd87fe25dc7626f9d8b67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0f2e54d5e1b3a186cf06c9ebd9bac1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d0f2e54d5e1b3a186cf06c9ebd9bac1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a9d0f2e54d5e1b3a186cf06c9ebd9bac1">DeltaPhi</a> (T v1, T v2, const T <a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>=<a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>)</td></tr>
<tr class="memdesc:a9d0f2e54d5e1b3a186cf06c9ebd9bac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle difference \(\Delta \phi\) of two scalars.  <a href="#a9d0f2e54d5e1b3a186cf06c9ebd9bac1">More...</a><br /></td></tr>
<tr class="separator:a9d0f2e54d5e1b3a186cf06c9ebd9bac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f546bd6bdeb375538824414804f53e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f546bd6bdeb375538824414804f53e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a4f546bd6bdeb375538824414804f53e2">DeltaPhi</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v2, const T <a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>=<a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>)</td></tr>
<tr class="memdesc:a4f546bd6bdeb375538824414804f53e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle difference \(\Delta \phi\) in radians of two vectors.  <a href="#a4f546bd6bdeb375538824414804f53e2">More...</a><br /></td></tr>
<tr class="separator:a4f546bd6bdeb375538824414804f53e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f74fa1623a1e24d3473324e32e78180"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f74fa1623a1e24d3473324e32e78180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a6f74fa1623a1e24d3473324e32e78180">DeltaPhi</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v1, T v2, const T <a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>=<a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>)</td></tr>
<tr class="memdesc:a6f74fa1623a1e24d3473324e32e78180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle difference \(\Delta \phi\) in radians of a vector and a scalar.  <a href="#a6f74fa1623a1e24d3473324e32e78180">More...</a><br /></td></tr>
<tr class="separator:a6f74fa1623a1e24d3473324e32e78180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cd6a8197b7fc366102654678215c0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87cd6a8197b7fc366102654678215c0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a87cd6a8197b7fc366102654678215c0c">DeltaPhi</a> (T v1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v2, const T <a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>=<a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>)</td></tr>
<tr class="memdesc:a87cd6a8197b7fc366102654678215c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle difference \(\Delta \phi\) in radians of a scalar and a vector.  <a href="#a87cd6a8197b7fc366102654678215c0c">More...</a><br /></td></tr>
<tr class="separator:a87cd6a8197b7fc366102654678215c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2c2b2065563d47d79a07e2335095a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae2c2b2065563d47d79a07e2335095a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#aae2c2b2065563d47d79a07e2335095a2">DeltaR</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;eta1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;eta2, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;phi1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;phi2, const T <a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>=<a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>)</td></tr>
<tr class="memdesc:aae2c2b2065563d47d79a07e2335095a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distance on the \(\eta\)- \(\phi\) plane ( \(\Delta R\)) from the collections eta1, eta2, phi1 and phi2.  <a href="#aae2c2b2065563d47d79a07e2335095a2">More...</a><br /></td></tr>
<tr class="separator:aae2c2b2065563d47d79a07e2335095a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb23cd678b4fbcf50e045aab12bd348"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:affb23cd678b4fbcf50e045aab12bd348"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#affb23cd678b4fbcf50e045aab12bd348">DeltaR</a> (T eta1, T eta2, T phi1, T phi2, const T <a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>=<a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>)</td></tr>
<tr class="memdesc:affb23cd678b4fbcf50e045aab12bd348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distance on the \(\eta\)- \(\phi\) plane ( \(\Delta R\)) from the scalars eta1, eta2, phi1 and phi2.  <a href="#affb23cd678b4fbcf50e045aab12bd348">More...</a><br /></td></tr>
<tr class="separator:affb23cd678b4fbcf50e045aab12bd348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d2995da6b2b2c53637a63489ea39d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6d2995da6b2b2c53637a63489ea39d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#ac6d2995da6b2b2c53637a63489ea39d9">DeltaR2</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;eta1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;eta2, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;phi1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;phi2, const T <a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>=<a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>)</td></tr>
<tr class="memdesc:ac6d2995da6b2b2c53637a63489ea39d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the distance on the \(\eta\)- \(\phi\) plane ( \(\Delta R\)) from the collections eta1, eta2, phi1 and phi2.  <a href="#ac6d2995da6b2b2c53637a63489ea39d9">More...</a><br /></td></tr>
<tr class="separator:ac6d2995da6b2b2c53637a63489ea39d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa714e75fcefe12330341db69c31d9772"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:aa714e75fcefe12330341db69c31d9772"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#aa714e75fcefe12330341db69c31d9772">Dot</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v0, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; V &gt; &amp;v1) -&gt; decltype(v0[0] *v1[0])</td></tr>
<tr class="memdesc:aa714e75fcefe12330341db69c31d9772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product.  <a href="#aa714e75fcefe12330341db69c31d9772">More...</a><br /></td></tr>
<tr class="separator:aa714e75fcefe12330341db69c31d9772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6951c4389557af80294358c393ba58e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a6951c4389557af80294358c393ba58e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a6951c4389557af80294358c393ba58e4">Filter</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, <a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> &amp;&amp;<a class="el" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>)</td></tr>
<tr class="memdesc:a6951c4389557af80294358c393ba58e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new collection with the elements passing the filter expressed by the predicate.  <a href="#a6951c4389557af80294358c393ba58e4">More...</a><br /></td></tr>
<tr class="separator:a6951c4389557af80294358c393ba58e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e903e9bed20c05d7a70afb393355643"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e903e9bed20c05d7a70afb393355643"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a2e903e9bed20c05d7a70afb393355643">Intersect</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v2, bool v2_is_sorted=false)</td></tr>
<tr class="memdesc:a2e903e9bed20c05d7a70afb393355643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the intersection of elements of two RVecs.  <a href="#a2e903e9bed20c05d7a70afb393355643">More...</a><br /></td></tr>
<tr class="separator:a2e903e9bed20c05d7a70afb393355643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c531eae910edad48bbf7319cc6d7e58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c531eae910edad48bbf7319cc6d7e58"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a2c531eae910edad48bbf7319cc6d7e58">InvariantMass</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="entrylistblock__figure1_8C.html#ac0ca150b0e000602a104bc1ca56005e3">pt</a>, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;eta, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;phi, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;mass)</td></tr>
<tr class="memdesc:a2c531eae910edad48bbf7319cc6d7e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the invariant mass of multiple particles given the collections of the quantities transverse momentum (pt), rapidity (eta), azimuth (phi) and mass.  <a href="#a2c531eae910edad48bbf7319cc6d7e58">More...</a><br /></td></tr>
<tr class="separator:a2c531eae910edad48bbf7319cc6d7e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07da335066e6edb3849be1b170186bab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07da335066e6edb3849be1b170186bab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a07da335066e6edb3849be1b170186bab">InvariantMasses</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;pt1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;eta1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;phi1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;mass1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;pt2, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;eta2, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;phi2, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;mass2)</td></tr>
<tr class="memdesc:a07da335066e6edb3849be1b170186bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the invariant mass of two particles given the collections of the quantities transverse momentum (pt), rapidity (eta), azimuth (phi) and mass.  <a href="#a07da335066e6edb3849be1b170186bab">More...</a><br /></td></tr>
<tr class="separator:a07da335066e6edb3849be1b170186bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aadd40d55ae7f01f3715903551d760"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a27aadd40d55ae7f01f3715903551d760"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a27aadd40d55ae7f01f3715903551d760">Map</a> (Args &amp;&amp;... args) -&gt; decltype(<a class="el" href="namespaceROOT_1_1Detail_1_1VecOps.html#ac5bcef1fdf51a657fb9886a89c741627">ROOT::Detail::VecOps::MapFromTuple</a>(std::forward_as_tuple(args...), std::make_index_sequence&lt; sizeof...(args) - 1 &gt;()))</td></tr>
<tr class="memdesc:a27aadd40d55ae7f01f3715903551d760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new collection applying a callable to the elements of the input collection.  <a href="#a27aadd40d55ae7f01f3715903551d760">More...</a><br /></td></tr>
<tr class="separator:a27aadd40d55ae7f01f3715903551d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014f2c5ed975748eef051cf7df955ba5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a014f2c5ed975748eef051cf7df955ba5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a014f2c5ed975748eef051cf7df955ba5">Max</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a014f2c5ed975748eef051cf7df955ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the greatest element of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>.  <a href="#a014f2c5ed975748eef051cf7df955ba5">More...</a><br /></td></tr>
<tr class="separator:a014f2c5ed975748eef051cf7df955ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72261407fa7c77d7066a063cd55dfdb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72261407fa7c77d7066a063cd55dfdb2"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a72261407fa7c77d7066a063cd55dfdb2">Mean</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a72261407fa7c77d7066a063cd55dfdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean of the elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>.  <a href="#a72261407fa7c77d7066a063cd55dfdb2">More...</a><br /></td></tr>
<tr class="separator:a72261407fa7c77d7066a063cd55dfdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9fe1cc9c0975ee89f84b7e67fb9d4e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa9fe1cc9c0975ee89f84b7e67fb9d4e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#aaa9fe1cc9c0975ee89f84b7e67fb9d4e">Min</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:aaa9fe1cc9c0975ee89f84b7e67fb9d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the smallest element of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>.  <a href="#aaa9fe1cc9c0975ee89f84b7e67fb9d4e">More...</a><br /></td></tr>
<tr class="separator:aaa9fe1cc9c0975ee89f84b7e67fb9d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0d21c900adb578bf49a3063733cb1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef0d21c900adb578bf49a3063733cb1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;::size_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#aef0d21c900adb578bf49a3063733cb1a">Nonzero</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:aef0d21c900adb578bf49a3063733cb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the indices of the elements which are not zero.  <a href="#aef0d21c900adb578bf49a3063733cb1a">More...</a><br /></td></tr>
<tr class="separator:aef0d21c900adb578bf49a3063733cb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015fbd3ba377ff20a90797b15696a09d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a015fbd3ba377ff20a90797b15696a09d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a015fbd3ba377ff20a90797b15696a09d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a015fbd3ba377ff20a90797b15696a09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> at the prompt:  <a href="#a015fbd3ba377ff20a90797b15696a09d">More...</a><br /></td></tr>
<tr class="separator:a015fbd3ba377ff20a90797b15696a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7226744d506fbf6e2776beeb460adc05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7226744d506fbf6e2776beeb460adc05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a7226744d506fbf6e2776beeb460adc05">Reverse</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a7226744d506fbf6e2776beeb460adc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return copy of reversed vector.  <a href="#a7226744d506fbf6e2776beeb460adc05">More...</a><br /></td></tr>
<tr class="separator:a7226744d506fbf6e2776beeb460adc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77262ab810a179ba1c555648e8d5909b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77262ab810a179ba1c555648e8d5909b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a77262ab810a179ba1c555648e8d5909b">Sort</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a77262ab810a179ba1c555648e8d5909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return copy of <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> with elements sorted in ascending order.  <a href="#a77262ab810a179ba1c555648e8d5909b">More...</a><br /></td></tr>
<tr class="separator:a77262ab810a179ba1c555648e8d5909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882439c2ff958157d2990b52dd76f599"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare &gt; </td></tr>
<tr class="memitem:a882439c2ff958157d2990b52dd76f599"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a882439c2ff958157d2990b52dd76f599">Sort</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, <a class="el" href="TVectorT_8cxx.html#ae6baa722a687905f9e3a08a0b95b2cf4">Compare</a> &amp;&amp;<a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>)</td></tr>
<tr class="memdesc:a882439c2ff958157d2990b52dd76f599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return copy of <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> with elements sorted based on a comparison operator.  <a href="#a882439c2ff958157d2990b52dd76f599">More...</a><br /></td></tr>
<tr class="separator:a882439c2ff958157d2990b52dd76f599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51a36ad424a7806508dfb4eafdcbb99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad51a36ad424a7806508dfb4eafdcbb99"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#ad51a36ad424a7806508dfb4eafdcbb99">StdDev</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:ad51a36ad424a7806508dfb4eafdcbb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the standard deviation of the elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>.  <a href="#ad51a36ad424a7806508dfb4eafdcbb99">More...</a><br /></td></tr>
<tr class="separator:ad51a36ad424a7806508dfb4eafdcbb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1638f2982ee60712f1f02e31d3e178ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1638f2982ee60712f1f02e31d3e178ad"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a1638f2982ee60712f1f02e31d3e178ad">Sum</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a1638f2982ee60712f1f02e31d3e178ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>.  <a href="#a1638f2982ee60712f1f02e31d3e178ad">More...</a><br /></td></tr>
<tr class="separator:a1638f2982ee60712f1f02e31d3e178ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e16ecd5df9720e7e2009ab1d973220d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e16ecd5df9720e7e2009ab1d973220d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a7e16ecd5df9720e7e2009ab1d973220d">swap</a> (<a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;lhs, <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a7e16ecd5df9720e7e2009ab1d973220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be88aa9a0a886abe2fcbbfc759be960"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3be88aa9a0a886abe2fcbbfc759be960"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a3be88aa9a0a886abe2fcbbfc759be960">Take</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;::size_type &gt; &amp;i)</td></tr>
<tr class="memdesc:a3be88aa9a0a886abe2fcbbfc759be960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elements of a vector at given indices.  <a href="#a3be88aa9a0a886abe2fcbbfc759be960">More...</a><br /></td></tr>
<tr class="separator:a3be88aa9a0a886abe2fcbbfc759be960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d5f310c958498f5248346478f5297a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46d5f310c958498f5248346478f5297a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a46d5f310c958498f5248346478f5297a">Take</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, const int <a class="el" href="TGX11_8cxx.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a46d5f310c958498f5248346478f5297a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return first or last <code>n</code> elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>.  <a href="#a46d5f310c958498f5248346478f5297a">More...</a><br /></td></tr>
<tr class="separator:a46d5f310c958498f5248346478f5297a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fbd6b649ecd2ee62c3d8f30e9cece1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9fbd6b649ecd2ee62c3d8f30e9cece1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#af9fbd6b649ecd2ee62c3d8f30e9cece1">Var</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:af9fbd6b649ecd2ee62c3d8f30e9cece1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the variance of the elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>.  <a href="#af9fbd6b649ecd2ee62c3d8f30e9cece1">More...</a><br /></td></tr>
<tr class="separator:af9fbd6b649ecd2ee62c3d8f30e9cece1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ec4b9cb652a124c4eae0879bbc44c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1ec4b9cb652a124c4eae0879bbc44c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#ad1ec4b9cb652a124c4eae0879bbc44c1">Where</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; int &gt; &amp;<a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:ad1ec4b9cb652a124c4eae0879bbc44c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elements of v1 if the condition c is true and v2 if the condition c is false.  <a href="#ad1ec4b9cb652a124c4eae0879bbc44c1">More...</a><br /></td></tr>
<tr class="separator:ad1ec4b9cb652a124c4eae0879bbc44c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fef176de7e03730c5f97cc62c9569ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4fef176de7e03730c5f97cc62c9569ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a4fef176de7e03730c5f97cc62c9569ec">Where</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; int &gt; &amp;<a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v1, T v2)</td></tr>
<tr class="memdesc:a4fef176de7e03730c5f97cc62c9569ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elements of v1 if the condition c is true and sets the value v2 if the condition c is false.  <a href="#a4fef176de7e03730c5f97cc62c9569ec">More...</a><br /></td></tr>
<tr class="separator:a4fef176de7e03730c5f97cc62c9569ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ce8ff6d82ed3d2cfce9dafceba7139"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3ce8ff6d82ed3d2cfce9dafceba7139"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#ad3ce8ff6d82ed3d2cfce9dafceba7139">Where</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; int &gt; &amp;<a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>, T v1, const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:ad3ce8ff6d82ed3d2cfce9dafceba7139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elements of v2 if the condition c is false and sets the value v1 if the condition c is true.  <a href="#ad3ce8ff6d82ed3d2cfce9dafceba7139">More...</a><br /></td></tr>
<tr class="separator:ad3ce8ff6d82ed3d2cfce9dafceba7139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6390cb179366cc24afceafed86f748"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e6390cb179366cc24afceafed86f748"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROOT_1_1VecOps.html#a4e6390cb179366cc24afceafed86f748">Where</a> (const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; int &gt; &amp;<a class="el" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>, T v1, T v2)</td></tr>
<tr class="memdesc:a4e6390cb179366cc24afceafed86f748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with the value v2 if the condition c is false and sets the value v1 if the condition c is true.  <a href="#a4e6390cb179366cc24afceafed86f748">More...</a><br /></td></tr>
<tr class="separator:a4e6390cb179366cc24afceafed86f748"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0986bfeefd61607a6f0aced1b37a5aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0986bfeefd61607a6f0aced1b37a5aa1">&#9670;&nbsp;</a></span>All()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ROOT::VecOps::All </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>[0] == false)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if all of the elements equate to true, return false otherwise. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;int&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {0, 1, 0};</div><div class="line"><span class="keyword">auto</span> allTrue = <a class="code" href="namespaceROOT_1_1VecOps.html#a0986bfeefd61607a6f0aced1b37a5aa1">All</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">allTrue</div><div class="line"><span class="comment">// (bool) false</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00978">978</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="ad67150bb64ec97ec4968d655a515487c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67150bb64ec97ec4968d655a515487c">&#9670;&nbsp;</a></span>Any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ROOT::VecOps::Any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>[0] == true)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if any of the elements equates to true, return false otherwise. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;int&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {0, 1, 0};</div><div class="line"><span class="keyword">auto</span> anyTrue = <a class="code" href="namespaceROOT_1_1VecOps.html#ad67150bb64ec97ec4968d655a515487c">Any</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">anyTrue</div><div class="line"><span class="comment">// (bool) true</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00959">959</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="afbb36f30def53183079a0b7c1e6fb2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb36f30def53183079a0b7c1e6fb2d1">&#9670;&nbsp;</a></span>ArgMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ROOT::VecOps::ArgMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the greatest element of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> In case of multiple occurrences of the maximum values, the index corresponding to the first occurrence is returned. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1.f, 2.f, 4.f};</div><div class="line"><span class="keyword">auto</span> v_argmax = <a class="code" href="namespaceROOT_1_1VecOps.html#afbb36f30def53183079a0b7c1e6fb2d1">ArgMax</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">v_argmax</div><div class="line"><span class="comment">// (int) 2</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00824">824</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="aed3afbcfaa0b0e38a951297ba74d6112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3afbcfaa0b0e38a951297ba74d6112">&#9670;&nbsp;</a></span>ArgMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ROOT::VecOps::ArgMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the smallest element of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> In case of multiple occurrences of the minimum values, the index corresponding to the first occurrence is returned. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1.f, 2.f, 4.f};</div><div class="line"><span class="keyword">auto</span> v_argmin = <a class="code" href="namespaceROOT_1_1VecOps.html#aed3afbcfaa0b0e38a951297ba74d6112">ArgMin</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">v_argmin</div><div class="line"><span class="comment">// (int) 0</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00842">842</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a7dcd060b97f6c82621ba0d8f376ad195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcd060b97f6c82621ba0d8f376ad195">&#9670;&nbsp;</a></span>Argsort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt;::size_type&gt; ROOT::VecOps::Argsort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of indices that sort the input <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {2., 3., 1.};</div><div class="line"><span class="keyword">auto</span> sortIndices = <a class="code" href="namespaceROOT_1_1VecOps.html#a7dcd060b97f6c82621ba0d8f376ad195">Argsort</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">sortIndices</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;unsigned long&gt; &amp;) { 2, 0, 1 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01003">1003</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a6d1d00c2ccb769cc48c6813dbeb132db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1d00c2ccb769cc48c6813dbeb132db">&#9670;&nbsp;</a></span>Combinations() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;<a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;std::size_t&gt; &gt; ROOT::VecOps::Combinations </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>size2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the indices that represent all combinations of the elements of two RVecs. </p>
<p>The type of the return value is an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of two RVecs containing indices.</p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><span class="keyword">auto</span> comb_idx = <a class="code" href="namespaceROOT_1_1VecOps.html#a6d1d00c2ccb769cc48c6813dbeb132db">Combinations</a>(3, 2);</div><div class="line">comb_idx</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;ROOT::VecOps::RVec&lt;ROOT::VecOps::RVec&lt;double&gt;::size_type&gt; &gt;) { { 0, 0, 1, 1, 2, 2 }, { 0, 1, 0, 1, 0, 1 } }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01146">1146</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a9e2df109b651e06a9dc60a9d88ded7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2df109b651e06a9dc60a9d88ded7a8">&#9670;&nbsp;</a></span>Combinations() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;<a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;<a class="el" href="md5_8inl.html#ac16509a75e3d3fc46b9df1726be486ec">T1</a>&gt;::size_type&gt; &gt; ROOT::VecOps::Combinations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="md5_8inl.html#ac16509a75e3d3fc46b9df1726be486ec">T1</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="md5_8inl.html#a259c2993ee45e06a4ea8150451a7a70e">T2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the indices that represent all combinations of the elements of two RVecs. </p>
<p>The type of the return value is an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of two RVecs containing indices.</p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> v1 {1., 2., 3.};</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> v2 {-4., -5.};</div><div class="line"><span class="keyword">auto</span> comb_idx = <a class="code" href="namespaceROOT_1_1VecOps.html#a6d1d00c2ccb769cc48c6813dbeb132db">Combinations</a>(v1, v2);</div><div class="line">comb_idx</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;ROOT::VecOps::RVec&lt;ROOT::VecOps::RVec&lt;double&gt;::size_type&gt; &gt;) { { 0, 0, 1, 1, 2, 2 }, { 0, 1,</span></div><div class="line">0, 1, 0, 1 } }</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01179">1179</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="abbbf82257156b750c7b9bdd39a53ee33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbf82257156b750c7b9bdd39a53ee33">&#9670;&nbsp;</a></span>Combinations() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;<a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt;::size_type&gt; &gt; ROOT::VecOps::Combinations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;::size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the indices that represent all unique combinations of the elements of a given <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1., 2., 3., 4.};</div><div class="line"><span class="keyword">auto</span> v_1 = <a class="code" href="namespaceROOT_1_1VecOps.html#a6d1d00c2ccb769cc48c6813dbeb132db">Combinations</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, 1);</div><div class="line">v_1</div><div class="line">(<a class="code" href="classROOT_1_1VecOps_1_1RVec.html">ROOT::VecOps::RVec</a>&lt;<a class="code" href="classROOT_1_1VecOps_1_1RVec.html">ROOT::VecOps::RVec</a>&lt;<a class="code" href="classROOT_1_1VecOps_1_1RVec.html#acdf49282db08ebce4b517e880513d18b">ROOT::VecOps::RVec&lt;double&gt;::size_type</a>&gt; &gt;) { { 0, 1, 2, 3 } }</div><div class="line"><span class="keyword">auto</span> v_2 = <a class="code" href="namespaceROOT_1_1VecOps.html#a6d1d00c2ccb769cc48c6813dbeb132db">Combinations</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, 2);</div><div class="line"><span class="keyword">auto</span> v_2</div><div class="line">(<a class="code" href="classROOT_1_1VecOps_1_1RVec.html">ROOT::VecOps::RVec</a>&lt;<a class="code" href="classROOT_1_1VecOps_1_1RVec.html">ROOT::VecOps::RVec</a>&lt;<a class="code" href="classROOT_1_1VecOps_1_1RVec.html#acdf49282db08ebce4b517e880513d18b">ROOT::VecOps::RVec&lt;double&gt;::size_type</a>&gt; &gt;) { { 0, 0, 0, 1, 1, 2 }, { 1, 2, 3, 2, 3, 3 } }</div><div class="line"><span class="keyword">auto</span> v_3 = <a class="code" href="namespaceROOT_1_1VecOps.html#a6d1d00c2ccb769cc48c6813dbeb132db">Combinations</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, 3);</div><div class="line">v_3</div><div class="line">(<a class="code" href="classROOT_1_1VecOps_1_1RVec.html">ROOT::VecOps::RVec</a>&lt;<a class="code" href="classROOT_1_1VecOps_1_1RVec.html">ROOT::VecOps::RVec</a>&lt;<a class="code" href="classROOT_1_1VecOps_1_1RVec.html#acdf49282db08ebce4b517e880513d18b">ROOT::VecOps::RVec&lt;double&gt;::size_type</a>&gt; &gt;) { { 0, 0, 0, 1 }, { 1, 1, 2, 2 }, { 2, 3, 3, 3 } }</div><div class="line"><span class="keyword">auto</span> v_4 = <a class="code" href="namespaceROOT_1_1VecOps.html#a6d1d00c2ccb769cc48c6813dbeb132db">Combinations</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, 4);</div><div class="line">v_4</div><div class="line">(<a class="code" href="classROOT_1_1VecOps_1_1RVec.html">ROOT::VecOps::RVec</a>&lt;<a class="code" href="classROOT_1_1VecOps_1_1RVec.html">ROOT::VecOps::RVec</a>&lt;<a class="code" href="classROOT_1_1VecOps_1_1RVec.html#acdf49282db08ebce4b517e880513d18b">ROOT::VecOps::RVec&lt;double&gt;::size_type</a>&gt; &gt;) { { 0 }, { 1 }, { 2 }, { 3 } }</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01204">1204</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a8e298525f7a7c55b510983e3f6ffb833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e298525f7a7c55b510983e3f6ffb833">&#9670;&nbsp;</a></span>Concatenate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 , typename Common_t  = typename std::common_type&lt;T0, T1&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;Common_t&gt; ROOT::VecOps::Concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; <a class="el" href="md5_8inl.html#ac16509a75e3d3fc46b9df1726be486ec">T1</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the concatenation of two RVecs. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> rvf {0.f, 1.f, 2.f};</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;int&gt;</a> rvi {7, 8, 9};</div><div class="line"><a class="code" href="namespaceROOT_1_1VecOps.html#a8e298525f7a7c55b510983e3f6ffb833">Concatenate</a>(rvf, rvi);</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;float&gt;) { 2.0000000, 4.0000000, 4.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01420">1420</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a0d8ddd546ccd87fe25dc7626f9d8b67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8ddd546ccd87fe25dc7626f9d8b67d">&#9670;&nbsp;</a></span>Construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; Args_t &gt; &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of objects starting from RVecs of input to their constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the objects contained in the created <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </td></tr>
    <tr><td class="paramname">Args_t</td><td>Pack of types templating the input RVecs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The RVecs containing the values used to initialise the output objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of objects initialised with the input parameters.</dd></dl>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> etas {.3f, 2.2f, 1.32f};</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> phis {.1f, 3.02f, 2.2f};</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> pts {15.5f, 34.32f, 12.95f};</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> masses {105.65f, 105.65f, 105.65f};</div><div class="line">Construct&lt;ROOT::Math::PtEtaPhiMVector&gt; fourVects(etas, phis, pts, masses);</div><div class="line">cout &lt;&lt; fourVects &lt;&lt; endl;</div><div class="line"><span class="comment">// { (15.5,0.3,0.1,105.65), (34.32,2.2,3.02,105.65), (12.95,1.32,2.2,105.65) }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01622">1622</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a9d0f2e54d5e1b3a186cf06c9ebd9bac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0f2e54d5e1b3a186cf06c9ebd9bac1">&#9670;&nbsp;</a></span>DeltaPhi() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ROOT::VecOps::DeltaPhi </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the angle difference \(\Delta \phi\) of two scalars. </p>
<p>The function computes the closest angle from v1 to v2 with sign and is therefore in the range \([-\pi, \pi]\). The computation is done per default in radians \(c = \pi\) but can be switched to degrees \(c = 180\). </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01439">1439</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a4f546bd6bdeb375538824414804f53e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f546bd6bdeb375538824414804f53e2">&#9670;&nbsp;</a></span>DeltaPhi() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::DeltaPhi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the angle difference \(\Delta \phi\) in radians of two vectors. </p>
<p>The function computes the closest angle from v1 to v2 with sign and is therefore in the range \([-\pi, \pi]\). The computation is done per default in radians \(c = \pi\) but can be switched to degrees \(c = 180\). </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01460">1460</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a6f74fa1623a1e24d3473324e32e78180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f74fa1623a1e24d3473324e32e78180">&#9670;&nbsp;</a></span>DeltaPhi() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::DeltaPhi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the angle difference \(\Delta \phi\) in radians of a vector and a scalar. </p>
<p>The function computes the closest angle from v1 to v2 with sign and is therefore in the range \([-\pi, \pi]\). The computation is done per default in radians \(c = \pi\) but can be switched to degrees \(c = 180\). </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01478">1478</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a87cd6a8197b7fc366102654678215c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cd6a8197b7fc366102654678215c0c">&#9670;&nbsp;</a></span>DeltaPhi() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::DeltaPhi </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the angle difference \(\Delta \phi\) in radians of a scalar and a vector. </p>
<p>The function computes the closest angle from v1 to v2 with sign and is therefore in the range \([-\pi, \pi]\). The computation is done per default in radians \(c = \pi\) but can be switched to degrees \(c = 180\). </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01496">1496</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="aae2c2b2065563d47d79a07e2335095a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2c2b2065563d47d79a07e2335095a2">&#9670;&nbsp;</a></span>DeltaR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::DeltaR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the distance on the \(\eta\)- \(\phi\) plane ( \(\Delta R\)) from the collections eta1, eta2, phi1 and phi2. </p>
<p>The function computes \(\Delta R = \sqrt{(\eta_1 - \eta_2)^2 + (\phi_1 - \phi_2)^2}\) of the given collections eta1, eta2, phi1 and phi2. The angle \(\phi\) can be set to radian or degrees using the optional argument c, see the documentation of the DeltaPhi helper. </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01529">1529</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="affb23cd678b4fbcf50e045aab12bd348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb23cd678b4fbcf50e045aab12bd348">&#9670;&nbsp;</a></span>DeltaR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ROOT::VecOps::DeltaR </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>eta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>eta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>phi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>phi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the distance on the \(\eta\)- \(\phi\) plane ( \(\Delta R\)) from the scalars eta1, eta2, phi1 and phi2. </p>
<p>The function computes \(\Delta R = \sqrt{(\eta_1 - \eta_2)^2 + (\phi_1 - \phi_2)^2}\) of the given scalars eta1, eta2, phi1 and phi2. The angle \(\phi\) can be set to radian or degrees using the optional argument c, see the documentation of the DeltaPhi helper. </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01542">1542</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="ac6d2995da6b2b2c53637a63489ea39d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d2995da6b2b2c53637a63489ea39d9">&#9670;&nbsp;</a></span>DeltaR2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::DeltaR2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="Math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the square of the distance on the \(\eta\)- \(\phi\) plane ( \(\Delta R\)) from the collections eta1, eta2, phi1 and phi2. </p>
<p>The function computes \(\Delta R^2 = (\eta_1 - \eta_2)^2 + (\phi_1 - \phi_2)^2\) of the given collections eta1, eta2, phi1 and phi2. The angle \(\phi\) can be set to radian or degrees using the optional argument c, see the documentation of the DeltaPhi helper. </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01515">1515</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="aa714e75fcefe12330341db69c31d9772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa714e75fcefe12330341db69c31d9772">&#9670;&nbsp;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ROOT::VecOps::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(v0[0] * v1[0])
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inner product. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> v1 {1., 2., 3.};</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> v2 {4., 5., 6.};</div><div class="line"><span class="keyword">auto</span> v1_dot_v2 = <a class="code" href="namespaceROOT_1_1VecOps.html#aa714e75fcefe12330341db69c31d9772">Dot</a>(v1, v2);</div><div class="line">v1_dot_v2</div><div class="line"><span class="comment">// (float) 32.f</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00738">738</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a6951c4389557af80294358c393ba58e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6951c4389557af80294358c393ba58e4">&#9670;&nbsp;</a></span>Filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="md5_8inl.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new collection with the elements passing the filter expressed by the predicate. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;int&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1, 2, 4};</div><div class="line"><span class="keyword">auto</span> v_even = <a class="code" href="namespaceROOT_1_1VecOps.html#a6951c4389557af80294358c393ba58e4">Filter</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, [](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> 0 == i%2;});</div><div class="line">v_even</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;int&gt; &amp;) { 2, 4 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00936">936</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a2e903e9bed20c05d7a70afb393355643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e903e9bed20c05d7a70afb393355643">&#9670;&nbsp;</a></span>Intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v2_is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the intersection of elements of two RVecs. </p>
<p>Each element of v1 is looked up in v2 and added to the returned vector if found. Following, the order of v1 is preserved. If v2 is already sorted, the optional argument v2_is_sorted can be used to toggle of the internal sorting step, therewith optimising runtime.</p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> v1 {1., 2., 3.};</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> v2 {-4., -5., 2., 1.};</div><div class="line"><span class="keyword">auto</span> v1_intersect_v2 = <a class="code" href="namespaceROOT_1_1VecOps.html#a2e903e9bed20c05d7a70afb393355643">Intersect</a>(v1, v2);</div><div class="line">v1_intersect_v2</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 1.0000000, 2.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01281">1281</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a2c531eae910edad48bbf7319cc6d7e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c531eae910edad48bbf7319cc6d7e58">&#9670;&nbsp;</a></span>InvariantMass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ROOT::VecOps::InvariantMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the invariant mass of multiple particles given the collections of the quantities transverse momentum (pt), rapidity (eta), azimuth (phi) and mass. </p>
<p>The function computes the invariant mass of multiple particles with the four-vectors (pt, eta, phi, mass). </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01585">1585</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a07da335066e6edb3849be1b170186bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07da335066e6edb3849be1b170186bab">&#9670;&nbsp;</a></span>InvariantMasses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::InvariantMasses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mass2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the invariant mass of two particles given the collections of the quantities transverse momentum (pt), rapidity (eta), azimuth (phi) and mass. </p>
<p>The function computes the invariant mass of two particles with the four-vectors (pt1, eta2, phi1, mass1) and (pt2, eta2, phi2, mass2). </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01554">1554</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a27aadd40d55ae7f01f3715903551d760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27aadd40d55ae7f01f3715903551d760">&#9670;&nbsp;</a></span>Map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ROOT::VecOps::Map </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceROOT_1_1Detail_1_1VecOps.html#ac5bcef1fdf51a657fb9886a89c741627">ROOT::Detail::VecOps::MapFromTuple</a>(std::forward_as_tuple(args...),
                                                  std::make_index_sequence&lt;sizeof...(args) - 1&gt;()))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new collection applying a callable to the elements of the input collection. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1.f, 2.f, 4.f};</div><div class="line"><span class="keyword">auto</span> v_square = <a class="code" href="namespaceROOT_1_1VecOps.html#a27aadd40d55ae7f01f3715903551d760">Map</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, [](<span class="keywordtype">float</span> <a class="code" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>){<span class="keywordflow">return</span> <a class="code" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>* 2.f;});</div><div class="line">v_square</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;float&gt; &amp;) { 2.00000f, 4.00000f, 8.00000f }</span></div><div class="line"></div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>({1.f, 2.f, 3.f});</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>({4.f, 5.f, 6.f});</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="TRolke_8cxx.html#a89a026883dd7df087bf16c8c176caeed">z</a>({7.f, 8.f, 9.f});</div><div class="line"><span class="keyword">auto</span> mod = [](<span class="keywordtype">float</span> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>, <span class="keywordtype">float</span> <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>, <span class="keywordtype">float</span> <a class="code" href="TRolke_8cxx.html#a89a026883dd7df087bf16c8c176caeed">z</a>) { <span class="keywordflow">return</span> <a class="code" href="TMath_8h.html#acdb55c1010a6c379a49db0201bf55d89">sqrt</a>(<a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a> * <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a> + <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a> * <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a> + <a class="code" href="TRolke_8cxx.html#a89a026883dd7df087bf16c8c176caeed">z</a> * <a class="code" href="TRolke_8cxx.html#a89a026883dd7df087bf16c8c176caeed">z</a>); };</div><div class="line"><span class="keyword">auto</span> v_mod = <a class="code" href="namespaceROOT_1_1VecOps.html#a27aadd40d55ae7f01f3715903551d760">Map</a>(<a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>, <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>, <a class="code" href="TRolke_8cxx.html#a89a026883dd7df087bf16c8c176caeed">z</a>, mod);</div><div class="line">v_mod</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;float&gt; &amp;) { 8.12404f, 9.64365f, 11.2250f }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00907">907</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a014f2c5ed975748eef051cf7df955ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014f2c5ed975748eef051cf7df955ba5">&#9670;&nbsp;</a></span>Max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ROOT::VecOps::Max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the greatest element of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1.f, 2.f, 4.f};</div><div class="line"><span class="keyword">auto</span> v_max = <a class="code" href="namespaceROOT_1_1VecOps.html#a014f2c5ed975748eef051cf7df955ba5">Max</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</div><div class="line">v_max</div><div class="line">(<span class="keywordtype">float</span>) 4.f</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00790">790</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a72261407fa7c77d7066a063cd55dfdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72261407fa7c77d7066a063cd55dfdb2">&#9670;&nbsp;</a></span>Mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double ROOT::VecOps::Mean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mean of the elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </p>
<p>The return type is a double precision floating point number. Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1.f, 2.f, 4.f};</div><div class="line"><span class="keyword">auto</span> v_mean = <a class="code" href="namespaceROOT_1_1VecOps.html#a72261407fa7c77d7066a063cd55dfdb2">Mean</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">v_mean</div><div class="line"><span class="comment">// (double) 2.3333333</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00773">773</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="aaa9fe1cc9c0975ee89f84b7e67fb9d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9fe1cc9c0975ee89f84b7e67fb9d4e">&#9670;&nbsp;</a></span>Min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ROOT::VecOps::Min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the smallest element of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1.f, 2.f, 4.f};</div><div class="line"><span class="keyword">auto</span> v_min = <a class="code" href="namespaceROOT_1_1VecOps.html#aaa9fe1cc9c0975ee89f84b7e67fb9d4e">Min</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</div><div class="line">v_min</div><div class="line">(<span class="keywordtype">float</span>) 1.f</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00806">806</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="aef0d21c900adb578bf49a3063733cb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0d21c900adb578bf49a3063733cb1a">&#9670;&nbsp;</a></span>Nonzero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt;::size_type&gt; ROOT::VecOps::Nonzero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the indices of the elements which are not zero. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {2., 0., 3., 0., 1.};</div><div class="line"><span class="keyword">auto</span> nonzero_idx = <a class="code" href="namespaceROOT_1_1VecOps.html#aef0d21c900adb578bf49a3063733cb1a">Nonzero</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">nonzero_idx</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;ROOT::VecOps::RVec&lt;double&gt;::size_type&gt;) { 0, 2, 4 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01250">1250</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a015fbd3ba377ff20a90797b15696a09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015fbd3ba377ff20a90797b15696a09d">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ROOT::VecOps::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> at the prompt: </p>

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01636">1636</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a7226744d506fbf6e2776beeb460adc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7226744d506fbf6e2776beeb460adc05">&#9670;&nbsp;</a></span>Reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return copy of reversed vector. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {2., 3., 1.};</div><div class="line"><span class="keyword">auto</span> v_reverse = <a class="code" href="namespaceROOT_1_1VecOps.html#a7226744d506fbf6e2776beeb460adc05">Reverse</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">v_reverse</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 1.0000000, 3.0000000, 2.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01081">1081</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a77262ab810a179ba1c555648e8d5909b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77262ab810a179ba1c555648e8d5909b">&#9670;&nbsp;</a></span>Sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Sort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return copy of <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> with elements sorted in ascending order. </p>
<p>This helper is different from ArgSort since it does not return an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of indices, but an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of values.</p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {2., 3., 1.};</div><div class="line"><span class="keyword">auto</span> v_sorted = <a class="code" href="namespaceROOT_1_1VecOps.html#a77262ab810a179ba1c555648e8d5909b">Sort</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">v_sorted</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 1.0000000, 2.0000000, 3.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01102">1102</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a882439c2ff958157d2990b52dd76f599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882439c2ff958157d2990b52dd76f599">&#9670;&nbsp;</a></span>Sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Sort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TVectorT_8cxx.html#ae6baa722a687905f9e3a08a0b95b2cf4">Compare</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return copy of <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> with elements sorted based on a comparison operator. </p>
<p>The comparison operator has to fullfill the same requirements of the predicate of by std::sort.</p>
<p>This helper is different from ArgSort since it does not return an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of indices, but an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a> of values.</p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {2., 3., 1.};</div><div class="line"><span class="keyword">auto</span> v_sorted = <a class="code" href="namespaceROOT_1_1VecOps.html#a77262ab810a179ba1c555648e8d5909b">Sort</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, [](<span class="keywordtype">double</span> <a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a>, <span class="keywordtype">double</span> <a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>) {<span class="keywordflow">return</span> 1/<a class="code" href="legend1_8C.html#a13c6713ae496caa8195647f76887f926">x</a> &lt; 1/<a class="code" href="legend1_8C.html#a1380cd153a0fc78015dd604dbcb6c841">y</a>;});</div><div class="line">v_sorted</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 3.0000000, 2.0000000, 1.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01127">1127</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="ad51a36ad424a7806508dfb4eafdcbb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51a36ad424a7806508dfb4eafdcbb99">&#9670;&nbsp;</a></span>StdDev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double ROOT::VecOps::StdDev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the standard deviation of the elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </p>
<p>The return type is a double precision floating point number. Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1.f, 2.f, 4.f};</div><div class="line"><span class="keyword">auto</span> v_sd = <a class="code" href="namespaceROOT_1_1VecOps.html#ad51a36ad424a7806508dfb4eafdcbb99">StdDev</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">v_sd</div><div class="line"><span class="comment">// (double) 1.5275252</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00883">883</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a1638f2982ee60712f1f02e31d3e178ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1638f2982ee60712f1f02e31d3e178ad">&#9670;&nbsp;</a></span>Sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ROOT::VecOps::Sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1.f, 2.f, 3.f};</div><div class="line"><span class="keyword">auto</span> v_sum = <a class="code" href="namespaceROOT_1_1VecOps.html#a1638f2982ee60712f1f02e31d3e178ad">Sum</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">v_sum</div><div class="line"><span class="comment">// (float) 6.f</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00756">756</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a7e16ecd5df9720e7e2009ab1d973220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e16ecd5df9720e7e2009ab1d973220d">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a> ROOT::VecOps::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00987">987</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a3be88aa9a0a886abe2fcbbfc759be960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be88aa9a0a886abe2fcbbfc759be960">&#9670;&nbsp;</a></span>Take() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Take </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; typename <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt;::size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return elements of a vector at given indices. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {2., 3., 1.};</div><div class="line"><span class="keyword">auto</span> vTaken = <a class="code" href="namespaceROOT_1_1VecOps.html#a3be88aa9a0a886abe2fcbbfc759be960">Take</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, {0,2});</div><div class="line">vTaken</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 2.0000000, 1.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01023">1023</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a46d5f310c958498f5248346478f5297a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d5f310c958498f5248346478f5297a">&#9670;&nbsp;</a></span>Take() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Take </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return first or last <code>n</code> elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </p>
<p>if <code>n &gt; 0</code> and last elements if <code>n &lt; 0</code>.</p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {2., 3., 1.};</div><div class="line"><span class="keyword">auto</span> firstTwo = <a class="code" href="namespaceROOT_1_1VecOps.html#a3be88aa9a0a886abe2fcbbfc759be960">Take</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, 2);</div><div class="line">firstTwo</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 2.0000000, 3.0000000 }</span></div><div class="line"><span class="keyword">auto</span> lastOne = <a class="code" href="namespaceROOT_1_1VecOps.html#a3be88aa9a0a886abe2fcbbfc759be960">Take</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, -1);</div><div class="line">lastOne</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 1.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01049">1049</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="af9fbd6b649ecd2ee62c3d8f30e9cece1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fbd6b649ecd2ee62c3d8f30e9cece1">&#9670;&nbsp;</a></span>Var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double ROOT::VecOps::Var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the variance of the elements of an <a class="el" href="classROOT_1_1VecOps_1_1RVec.html" title=" A &quot;std::vector&quot;-like collection of values implementing handy operation to analyse them ...">RVec</a>. </p>
<p>The return type is a double precision floating point number. Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;float&gt;</a> <a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a> {1.f, 2.f, 4.f};</div><div class="line"><span class="keyword">auto</span> v_var = <a class="code" href="namespaceROOT_1_1VecOps.html#af9fbd6b649ecd2ee62c3d8f30e9cece1">Var</a>(<a class="code" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>);</div><div class="line">v_var</div><div class="line"><span class="comment">// (double) 2.3333333</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l00859">859</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="ad1ec4b9cb652a124c4eae0879bbc44c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ec4b9cb652a124c4eae0879bbc44c1">&#9670;&nbsp;</a></span>Where() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elements of v1 if the condition c is true and v2 if the condition c is false. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> v1 {1., 2., 3.};</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> v2 {-1., -2., -3.};</div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a> = v1 &gt; 1;</div><div class="line"><a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a></div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;int&gt; &amp;) { 0, 1, 1 }</span></div><div class="line"><span class="keyword">auto</span> if_c_v1_else_v2 = <a class="code" href="namespaceROOT_1_1VecOps.html#ad1ec4b9cb652a124c4eae0879bbc44c1">Where</a>(<a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>, v1, v2);</div><div class="line">if_c_v1_else_v2</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt; &amp;) { -1.0000000, 2.0000000, 3.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01315">1315</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a4fef176de7e03730c5f97cc62c9569ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fef176de7e03730c5f97cc62c9569ec">&#9670;&nbsp;</a></span>Where() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elements of v1 if the condition c is true and sets the value v2 if the condition c is false. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> v1 {1., 2., 3.};</div><div class="line"><span class="keywordtype">double</span> v2 = 4.;</div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a> = v1 &gt; 1;</div><div class="line"><a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a></div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;int&gt; &amp;) { 0, 1, 1 }</span></div><div class="line"><span class="keyword">auto</span> if_c_v1_else_v2 = <a class="code" href="namespaceROOT_1_1VecOps.html#ad1ec4b9cb652a124c4eae0879bbc44c1">Where</a>(<a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>, v1, v2);</div><div class="line">if_c_v1_else_v2</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 4.0000000, 2.0000000, 3.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01343">1343</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="ad3ce8ff6d82ed3d2cfce9dafceba7139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ce8ff6d82ed3d2cfce9dafceba7139">&#9670;&nbsp;</a></span>Where() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elements of v2 if the condition c is false and sets the value v1 if the condition c is true. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><span class="keywordtype">double</span> v1 = 4.;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;double&gt;</a> v2 {1., 2., 3.};</div><div class="line"><span class="keyword">auto</span> <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a> = v2 &gt; 1;</div><div class="line"><a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a></div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;int&gt; &amp;) { 0, 1, 1 }</span></div><div class="line"><span class="keyword">auto</span> if_c_v1_else_v2 = <a class="code" href="namespaceROOT_1_1VecOps.html#ad1ec4b9cb652a124c4eae0879bbc44c1">Where</a>(<a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>, v1, v2);</div><div class="line">if_c_v1_else_v2</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 1.0000000, 4.0000000, 4.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01371">1371</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
<a id="a4e6390cb179366cc24afceafed86f748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6390cb179366cc24afceafed86f748">&#9670;&nbsp;</a></span>Where() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt;T&gt; ROOT::VecOps::Where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1VecOps_1_1RVec.html">RVec</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector with the value v2 if the condition c is false and sets the value v1 if the condition c is true. </p>
<p>Example code, at the <a class="el" href="namespaceROOT.html" title="Namespace for new ROOT classes and functions. ">ROOT</a> prompt: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceROOT_1_1VecOps.html">ROOT::VecOps</a>;</div><div class="line"><span class="keywordtype">double</span> v1 = 4.;</div><div class="line"><span class="keywordtype">double</span> v2 = 2.;</div><div class="line"><a class="code" href="classROOT_1_1VecOps_1_1RVec.html">RVec&lt;int&gt;</a> <a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a> {0, 1, 1};</div><div class="line"><span class="keyword">auto</span> if_c_v1_else_v2 = <a class="code" href="namespaceROOT_1_1VecOps.html#ad1ec4b9cb652a124c4eae0879bbc44c1">Where</a>(<a class="code" href="RSha256_8hxx.html#a63f410abde93141c9013b7d3f3971738">c</a>, v1, v2);</div><div class="line">if_c_v1_else_v2</div><div class="line"><span class="comment">// (ROOT::VecOps::RVec&lt;double&gt;) { 2.0000000, 4.0000000, 4.0000000 }</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RVec_8hxx_source.html#l01397">1397</a> of file <a class="el" href="RVec_8hxx_source.html">RVec.hxx</a>.</p>

</div>
</div>
</div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:11:58 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
