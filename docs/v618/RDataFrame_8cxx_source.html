<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: tree/dataframe/src/RDataFrame.cxx Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70093cb3a9d1f8840af4e997fde867c3.html">tree</a></li><li class="navelem"><a class="el" href="dir_8af57de82206d86c1654bc47e0b85bc3.html">dataframe</a></li><li class="navelem"><a class="el" href="dir_647aec5a94dac80d1597a04d372ca11d.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RDataFrame.cxx</div>  </div>
</div><!--header-->
<div class="contents">
<a href="RDataFrame_8cxx.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Author: Enrico Guiraud, Danilo Piparo CERN  12/2016</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">/*************************************************************************</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers.               *</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> * All rights reserved.                                                  *</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"> *                                                                       *</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"> * For the licensing terms see $ROOTSYS/LICENSE.                         *</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"> * For the list of contributors see $ROOTSYS/README/CREDITS.             *</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"> *************************************************************************/</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &lt;stdexcept&gt;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="RDataFrame_8hxx.html">ROOT/RDataFrame.hxx</a>&quot;</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="RDataSource_8hxx.html">ROOT/RDataSource.hxx</a>&quot;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="TChain_8h.html">TChain.h</a>&quot;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="TDirectory_8h.html">TDirectory.h</a>&quot;</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">// clang-format off</span><span class="comment"></span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">* \class ROOT::RDataFrame</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">* \ingroup dataframe</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">* \brief ROOT&#39;s RDataFrame offers a high level interface for analyses of data stored in `TTree`s, CSV&#39;s and other data formats.</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">on their machines completely transparently.&lt;br&gt;</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">Skip to the [class reference](#reference) or keep reading for the user guide.</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">In a nutshell:</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">ROOT::RDataFrame d(&quot;myTree&quot;, &quot;file_*.root&quot;); // Interface to TTree and TChain</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">auto myHisto = d.Histo1D(&quot;Branch_A&quot;); // This happens in parallel!</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">myHisto-&gt;Draw();</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, `RDataFrame` takes</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">care of their execution. The implementation automatically puts in place several low level optimisations such as</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">multi-thread parallelisation and caching.</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">\htmlonly</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">&lt;a href=&quot;https://doi.org/10.5281/zenodo.260230&quot;&gt;&lt;img src=&quot;https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg&quot;</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">alt=&quot;DOI&quot;&gt;&lt;/a&gt;</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">\endhtmlonly</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">## For the impatient user</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">You can directly see RDataFrame in action through its [code examples](https://root.cern.ch/doc/master/group__tutorial__dataframe.html), both in C++ and Python.</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">## Table of Contents</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">- [Cheat sheet](#cheatsheet)</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">- [Introduction](#introduction)</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">- [Crash course](#crash-course)</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">- [More features](#more-features)</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">- [Transformations](#transformations) -- manipulating data</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">- [Actions](#actions) -- getting results</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">- [Parallel execution](#parallel-execution) -- how to use it and common pitfalls</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">- [Class reference](#reference) -- most methods are implemented in the [RInterface](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html) base class</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">## &lt;a name=&quot;cheatsheet&quot;&gt;&lt;/a&gt;Cheat sheet</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">These are the operations which can be performed with RDataFrame</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">### Transformations</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">Transformations are a way to manipulate the data.</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">| **Transformation** | **Description** |</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">|------------------|--------------------|</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">| [Define](classROOT_1_1RDF_1_1RInterface.html#a7d48eb23b4378e99ebccb35e94ad025a) | Creates a new column in the dataset. |</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">| [DefineSlot](classROOT_1_1RDF_1_1RInterface.html#acaacf727b8a41d27c6bb4513348ac892) | Same as `Define`, but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe `Define` transformation when using `RDataFrame` after `ROOT::EnableImplicitMT()`. `DefineSlot` works just as well with single-thread execution: in that case `slot` will always be `0`.  |</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment">| [DefineSlotEntry](classROOT_1_1RDF_1_1RInterface.html#a4f17074d5771916e3df18f8458186de7) | Same as `DefineSlot`, but the entry number is passed in addition to the slot number. This is meant as a helper in case some dependency on the entry number needs to be honoured. |</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment">| [Filter](classROOT_1_1RDF_1_1RInterface.html#a70284a3bedc72b19610aaa91b5007ebd) | Filter the rows of the dataset. |</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">| [Range](classROOT_1_1RDF_1_1RInterface.html#a1b36b7868831de2375e061bb06cfc225) | Creates a node that filters entries based on range of entries |</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment">### Actions</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment">Actions are a way to produce a result out of the data. Each one is described in more detail in the reference guide.</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">In the following, whenever we say an action &quot;returns&quot; something, we always mean it returns a smart pointer to it. Also</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">note that all actions are only executed for events that pass all preceding filters.</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">produce several different results in one event loop. Instant actions trigger the event loop instantly.</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment">| **Lazy action** | **Description** |</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">|------------------|-----------------|</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">| [Aggregate](classROOT_1_1RDF_1_1RInterface.html#ae540b00addc441f9b504cbae0ef0a24d) | Execute a user-defined accumulation operation on the processed column values. |</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment">| [Book](classROOT_1_1RDF_1_1RInterface.html#a9b2f61f3333d1669e57055b9ae8be9d9) | Book execution of a custom action using a user-defined helper object. |</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment">| [Cache](classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9) | Caches in contiguous memory columns&#39; entries. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment">| [Count](classROOT_1_1RDF_1_1RInterface.html#a37f9e00c2ece7f53fae50b740adc1456) | Return the number of events processed. |</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment">| [Display](classROOT_1_1RDF_1_1RInterface.html#aee68f4411f16f00a1d46eccb6d296f01) | Obtains the events in the dataset for the requested columns. The method returns a [RDisplay](classROOT_1_1RDF_1_1RDisplay.html) instance which can be queried to get a compressed tabular representation on the standard output or a complete representation as a string. |</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">| [Fill](classROOT_1_1RDF_1_1RInterface.html#a0cac4d08297c23d16de81ff25545440a) | Fill a user-defined object with the values of the specified branches, as if by calling `Obj.Fill(branch1, branch2, ...). |</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">| [Graph](classROOT_1_1RDF_1_1RInterface.html#a804b466ebdbddef5c7e3400cc6b89301) | Fills a TGraph with the two columns provided. If Multithread is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">| [Histo{1D,2D,3D}](classROOT_1_1RDF_1_1RInterface.html#a247ca3aeb7ce5b95015b7fae72983055) | Fill a {one,two,three}-dimensional histogram with the processed branch values. |</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">| [Max](classROOT_1_1RDF_1_1RInterface.html#a057179b1e77599466a0b02200d5cd8c3) | Return the maximum of processed branch values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">| [Mean](classROOT_1_1RDF_1_1RInterface.html#ade6b020284f2f4fe9d3b09246b5f376a) | Return the mean of processed branch values.|</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">| [Min](classROOT_1_1RDF_1_1RInterface.html#a7005702189e601972b6d19ecebcdc80c) | Return the minimum of processed branch values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment">| [Profile{1D,2D}](classROOT_1_1RDF_1_1RInterface.html#a8ef7dc16b0e9f7bc9cfbe2d9e5de0cef) | Fill a {one,two}-dimensional profile with the branch values that passed all filters. |</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment">| [Reduce](classROOT_1_1RDF_1_1RInterface.html#a118e723ae29834df8f2a992ded347354) | Reduce (e.g. sum, merge) entries using the function (lambda, functor...) passed as argument. The function must have signature `T(T,T)` where `T` is the type of the branch. Return the final result of the reduction operation. An optional parameter allows initialization of the result object to non-default values. |</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment">| [Report](classROOT_1_1RDF_1_1RInterface.html#a94f322531dcb25beb8f53a602e5d6332) | Obtains statistics on how many entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">| [StdDev](classROOT_1_1RDF_1_1RInterface.html#a482c4e4f81fe1e421c016f89cd281572) | Return the unbiased standard deviation of the processed branch values. |</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment">| [Sum](classROOT_1_1RDF_1_1RInterface.html#a61d03407459120df6749af43ed506891) | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment">| [Take](classROOT_1_1RDF_1_1RInterface.html#a4fd694773a2931b6b07737ddcd1e73b4) | Extract a column from the dataset as a collection of values. If the type of the column is a C-style array, the type stored in the return container is a `ROOT::VecOps::RVec&lt;T&gt;` to guarantee the lifetime of the data involved. |</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment">| **Instant action** | **Description** |</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment">|---------------------|-----------------|</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment">| [Foreach](classROOT_1_1RDF_1_1RInterface.html#ad2822a7ccb8a9afdf3e5b2ea321886ca) | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this lambda when executing with implicit multi-threading enabled. |</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment">| [ForeachSlot](classROOT_1_1RDF_1_1RInterface.html#a3650ca30aae1ccd0d92bf3d680314129) | Same as `Foreach`, but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe `Foreach` actions when using `RDataFrame` after `ROOT::EnableImplicitMT()`. `ForeachSlot` works just as well with single-thread execution: in that case `slot` will always be `0`. |</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment">| [Snapshot](classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8) | Writes processed data-set to disk, in a new `TTree` and `TFile`. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. `Snapshot` can be made *lazy* setting the appropriate flage in the snapshot options.|</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment">### Other Operations</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">| **Operation** | **Description** |</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">|---------------------|-----------------|</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment">| [Alias](classROOT_1_1RDF_1_1RInterface.html#a31ca327e4a192dcc05a4aac240e1a725) | Introduce an alias for a particular column name. |</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">| [GetColumnNames](classROOT_1_1RDF_1_1RInterface.html#a951fe60b74d3a9fda37df59fd1dac186) | Get the names of all the available columns of the dataset. |</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">| [GetDefinedColumnNames](classROOT_1_1RDF_1_1RInterface.html#ad5c3fab8155aae8f614735df68430c58) | Get the names of all the defined columns |</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">| [GetColumnType](classROOT_1_1RDF_1_1RInterface.html#ad3ccd813d9fed014ae6a080411c5b5a8) | Return the type of a given column as a string. |</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">| [GetColumnTypeNamesList](classROOT_1_1RDF_1_1RInterface.html#a951fe60b74d3a9fda37df59fd1dac186) | Return the list of type names of columns in the dataset. |</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">| [GetFilterNames](classROOT_1_1RDF_1_1RInterface.html#a25026681111897058299161a70ad9bb2) | Get all the filters defined. If called on a root node, all filters will be returned. For any other node, only the filters upstream of that node. |</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">| [Display](classROOT_1_1RDF_1_1RInterface.html#a652f9ab3e8d2da9335b347b540a9a941) | Provides an ASCII representation of the columns types and contents of the dataset printable by the user. |</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">| [SaveGraph](namespaceROOT_1_1RDF.html#adc17882b283c3d3ba85b1a236197c533) | Store the computation graph of an RDataFrame in graphviz format for easy inspection. |</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">## &lt;a name=&quot;introduction&quot;&gt;&lt;/a&gt;Introduction</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">Users define their analysis as a sequence of operations to be performed on the data-frame object; the framework</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">takes care of the management of the loop over entries as well as low-level details such as I/O and parallelisation.</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">`RDataFrame` provides methods to perform most common operations required by ROOT analyses;</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">at the same time, users can just as easily specify custom code that will be executed in the event loop.</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">`RDataFrame` is built with a *modular* and *flexible* workflow in mind, summarised as follows:</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment">1. **build a data-frame** object by specifying your data-set</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment">2. **apply a series of transformations** to your data</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment">   1.  **filter** (e.g. apply some cuts) or</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment">   2.  **define** a new column (e.g. the result of an expensive computation on branches)</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment">3. **apply actions** to the transformed data to produce results (e.g. fill a histogram)</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment">The following table shows how analyses based on `TTreeReader` and `TTree::Draw` translate to `RDataFrame`. Follow the</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment">[crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with `RDataFrame`.</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment">&lt;table&gt;</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">&lt;tr&gt;</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment">   &lt;td&gt;</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">      &lt;b&gt;TTreeReader&lt;/b&gt;</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">   &lt;/td&gt;</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment">   &lt;td&gt;</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">      &lt;b&gt;ROOT::RDataFrame&lt;/b&gt;</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment">   &lt;/td&gt;</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment">&lt;/tr&gt;</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment">&lt;tr&gt;</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment">   &lt;td&gt;</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">TTreeReader reader(&quot;myTree&quot;, file);</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">TTreeReaderValue&lt;A_t&gt; a(reader, &quot;A&quot;);</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">TTreeReaderValue&lt;B_t&gt; b(reader, &quot;B&quot;);</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">TTreeReaderValue&lt;C_t&gt; c(reader, &quot;C&quot;);</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment">while(reader.Next()) {</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">   if(IsGoodEvent(*a, *b, *c))</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment">      DoStuff(*a, *b, *c);</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment">}</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">   &lt;/td&gt;</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment">   &lt;td&gt;</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">ROOT::RDataFrame d(&quot;myTree&quot;, file, {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;});</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">d.Filter(IsGoodEvent).Foreach(DoStuff);</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment">   &lt;/td&gt;</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment">&lt;/tr&gt;</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment">&lt;tr&gt;</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment">   &lt;td&gt;</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">      &lt;b&gt;TTree::Draw&lt;/b&gt;</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment">   &lt;/td&gt;</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment">   &lt;td&gt;</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment">      &lt;b&gt;ROOT::RDataFrame&lt;/b&gt;</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment">   &lt;/td&gt;</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment">&lt;/tr&gt;</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment">&lt;tr&gt;</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment">   &lt;td&gt;</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">auto t = file-&gt;Get&lt;TTree&gt;(&quot;myTree&quot;);</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">t-&gt;Draw(&quot;x&quot;, &quot;y &gt; 2&quot;);</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">   &lt;/td&gt;</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">   &lt;td&gt;</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment">ROOT::RDataFrame d(&quot;myTree&quot;, file);</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">auto h = d.Filter(&quot;y &gt; 2&quot;).Histo1D(&quot;x&quot;);</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">   &lt;/td&gt;</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">&lt;/tr&gt;</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">&lt;/table&gt;</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">## &lt;a name=&quot;crash-course&quot;&gt;&lt;/a&gt; Crash course</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">All snippets of code presented in the crash course can be executed in the ROOT interpreter. Simply precede them with</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">using namespace ROOT; // RDataFrame&#39;s namespace</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment">which is omitted for brevity. The terms &quot;column&quot; and &quot;branch&quot; are used interchangeably.</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment">### Creating a RDataFrame</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment">RDataFrame&#39;s constructor is where the user specifies the dataset and, optionally, a default set of columns that</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">operations should work with. Here are the most common methods to construct a RDataFrame object:</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment">// single file -- all ctors are equivalent</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">TFile *f = TFile::Open(&quot;file.root&quot;);</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">auto t = f.Get&lt;TTree&gt;(&quot;treeName&quot;);</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">RDataFrame d1(&quot;treeName&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">RDataFrame d2(&quot;treeName&quot;, f); // same as TTreeReader</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">RDataFrame d3(*t); // TTreeReader takes a pointer, RDF takes a reference</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment">// multiple files -- all ctors are equivalent</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">std::vector&lt;std::string&gt; files = {&quot;file1.root&quot;, &quot;file2.root&quot;};</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">TChain chain(&quot;myTree&quot;);</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">chain.Add(&quot;file1.root&quot;);</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">chain.Add(&quot;file2.root&quot;);</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">RDataFrame d4(&quot;myTree&quot;, {&quot;file1.root&quot;, &quot;file2.root&quot;});</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment">RDataFrame d5(&quot;myTree&quot;, files);</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">RDataFrame d6(&quot;myTree&quot;, &quot;file*.root&quot;); // see TRegexp&#39;s documentation for a list of valid regexes</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">RDataFrame d7(chain);</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">Additionally, users can construct a RDataFrame specifying just an integer number. This is the number of &quot;events&quot; that</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment">will be generated by this RDataFrame.</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">RDataFrame d(10); // a RDF with 10 entries (and no columns/branches, for now)</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">d.Foreach([] { static int i = 0; std::cout &lt;&lt; i++ &lt;&lt; std::endl; }); // silly example usage: count to ten</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">This is useful to generate simple data-sets on the fly: the contents of each event can be specified via the `Define`</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">transformation (explained below). For example, we have used this method to generate Pythia events (with a `Define`</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment">transformation) and write them to disk in parallel (with the `Snapshot` action).</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">### Filling a histogram</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment">Let&#39;s now tackle a very common task, filling a histogram:</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">// Fill a TH1D with the &quot;MET&quot; branch</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment">RDataFrame d(&quot;myTree&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">auto h = d.Histo1D(&quot;MET&quot;);</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">h-&gt;Draw();</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment">The first line creates a `RDataFrame` associated to the `TTree` &quot;myTree&quot;. This tree has a branch named &quot;MET&quot;.</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment">`Histo1D` is an *action*; it returns a smart pointer (a `RResultPtr` to be precise) to a `TH1D` histogram filled</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">with the `MET` of all events. If the quantity stored in the branch is a collection (e.g. a vector or an array), the</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">histogram is filled with its elements.</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">You can use the objects returned by actions as if they were pointers to the desired results. There are many other</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment">possible [actions](#overview), and all their results are wrapped in smart pointers; we&#39;ll see why in a minute.</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">### Applying a filter</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">Let&#39;s say we want to cut over the value of branch &quot;MET&quot; and count how many events pass this cut. This is one way to do it:</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">RDataFrame d(&quot;myTree&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">auto c = d.Filter(&quot;MET &gt; 4.&quot;).Count();</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">std::cout &lt;&lt; *c &lt;&lt; std::endl;</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment">The filter string (which must contain a valid c++ expression) is applied to the specified branches for each event;</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment">the name and types of the columns are inferred automatically. The string expression is required to return a `bool`</span></div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">which signals whether the event passes the filter (`true`) or not (`false`).</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">You can think of your data as &quot;flowing&quot; through the chain of calls, being transformed, filtered and finally used to</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">perform actions. Multiple `Filter` calls can be chained one after another.</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment">Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment">statement or the body of a lambda, so it&#39;s cumbersome to use strings with more complex filters. They also add a small</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,</span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">but it can be any kind of function or even a functor class), together with a list of branch names.</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">This snippet is analogous to the one above:</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">RDataFrame d(&quot;myTree&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">auto metCut = [](double x) { return x &gt; 4.; }; // a c++11 lambda function checking &quot;x &gt; 4&quot;</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">auto c = d.Filter(metCut, {&quot;MET&quot;}).Count();</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">std::cout &lt;&lt; *c &lt;&lt; std::endl;</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">An example of a more complex filter expressed as a string containing C++ code is shown below</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">RDataFrame d(&quot;myTree&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment">auto df = d.Define(&quot;p&quot;, &quot;std::array&lt;double, 4&gt; p{px, py, pz}; return p;&quot;)</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">           .Filter(&quot;double p2 = 0.0; for (auto&amp;&amp; x : p) p2 += x*x; return sqrt(p2) &lt; 10.0;&quot;);</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">The code snippet above defines a column `p` that is a fixed-size array using the component column names and then</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment">filters on its magnitude by looping over its elements. It must be noted that the usage of strings to define columns</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment">like the one above is a major advantage when using PyROOT. However, only constants and data coming from other columns</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment">in the dataset can be involved in the code passed as a string. Local variables and functions cannot be used, since</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment">the interpreter will not know how to find them. When capturing local state is necessary, a C++ callable can be used.</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment">More information on filters and how to use them to automatically generate cutflow reports can be found [below](#Filters).</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment">### Defining custom columns</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment">Let&#39;s now consider the case in which &quot;myTree&quot; contains two quantities &quot;x&quot; and &quot;y&quot;, but our analysis relies on a derived</span></div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment">quantity `z = sqrt(x*x + y*y)`. Using the `Define` transformation, we can create a new column in the data-set containing</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">the variable &quot;z&quot;:</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment">RDataFrame d(&quot;myTree&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="comment">auto sqrtSum = [](double x, double y) { return sqrt(x*x + y*y); };</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="comment">auto zMean = d.Define(&quot;z&quot;, sqrtSum, {&quot;x&quot;,&quot;y&quot;}).Mean(&quot;z&quot;);</span></div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="comment">std::cout &lt;&lt; *zMean &lt;&lt; std::endl;</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="comment">`Define` creates the variable &quot;z&quot; by applying `sqrtSum` to &quot;x&quot; and &quot;y&quot;. Later in the chain of calls we refer to</span></div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="comment">variables created with `Define` as if they were actual tree branches/columns, but they are evaluated on demand, at most</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="comment">once per event. As with filters, `Define` calls can be chained with other transformations to create multiple custom</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="comment">columns. `Define` and `Filter` transformations can be concatenated and intermixed at will.</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment">As with filters, it is possible to specify new columns as string expressions. This snippet is analogous to the one above:</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment">RDataFrame d(&quot;myTree&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment">auto zMean = d.Define(&quot;z&quot;, &quot;sqrt(x*x + y*y)&quot;).Mean(&quot;z&quot;);</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment">std::cout &lt;&lt; *zMean &lt;&lt; std::endl;</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment">Again the names of the branches used in the expression and their types are inferred automatically. The string must be</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="comment">valid c++ and is just-in-time compiled by the ROOT interpreter, cling -- the process has a small runtime overhead.</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment">Previously, when showing the different ways a RDataFrame can be created, we showed a constructor that only takes a</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment">number of entries a parameter. In the following example we show how to combine such an &quot;empty&quot; `RDataFrame` with `Define`</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment">transformations to create a data-set on the fly. We then save the generated data on disk using the `Snapshot` action.</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="comment">RDataFrame d(100); // a RDF that will generate 100 entries (currently empty)</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="comment">int x = -1;</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment">auto d_with_columns = d.Define(&quot;x&quot;, [&amp;x] { return ++x; })</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment">                       .Define(&quot;xx&quot;, [&amp;x] { return x*x; });</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">d_with_columns.Snapshot(&quot;myNewTree&quot;, &quot;newfile.root&quot;);</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">This example is slightly more advanced than what we have seen so far: for starters, it makes use of lambda captures (a</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">simple way to make external variables available inside the body of c++ lambdas) to act on the same variable `x` from</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">both `Define` transformations. Secondly we have *stored* the transformed data-frame in a variable. This is always</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">possible: at each point of the transformation chain, users can store the status of the data-frame for further use (more</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">on this [below](#callgraphs)).</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment">You can read more about defining new columns [here](#custom-columns).</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">\image html RDF_Graph.png &quot;A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action.&quot;</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment">### Running on a range of entries</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment">It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment">offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment">actions can be concatenated to and intermixed with `Range`s. If a range is specified after a filter, the range will act</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment">exclusively on the entries passing the filter -- it will not even count the other entries! The same goes for a `Range`</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment">hanging from another `Range`. Here are some commented examples:</span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment">RDataFrame d(&quot;myTree&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">// Here we store a data-frame that loops over only the first 30 entries in a variable</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">auto d30 = d.Range(30);</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment">// This is how you pick all entries from 15 onwards</span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment">auto d15on = d.Range(15, 0);</span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment">// We can specify a stride too, in this case we pick an event every 3</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment">auto d15each3 = d.Range(0, 15, 3);</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">Note that ranges are not available when multi-threading is enabled. More information on ranges is available</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">[here](#ranges).</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment">### Executing multiple actions in the same event loop</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment">As a final example let us apply two different cuts on branch &quot;MET&quot; and fill two different histograms with the &quot;pt\_v&quot; of</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment">the filtered events.</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment">By now, you should be able to easily understand what&#39;s happening:</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment">RDataFrame d(&quot;treeName&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment">auto h1 = d.Filter(&quot;MET &gt; 10&quot;).Histo1D(&quot;pt_v&quot;);</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment">auto h2 = d.Histo1D(&quot;pt_v&quot;);</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment">h1-&gt;Draw();       // event loop is run once here</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment">h2-&gt;Draw(&quot;SAME&quot;); // no need to run the event loop again</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="comment">`RDataFrame` executes all above actions by **running the event-loop only once**. The trick is that actions are not</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="comment">executed at the moment they are called, but they are **lazy**, i.e. delayed until the moment one of their results is</span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="comment">accessed through the smart pointer. At that time, the event loop is triggered and *all* results are produced</span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="comment">simultaneously.</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="comment">It is therefore good practice to declare all your transformations and actions *before* accessing their results, allowing</span></div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="comment">`RDataFrame` to run the loop once and produce all results in one go.</span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment">### Going parallel</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment">Let&#39;s say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores.</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment">The only modification required to the snippets would be the addition of this line *before* constructing the main</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment">data-frame object:</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment">ROOT::EnableImplicitMT();</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="comment">Simple as that. More details are given [below](#parallel-execution).</span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="comment">##  &lt;a name=&quot;more-features&quot;&gt;&lt;/a&gt;More features</span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="comment">Here is a list of the most important features that have been omitted in the &quot;Crash course&quot; for brevity.</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="comment">You don&#39;t need to read all these to start using `RDataFrame`, but they are useful to save typing time and runtime.</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment">### Programmatically get the list of column names</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="comment">The `GetColumnsNames()` method returns the list of valid column names for the dataset:</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="comment">RDataFrame d(&quot;myTree&quot;, &quot;file.root&quot;);</span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment">std::vector&lt;std::string&gt; colNames = d.GetColumnNames();</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="comment">### Reading and manipulating collections</span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="comment">When using RDataFrame to read data from a ROOT file, users can specify that the type of a branch is `RVec&lt;T&gt;`</span></div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="comment">to indicate the branch is a c-style array, a `std::vector` or any other collection type associated to a</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment">contiguous storage in memory.</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="comment">Column values of type `RVec&lt;T&gt;` perform no copy of the underlying array data</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="comment">and offer a rich interface to operate on the array elements in a vectorised fashion.</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="comment">The `RVec&lt;T&gt;` type signals to RDataFrame that a special behaviour needs to be adopted when snapshotting</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="comment">a dataset on disk. Indeed, if columns which are variable size C arrays are treated via the `RVec&lt;T&gt;`,</span></div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="comment">RDataFrame will correctly persistify them - if anything else is adopted, for example `std::span`, only</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="comment">the first element of the array will be written.</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">Learn more on [RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html).</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">### Callbacks</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment">It&#39;s possible to schedule execution of arbitrary functions (callbacks) during the event loop.</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment">Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment">drawing a partially-filled histogram every time a certain number of new entries is processed, or event</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment">displaying a progress bar while the event loop runs.</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment">For example one can draw an up-to-date version of a result histogram every 100 entries like this:</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment">auto h = tdf.Histo1D(&quot;x&quot;);</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment">TCanvas c(&quot;c&quot;,&quot;x hist&quot;);</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="comment">h.OnPartialResult(100, [&amp;c](TH1D &amp;h_) { c.cd(); h_.Draw(); c.Update(); });</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="comment">h-&gt;Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished</span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="comment">Callbacks are registered to a RResultPtr and must be callables that takes a reference to the result type as argument</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="comment">and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="comment">(e.g. a histogram filled with a part of the selected events).</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment">Read more on RResultPtr::OnPartialResult().</span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment">### Default branch lists</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment">When constructing a `RDataFrame` object, it is possible to specify a **default column list** for your analysis, in the</span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment">usual form of a list of strings representing branch/column names. The default column list will be used as a fallback</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment">whenever a list specific to the transformation/action is not present. RDataFrame will take as many of these columns as</span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="comment">needed, ignoring trailing extra names if present.</span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="comment">// use &quot;b1&quot; and &quot;b2&quot; as default branches</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="comment">RDataFrame d1(&quot;myTree&quot;, &quot;file.root&quot;, {&quot;b1&quot;,&quot;b2&quot;});</span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="comment">auto h = d1.Filter([](int b1, int b2) { return b1 &gt; b2; }) // will act on &quot;b1&quot; and &quot;b2&quot;</span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="comment">           .Histo1D(); // will act on &quot;b1&quot;</span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="comment">// just one default branch this time</span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">RDataFrame d2(&quot;myTree&quot;, &quot;file.root&quot;, {&quot;b1&quot;});</span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="comment">auto min = d2.Filter([](double b2) { return b2 &gt; 0; }, {&quot;b2&quot;}) // we can still specify non-default branch lists</span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="comment">             .Min(); // returns the minimum value of &quot;b1&quot; for the filtered entries</span></div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="comment">### &lt;a name=&quot;ImplicitColumns&quot;&gt;&lt;/a&gt; Implicit Columns</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="comment">Every instance of `RDataFrame` is created with two special columns called `rdfentry_` and `rdfslot_`. The `rdfentry_`</span></div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="comment">column is an unsigned 64-bit integer holding the current entry number while `rdfslot_` is an unsigned 32-bit integer</span></div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="comment">holding the index of the current data processing slot.</span></div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="comment">For backwards compatibility reasons, the names `tdfentry_` and `tdfslot_` are also accepted.</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="comment">These columns are not considered by operations such as [Cache](classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9)</span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment">or [Snapshot](classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8). The _cached_ or _snapshot_ data frame</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">provides &quot;its own&quot; values for these columns which do not necessarily correspond to the ones of the mother data frame. This is</span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment">most notably the case where filters are used before deriving a cached/persistified dataframe.</span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment">Note that in multi-thread event loops the values of `rdfentry_` _do not_ correspond to what would be the entry numbers</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment">of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order.</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">### Branch type guessing and explicit declaration of branch types</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">C++ is a statically typed language: all types must be known at compile-time. This includes the types of the `TTree`</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">branches we want to work on. For filters, temporary columns and some of the actions, **branch types are deduced from the</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="comment">signature** of the relevant filter function/temporary column expression/action function:</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="comment">// here b1 is deduced to be `int` and b2 to be `double`</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="comment">dataFrame.Filter([](int x, double y) { return x &gt; 0 &amp;&amp; y &lt; 0.; }, {&quot;b1&quot;, &quot;b2&quot;});</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="comment">If we specify an incorrect type for one of the branches, an exception with an informative message will be thrown at</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="comment">runtime, when the branch value is actually read from the `TTree`: `RDataFrame` detects type mismatches. The same would</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="comment">happen if we swapped the order of &quot;b1&quot; and &quot;b2&quot; in the branch list passed to `Filter`.</span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="comment">Certain actions, on the other hand, do not take a function as argument (e.g. `Histo1D`), so we cannot deduce the type of</span></div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="comment">the branch at compile-time. In this case **`RDataFrame` infers the type of the branch** from the `TTree` itself. This</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="comment">is why we never needed to specify the branch types for all actions in the above snippets.</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="comment">When the branch type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="comment">specify it as a template parameter to the action itself, like this:</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="comment">dataFrame.Histo1D(&quot;b1&quot;); // OK, the type of &quot;b1&quot; is deduced at runtime</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="comment">dataFrame.Min&lt;MyNumber_t&gt;(&quot;myObject&quot;); // OK, &quot;myObject&quot; is deduced to be of type `MyNumber_t`</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="comment">Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime</span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="comment">overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.</span></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="comment">### Generic actions</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="comment">`RDataFrame` strives to offer a comprehensive set of standard actions that can be performed on each event. At the same</span></div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment">time, it **allows users to execute arbitrary code (i.e. a generic action) inside the event loop** through the `Foreach`</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="comment">and `ForeachSlot` actions.</span></div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="comment">`Foreach(f, columnList)` takes a function `f` (lambda expression, free function, functor...) and a list of columns, and</span></div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="comment">executes `f` on those columns for each event. The function passed must return nothing (i.e. `void`). It can be used to</span></div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="comment">perform actions that are not already available in the interface. For example, the following snippet evaluates the root</span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment">mean square of column &quot;b&quot;:</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="comment">// Single-thread evaluation of RMS of column &quot;b&quot; using Foreach</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="comment">double sumSq = 0.;</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="comment">unsigned int n = 0;</span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="comment">RDataFrame d(&quot;bTree&quot;, bFilePtr);</span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="comment">d.Foreach([&amp;sumSq, &amp;n](double b) { ++n; sumSq += b*b; }, {&quot;b&quot;});</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="comment">std::cout &lt;&lt; &quot;rms of b: &quot; &lt;&lt; std::sqrt(sumSq / n) &lt;&lt; std::endl;</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="comment">When executing on multiple threads, users are responsible for the thread-safety of the expression passed to `Foreach`:</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="comment">each thread will execute the expression multiple times (once per entry) in an unspecified order.</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="comment">The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but</span></div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="comment">this is probably too much head-scratch for such a simple operation.</span></div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="comment">`ForeachSlot` can help in this situation. It is an alternative version of `Foreach` for which the function takes an</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="comment">additional parameter besides the columns it should be applied to: an `unsigned int slot` parameter, where `slot` is a</span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="comment">number indicating which thread (0, 1, 2 , ..., poolSize - 1) the function is being run in. More specifically, RDataFrame</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="comment">guarantees that `ForeachSlot` will invoke the user expression with different `slot` parameters for different concurrent</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="comment">executions (there is no guarantee that a certain slot number will always correspond to a given thread id, though).</span></div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">We can take advantage of `ForeachSlot` to evaluate a thread-safe root mean square of branch &quot;b&quot;:</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment">// Thread-safe evaluation of RMS of branch &quot;b&quot; using ForeachSlot</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">ROOT::EnableImplicitMT();</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment">const unsigned int nSlots = ROOT::GetImplicitMTPoolSize();</span></div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="comment">std::vector&lt;double&gt; sumSqs(nSlots, 0.);</span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="comment">std::vector&lt;unsigned int&gt; ns(nSlots, 0);</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="comment">RDataFrame d(&quot;bTree&quot;, bFilePtr);</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="comment">d.ForeachSlot([&amp;sumSqs, &amp;ns](unsigned int slot, double b) { sumSqs[slot] += b*b; ns[slot] += 1; }, {&quot;b&quot;});</span></div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="comment">double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares</span></div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="comment">unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts</span></div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="comment">std::cout &lt;&lt; &quot;rms of b: &quot; &lt;&lt; std::sqrt(sumSq / n) &lt;&lt; std::endl;</span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="comment">You see how we created one `double` variable for each thread in the pool, and later merged their results via</span></div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="comment">`std::accumulate`.</span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="comment">### Friend trees</span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="comment">Friend trees are supported by RDataFrame.</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="comment">In order to deal with friend trees with RDataFrame, the user is required to build</span></div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="comment">the tree and its friends and instantiate a RDataFrame with it.</span></div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="comment">TTree t([...]);</span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="comment">TTree ft([...]);</span></div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="comment">t.AddFriend(ft, &quot;myFriend&quot;);</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="comment">RDataFrame d(t);</span></div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="comment">auto f = d.Filter(&quot;myFriend.MyCol == 42&quot;);</span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="comment">### Reading file formats different from ROOT&#39;s</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="comment">RDataFrame can be interfaced with RDataSources. The RDataSource interface defines an API that RDataFrame can use to read arbitrary data formats.</span></div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="comment">A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="comment">methods) provides an adaptor that RDataFrame can leverage to read any kind of tabular data formats.</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="comment">RDataFrame calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or &quot;cursors&quot; for selected columns</span></div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="comment">and to advance the readers to the desired data entry.</span></div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="comment">Some predefined RDataSources are natively provided by ROOT such as the `RCsvDS` which allows to read comma separated files:</span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="comment">auto tdf = ROOT::RDF::MakeCsvDataFrame(&quot;MuRun2010B.csv&quot;);</span></div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="comment">auto filteredEvents =</span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="comment">   tdf.Filter(&quot;Q1 * Q2 == -1&quot;)</span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="comment">      .Define(&quot;m&quot;, &quot;sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))&quot;);</span></div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="comment">auto h = filteredEvents.Histo1D(&quot;m&quot;);</span></div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="comment">h-&gt;Draw();</span></div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment">### &lt;a name=&quot;callgraphs&quot;&gt;&lt;/a&gt;Call graphs (storing and reusing sets of transformations)</span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment">**Sets of transformations can be stored as variables** and reused multiple times to create **call graphs** in which</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">several paths of filtering/creation of columns are executed simultaneously; we often refer to this as &quot;storing the</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment">state of the chain&quot;.</span></div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="comment">This feature can be used, for example, to create a temporary column once and use it in several subsequent filters or</span></div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="comment">actions, or to apply a strict filter to the data-set *before* executing several other transformations and actions,</span></div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="comment">effectively reducing the amount of events processed.</span></div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="comment">Let&#39;s try to make this clearer with a commented example:</span></div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="comment">// build the data-frame and specify a default column list</span></div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="comment">RDataFrame d(treeName, filePtr, {&quot;var1&quot;, &quot;var2&quot;, &quot;var3&quot;});</span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="comment">// apply a cut and save the state of the chain</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="comment">auto filtered = d.Filter(myBigCut);</span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="comment">// plot branch &quot;var1&quot; at this point of the chain</span></div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="comment">auto h1 = filtered.Histo1D(&quot;var1&quot;);</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="comment">// create a new branch &quot;vec&quot; with a vector extracted from a complex object (only for filtered entries)</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="comment">// and save the state of the chain</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="comment">auto newBranchFiltered = filtered.Define(&quot;vec&quot;, [](const Obj&amp; o) { return o.getVector(); }, {&quot;obj&quot;});</span></div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment">// apply a cut and fill a histogram with &quot;vec&quot;</span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="comment">auto h2 = newBranchFiltered.Filter(cut1).Histo1D(&quot;vec&quot;);</span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="comment">// apply a different cut and fill a new histogram</span></div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="comment">auto h3 = newBranchFiltered.Filter(cut2).Histo1D(&quot;vec&quot;);</span></div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="comment">// Inspect results</span></div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="comment">h2-&gt;Draw(); // first access to an action result: run event-loop!</span></div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="comment">h3-&gt;Draw(&quot;SAME&quot;); // event loop does not need to be run again here..</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="comment">std::cout &lt;&lt; &quot;Entries in h1: &quot; &lt;&lt; h1-&gt;GetEntries() &lt;&lt; std::endl; // ..or here</span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="comment">`RDataFrame` detects when several actions use the same filter or the same temporary column, and **only evaluates each</span></div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="comment">filter or temporary column once per event**, regardless of how many times that result is used down the call graph.</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="comment">Objects read from each column are **built once and never copied**, for maximum efficiency.</span></div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="comment">When &quot;upstream&quot; filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated,</span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="comment">so it might be advisable to put the strictest filters first in the chain.</span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="comment">### &lt;a name=&quot;representgraph&quot;&gt;&lt;/a&gt;Printing the computation graph</span></div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="comment">It is possible to print the computation graph from any node to obtain a dot representation either on the standard output</span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="comment">or in a file.</span></div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="comment">Invoking the function ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment">the node belongs to is printed. By using the head node, the entire computation graph is printed.</span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="comment">Following there is an example of usage:</span></div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="comment">// First, a sample computational graph is built</span></div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="comment">ROOT::RDataFrame df(&quot;tree&quot;, &quot;f.root&quot;);</span></div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="comment">auto df2 = df.Define(&quot;x&quot;, []() { return 1; })</span></div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="comment">             .Filter(&quot;col0 % 1 == col0&quot;)</span></div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="comment">             .Filter([](int b1) { return b1 &lt;2; }, {&quot;cut1&quot;})</span></div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="comment">             .Define(&quot;y&quot;, []() { return 1; });</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="comment">auto count =  df2.Count();</span></div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="comment">// Prints the graph to the rd1.dot file in the current directory</span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="comment">ROOT::RDF::SaveGraph(rd1, &quot;./mydot.dot&quot;);</span></div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="comment">// Prints the graph to standard output</span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="comment">ROOT::RDF::SaveGraph(rd1);</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="comment">### RDataFrame variables as function arguments and return values</span></div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="comment">RDataFrame variables/nodes are relatively cheap to copy and it&#39;s possible to both pass them to (or move them into)</span></div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="comment">functions and to return them from functions. However, in general each dataframe node will have a different C++ type,</span></div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="comment">which includes all available compile-time information about what that node does. One way to cope with this complication</span></div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="comment">is to use template functions and/or C++14 auto return types:</span></div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="comment">template &lt;typename RDF&gt;</span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="comment">auto ApplySomeFilters(RDF df)</span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="comment">{</span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="comment">   return df.Filter(&quot;x &gt; 0&quot;).Filter([](int y) { return y &lt; 0; }, {&quot;y&quot;});</span></div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="comment">}</span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="comment">A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be</span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="comment">converted to the common type ROOT::RDF::RNode:</span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="comment">// a function that conditionally adds a Range to a RDataFrame node.</span></div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;<span class="comment">RNode MaybeAddRange(RNode df, bool mustAddRange)</span></div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="comment">{</span></div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="comment">   return mustAddRange ? df.Range(1) : df;</span></div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="comment">}</span></div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="comment">// use as :</span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="comment">ROOT::RDataFrame df(10);</span></div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="comment">auto maybeRangedDF = MaybeAddRange(df, true);</span></div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="comment">The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event </span></div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="comment">loop (in most cases, the resulting performance impact should be negligible).</span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="comment">As a final note, remember that RDataFrame actions do not return another dataframe, but a RResultPtr&lt;T&gt;, where T is the</span></div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="comment">type of the result of the action.</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="comment">Read more on this topic [here](https://root.cern.ch/doc/master/classROOT_1_1RDF_1_1RInterface.html#a6909f04c05723de79f97a14b092318b1).</span></div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="comment">##  &lt;a name=&quot;transformations&quot;&gt;&lt;/a&gt;Transformations</span></div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="comment">### &lt;a name=&quot;Filters&quot;&gt;&lt;/a&gt; Filters</span></div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="comment">A filter is defined through a call to `Filter(f, columnList)`. `f` can be a function, a lambda expression, a functor</span></div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="comment">class, or any other callable object. It must return a `bool` signalling whether the event has passed the selection</span></div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="comment">(`true`) or not (`false`). It must perform &quot;read-only&quot; actions on the columns, and should not have side-effects (e.g.</span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;<span class="comment">modification of an external or static variable) to ensure correct results when implicit multi-threading is active.</span></div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;<span class="comment">`RDataFrame` only evaluates filters when necessary: if multiple filters are chained one after another, they are executed</span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;<span class="comment">in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next</span></div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;<span class="comment">entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for</span></div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;<span class="comment">each entry: after the first access it simply serves a cached result.</span></div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="comment">#### &lt;a name=&quot;named-filters-and-cutflow-reports&quot;&gt;&lt;/a&gt;Named filters and cutflow reports</span></div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;<span class="comment">An optional string parameter `name` can be passed to the `Filter` method to create a **named filter**. Named filters</span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="comment">work as usual, but also keep track of how many entries they accept and reject.</span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="comment">Statistics are retrieved through a call to the `Report` method:</span></div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="comment">- when `Report` is called on the main `RDataFrame` object, it returns a RResultPtr&lt;RCutFlowReport&gt; relative to all</span></div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;<span class="comment">named filters declared up to that point</span></div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="comment">- when called on a specific node (e.g. the result of a `Define` or `Filter`), it returns a RResultPtr&lt;RCutFlowReport&gt;</span></div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="comment">relative all named filters in the section of the chain between the main `RDataFrame` and that node (included).</span></div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="comment">Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*</span></div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;<span class="comment">that has been run using the relevant `RDataFrame`.</span></div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;<span class="comment">### &lt;a name=&quot;ranges&quot;&gt;&lt;/a&gt;Ranges</span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<span class="comment">When `RDataFrame` is not being used in a multi-thread environment (i.e. no call to `EnableImplicitMT` was made),</span></div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="comment">`Range` transformations are available. These act very much like filters but instead of basing their decision on</span></div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="comment">a filter expression, they rely on `begin`,`end` and `stride` parameters.</span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="comment">- `begin`: initial entry number considered for this range.</span></div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="comment">- `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.</span></div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="comment">- `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.</span></div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;<span class="comment">The actual number of entries processed downstream of a `Range` node will be `(end - begin)/stride` (or less if less</span></div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;<span class="comment">entries than that are available).</span></div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="comment">Note that ranges act &quot;locally&quot;, not based on the global entry count: `Range(10,50)` means &quot;skip the first 10 entries</span></div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;<span class="comment">*that reach this node*, let the next 40 entries pass, then stop processing&quot;. If a range node hangs from a filter node,</span></div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="comment">and the range has a `begin` parameter of 10, that means the range will skip the first 10 entries *that pass the</span></div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;<span class="comment">preceding filter*.</span></div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="comment">Ranges allow &quot;early quitting&quot;: if all branches of execution of a functional graph reached their `end` value of</span></div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="comment">processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations.</span></div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;<span class="comment">### &lt;a name=&quot;custom-columns&quot;&gt;&lt;/a&gt; Custom columns</span></div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="comment">Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object</span></div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;<span class="comment">(function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of</span></div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="comment">strings) as parameters, in the same order as they are listed in `columnList`. `f` must return the value that will be</span></div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;<span class="comment">assigned to the temporary column.</span></div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="comment">A new variable is created called `name`, accessible as if it was contained in the dataset from subsequent</span></div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;<span class="comment">transformations/actions.</span></div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;<span class="comment">Use cases include:</span></div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;<span class="comment">- caching the results of complex calculations for easy and efficient multiple access</span></div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="comment">- extraction of quantities of interest from complex objects</span></div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;<span class="comment">- branch aliasing, i.e. changing the name of a branch</span></div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;<span class="comment">An exception is thrown if the `name` of the new column/branch is already in use for another branch in the `TTree`.</span></div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="comment">It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method</span></div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="comment">`Define(name, expression)`. For example this invocation</span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;<span class="comment">~~~{.cpp}</span></div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="comment">tdf.Define(&quot;pt&quot;, &quot;sqrt(px*px + py*py)&quot;);</span></div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="comment">~~~</span></div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="comment">will create a new column called &quot;pt&quot; the value of which is calculated starting from the columns px and py. The system</span></div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="comment">builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches</span></div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="comment">from the names of the variables specified by the user.</span></div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="comment">#### Custom columns as function of slot and entry number</span></div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="comment">It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can</span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="comment">be invoked are:</span></div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="comment">- `DefineSlot(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, T1, T2, ...)`: the</span></div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;<span class="comment">first parameter is the slot number which ranges from 0 to ROOT::GetImplicitMTPoolSize() - 1.</span></div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;<span class="comment">- `DefineSlotEntry(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, ULong64_t,</span></div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;<span class="comment">T1, T2, ...)`: the first parameter is the slot number while the second one the number of the entry being processed.</span></div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="comment">##  &lt;a name=&quot;actions&quot;&gt;&lt;/a&gt;Actions</span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="comment">### Instant and lazy actions</span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;<span class="comment">Actions can be **instant** or **lazy**. Instant actions are executed as soon as they are called, while lazy actions are</span></div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;<span class="comment">executed whenever the object they return is accessed for the first time. As a rule of thumb, actions with a return value</span></div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="comment">are lazy, the others are instant.</span></div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="comment">##  &lt;a name=&quot;parallel-execution&quot;&gt;&lt;/a&gt;Parallel execution</span></div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="comment">As pointed out before in this document, `RDataFrame` can transparently perform multi-threaded event loops to speed up</span></div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;<span class="comment">the execution of its actions. Users have to call `ROOT::EnableImplicitMT()` *before* constructing the `RDataFrame`</span></div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;<span class="comment">object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct</span></div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="comment">subset of entries**, and their partial results are merged before returning the final values to the user.</span></div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="comment">More specifically, the dataset will be divided in batches of entries, and threads will divide among themselves the</span></div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;<span class="comment">processing of these batches. There are no guarantees on the order the batches are processed, i.e. no guarantees in the</span></div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;<span class="comment">order entries of the dataset are processed. Note that this in turn means that, for multi-thread event loops, there is no</span></div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;<span class="comment">guarantee on the order in which `Snapshot` will _write_ entries: they could be scrambled with respect to the input dataset.</span></div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;<span class="comment">### Thread-safety of user-defined expressions</span></div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;<span class="comment">RDataFrame operations such as `Histo1D` or `Snapshot` are guaranteed to work correctly in multi-thread event loops.</span></div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;<span class="comment">User-defined expressions, such as strings or lambdas passed to `Filter`, `Define`, `Foreach`, `Reduce` or `Aggregate`</span></div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;<span class="comment">will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.</span></div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;<span class="comment">Note that simple `Filter` and `Define` transformations will inherently satisfy this requirement: `Filter`/`Define`</span></div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;<span class="comment">expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),</span></div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;<span class="comment">which eliminates all risks of race conditions.</span></div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="comment">In order to facilitate writing of thread-safe operations, some RDataFrame features such as `Foreach`, `Define` or `OnPartialResult`</span></div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;<span class="comment">offer thread-aware counterparts (`ForeachSlot`, `DefineSlot`, `OnPartialResultSlot`): their only difference is that they</span></div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="comment">will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code</span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="comment">concurrently, `RDataFrame` guarantees that different threads will employ different values of the `slot` parameter,</span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="comment">where `slot` will be a number between 0 and `ROOT::GetImplicitMTPoolSize() - 1`.</span></div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="comment">In other words, within a slot, computation runs sequentially and events are processed sequentially.</span></div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="comment">Note that the same slot might be associated to different threads over the course of a single event loop, but two threads</span></div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="comment">will never receive the same slot at the same time.</span></div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="comment">This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different</span></div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="comment">*processing slot*, e.g. a different element of a list. See [here](#generic-actions) for an example usage of `ForeachSlot`.</span></div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;<span class="comment">&lt;a name=&quot;reference&quot;&gt;&lt;/a&gt;</span></div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="comment">// clang-format on</span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceROOT.html">ROOT</a> {</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="keyword">namespace </span>Detail {</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="keyword">namespace </span>RDF {</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;<span class="keyword">class </span>RCustomColumnBase;</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;}</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;} <span class="comment">// namespace Detail</span></div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;</div><div class="line"><a name="l00788"></a><span class="lineno"><a class="line" href="namespaceROOT.html#a73d76a9e8633d9e5f26d7f7aad7da94a">  788</a></span>&#160;<span class="keyword">using</span> <a class="code" href="namespaceROOT.html#a73d76a9e8633d9e5f26d7f7aad7da94a">ColumnNames_t</a> = <a class="code" href="namespaceROOT.html#a73d76a9e8633d9e5f26d7f7aad7da94a">ROOT::Detail::RDF::ColumnNames_t</a>;</div><div class="line"><a name="l00789"></a><span class="lineno"><a class="line" href="namespaceROOT.html#a85f93d3c1a63fd8a19edef3bc6262217">  789</a></span>&#160;<span class="keyword">using</span> <a class="code" href="namespaceROOT.html#a85f93d3c1a63fd8a19edef3bc6262217">ColumnNamesPtr_t</a> = std::shared_ptr&lt;const ColumnNames_t&gt;;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceROOT_1_1Internal_1_1RDF.html">RDFInternal</a> = <a class="code" href="namespaceROOT_1_1Internal_1_1RDF.html">ROOT::Internal::RDF</a>;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;<span class="comment">////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;<span class="comment">/// \brief Build the dataframe</span></div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;<span class="comment">/// \param[in] treeName Name of the tree contained in the directory</span></div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;<span class="comment">/// \param[in] dirPtr TDirectory where the tree is stored, e.g. a TFile.</span></div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;<span class="comment">/// \param[in] defaultBranches Collection of default branches.</span></div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;<span class="comment">/// The default branches are looked at in case no branch is specified in the</span></div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;<span class="comment">/// booking of actions or transformations.</span></div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;<span class="comment">/// See RInterface for the documentation of the methods available.</span></div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;<span class="comment"></span><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame::RDataFrame</a>(std::string_view treeName, <a class="code" href="classTDirectory.html">TDirectory</a> *dirPtr, <span class="keyword">const</span> <a class="code" href="namespaceROOT.html#a73d76a9e8633d9e5f26d7f7aad7da94a">ColumnNames_t</a> &amp;defaultBranches)</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;   : RInterface(<a class="code" href="namespacestd.html">std</a>::make_shared&lt;<a class="code" href="namespaceROOT_1_1Detail_1_1RDF.html">RDFDetail</a>::RLoopManager&gt;(nullptr, defaultBranches))</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;{</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;   <span class="keywordflow">if</span> (!dirPtr) {</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;      <span class="keyword">auto</span> msg = <span class="stringliteral">&quot;Invalid TDirectory!&quot;</span>;</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;      <span class="keywordflow">throw</span> std::runtime_error(msg);</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;   }</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;   <span class="keyword">const</span> std::string treeNameInt(treeName);</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;   <span class="keyword">auto</span> <a class="code" href="namespacetree.html">tree</a> = <span class="keyword">static_cast&lt;</span><a class="code" href="classTTree.html">TTree</a> *<span class="keyword">&gt;</span>(dirPtr-&gt;<a class="code" href="classTDirectory.html#a411338189331c0ec67b2c56822b7773a">Get</a>(treeNameInt.c_str()));</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;   <span class="keywordflow">if</span> (!<a class="code" href="namespacetree.html">tree</a>) {</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;      <span class="keyword">auto</span> msg = <span class="stringliteral">&quot;Tree \&quot;&quot;</span> + treeNameInt + <span class="stringliteral">&quot;\&quot; cannot be found!&quot;</span>;</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;      <span class="keywordflow">throw</span> std::runtime_error(msg);</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;   }</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;   GetProxiedPtr()-&gt;SetTree(std::shared_ptr&lt;TTree&gt;(<a class="code" href="namespacetree.html">tree</a>, [](<a class="code" href="classTTree.html">TTree</a> *) {}));</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;}</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="comment">////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="comment">/// \brief Build the dataframe</span></div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;<span class="comment">/// \param[in] treeName Name of the tree contained in the directory</span></div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;<span class="comment">/// \param[in] filenameglob TDirectory where the tree is stored, e.g. a TFile.</span></div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;<span class="comment">/// \param[in] defaultBranches Collection of default branches.</span></div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<span class="comment">/// The filename globbing supports the same type of expressions as TChain::Add().</span></div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="comment">/// The default branches are looked at in case no branch is specified in the</span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;<span class="comment">/// booking of actions or transformations.</span></div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="comment">/// See RInterface for the documentation of the methods available.</span></div><div class="line"><a name="l00828"></a><span class="lineno"><a class="line" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">  828</a></span>&#160;<span class="comment"></span>RDataFrame::RDataFrame(std::string_view treeName, std::string_view filenameglob, <span class="keyword">const</span> <a class="code" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;defaultBranches)</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;   : RInterface(<a class="code" href="namespacestd.html">std</a>::make_shared&lt;<a class="code" href="namespaceROOT_1_1Detail_1_1RDF.html">RDFDetail</a>::<a class="code" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RLoopManager</a>&gt;(nullptr, defaultBranches))</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;{</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;   <span class="keyword">const</span> std::string treeNameInt(treeName);</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;   <span class="keyword">const</span> std::string filenameglobInt(filenameglob);</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;   <span class="keyword">auto</span> chain = std::make_shared&lt;TChain&gt;(treeNameInt.c_str());</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;   chain-&gt;Add(filenameglobInt.c_str());</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;   <a class="code" href="classROOT_1_1RDF_1_1RInterface.html#aafbc83aa8c2589aba0525c17a46ae44c">GetProxiedPtr</a>()-&gt;SetTree(chain);</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;}</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="comment">////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="comment">/// \brief Build the dataframe</span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="comment">/// \param[in] treeName Name of the tree contained in the directory</span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="comment">/// \param[in] fileglobs Collection of file names of filename globs</span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="comment">/// \param[in] defaultBranches Collection of default branches.</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="comment">/// The filename globbing supports the same type of expressions as TChain::Add().</span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="comment">/// The default branches are looked at in case no branch is specified in the booking of actions or transformations.</span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="comment">/// See RInterface for the documentation of the methods available.</span></div><div class="line"><a name="l00847"></a><span class="lineno"><a class="line" href="classROOT_1_1RDataFrame.html#adcebb79c00694365296d054626e87742">  847</a></span>&#160;<span class="comment"></span><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame::RDataFrame</a>(std::string_view treeName, <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;fileglobs,</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                       <span class="keyword">const</span> <a class="code" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;defaultBranches)</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;   : RInterface(<a class="code" href="namespacestd.html">std</a>::make_shared&lt;<a class="code" href="namespaceROOT_1_1Detail_1_1RDF.html">RDFDetail</a>::<a class="code" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RLoopManager</a>&gt;(nullptr, defaultBranches))</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;{</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;   std::string treeNameInt(treeName);</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;   <span class="keyword">auto</span> chain = std::make_shared&lt;TChain&gt;(treeNameInt.c_str());</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;   <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a> : fileglobs)</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;      chain-&gt;Add(<a class="code" href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a>.c_str());</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;   <a class="code" href="classROOT_1_1RDF_1_1RInterface.html#aafbc83aa8c2589aba0525c17a46ae44c">GetProxiedPtr</a>()-&gt;SetTree(chain);</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;}</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;<span class="comment">////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;<span class="comment">/// \brief Build the dataframe</span></div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="comment">/// \param[in] tree The tree or chain to be studied.</span></div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;<span class="comment">/// \param[in] defaultBranches Collection of default column names to fall back to when none is specified.</span></div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;<span class="comment">/// The default branches are looked at in case no branch is specified in the</span></div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="comment">/// booking of actions or transformations.</span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="comment">/// See RInterface for the documentation of the methods available.</span></div><div class="line"><a name="l00866"></a><span class="lineno"><a class="line" href="classROOT_1_1RDataFrame.html#a6a45ce7601ffbca837f6773cd55a3e72">  866</a></span>&#160;<span class="comment"></span><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame::RDataFrame</a>(<a class="code" href="classTTree.html">TTree</a> &amp;<a class="code" href="namespacetree.html">tree</a>, <span class="keyword">const</span> <a class="code" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;defaultBranches)</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;   : RInterface(<a class="code" href="namespacestd.html">std</a>::make_shared&lt;<a class="code" href="namespaceROOT_1_1Detail_1_1RDF.html">RDFDetail</a>::<a class="code" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RLoopManager</a>&gt;(&amp;<a class="code" href="namespacetree.html">tree</a>, defaultBranches))</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;{</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;}</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="comment">//////////////////////////////////////////////////////////////////////////</span></div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;<span class="comment">/// \brief Build a dataframe that generates numEntries entries.</span></div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="comment">/// \param[in] numEntries The number of entries to generate.</span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;<span class="comment">/// An empty-source dataframe constructed with a number of entries will</span></div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="comment">/// generate those entries on the fly when some action is triggered,</span></div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="comment">/// and it will do so for all the previously-defined temporary branches.</span></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="comment">/// See RInterface for the documentation of the methods available.</span></div><div class="line"><a name="l00879"></a><span class="lineno"><a class="line" href="classROOT_1_1RDataFrame.html#a90daba6a8ab4a0590e12d5eda3b1aec7">  879</a></span>&#160;<span class="comment"></span><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame::RDataFrame</a>(<a class="code" href="RtypesCore_8h.html#aec5c78ee1411360ee0f2dc942f475c63">ULong64_t</a> numEntries)</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;   : RInterface(<a class="code" href="namespacestd.html">std</a>::make_shared&lt;<a class="code" href="namespaceROOT_1_1Detail_1_1RDF.html">RDFDetail</a>::<a class="code" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RLoopManager</a>&gt;(numEntries))</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;{</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;}</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="comment">//////////////////////////////////////////////////////////////////////////</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="comment">/// \brief Build dataframe associated to datasource.</span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="comment">/// \param[in] ds The data-source object.</span></div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="comment">/// \param[in] defaultBranches Collection of default column names to fall back to when none is specified.</span></div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;<span class="comment">/// A dataframe associated to a datasource will query it to access column values.</span></div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;<span class="comment">/// See RInterface for the documentation of the methods available.</span></div><div class="line"><a name="l00892"></a><span class="lineno"><a class="line" href="classROOT_1_1RDataFrame.html#a1644efe41e76c2cdb9a6bc9ade8b9d0c">  892</a></span>&#160;<span class="comment"></span><a class="code" href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">RDataFrame::RDataFrame</a>(std::unique_ptr&lt;ROOT::RDF::RDataSource&gt; ds, <span class="keyword">const</span> <a class="code" href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ColumnNames_t</a> &amp;defaultBranches)</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;   : RInterface(<a class="code" href="namespacestd.html">std</a>::make_shared&lt;<a class="code" href="namespaceROOT_1_1Detail_1_1RDF.html">RDFDetail</a>::<a class="code" href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">RLoopManager</a>&gt;(<a class="code" href="namespacestd.html">std</a>::move(ds), defaultBranches))</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;{</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;}</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;} <span class="comment">// namespace ROOT</span></div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacecling.html">cling</a> {<span class="comment"></span></div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="comment">//////////////////////////////////////////////////////////////////////////</span></div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="comment">/// Print a RDataFrame at the prompt</span></div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;<span class="comment"></span>std::string printValue(<a class="code" href="classROOT_1_1RDataFrame.html">ROOT::RDataFrame</a> *tdf)</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;{</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;   <span class="keyword">auto</span> &amp;df = *tdf-&gt;<a class="code" href="classROOT_1_1RDF_1_1RInterface.html#a44a7516adcf1c64c08b1b59b8eddba5d">GetLoopManager</a>();</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;   <span class="keyword">auto</span> *<a class="code" href="namespacetree.html">tree</a> = df.GetTree();</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;   <span class="keyword">auto</span> defBranches = df.GetDefaultColumnNames();</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;   std::ostringstream ret;</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;   <span class="keywordflow">if</span> (<a class="code" href="namespacetree.html">tree</a>) {</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;      ret &lt;&lt; <span class="stringliteral">&quot;A data frame built on top of the &quot;</span> &lt;&lt; <a class="code" href="namespacetree.html">tree</a>-&gt;GetName() &lt;&lt; <span class="stringliteral">&quot; dataset.&quot;</span>;</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;      <span class="keywordflow">if</span> (!defBranches.empty()) {</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;         <span class="keywordflow">if</span> (defBranches.size() == 1)</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;            ret &lt;&lt; <span class="stringliteral">&quot;\nDefault branch: &quot;</span> &lt;&lt; defBranches[0];</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;         <span class="keywordflow">else</span> {</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;            ret &lt;&lt; <span class="stringliteral">&quot;\nDefault branches:\n&quot;</span>;</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;branch : defBranches) {</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;               ret &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; branch &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;            }</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;         }</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;      }</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> ds = tdf-&gt;fDataSource) {</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;      ret &lt;&lt; <span class="stringliteral">&quot;A data frame associated to the data source \&quot;&quot;</span> &lt;&lt; cling::printValue(ds) &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;   } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;      ret &lt;&lt; <span class="stringliteral">&quot;An empty data frame that will create &quot;</span> &lt;&lt; df.GetNEmptyEntries() &lt;&lt; <span class="stringliteral">&quot; entries\n&quot;</span>;</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;   }</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;   <span class="keywordflow">return</span> ret.str();</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;}</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;} <span class="comment">// namespace cling</span></div><div class="ttc" id="classROOT_1_1Detail_1_1RDF_1_1RLoopManager_html"><div class="ttname"><a href="classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html">ROOT::Detail::RDF::RLoopManager</a></div><div class="ttdoc">The head node of a RDF computation graph. </div><div class="ttdef"><b>Definition:</b> <a href="RLoopManager_8hxx_source.html#l00056">RLoopManager.hxx:56</a></div></div>
<div class="ttc" id="namespaceROOT_html"><div class="ttname"><a href="namespaceROOT.html">ROOT</a></div><div class="ttdoc">Namespace for new ROOT classes and functions. </div><div class="ttdef"><b>Definition:</b> <a href="StringConv_8hxx_source.html#l00021">StringConv.hxx:21</a></div></div>
<div class="ttc" id="classTDirectory_html_a411338189331c0ec67b2c56822b7773a"><div class="ttname"><a href="classTDirectory.html#a411338189331c0ec67b2c56822b7773a">TDirectory::Get</a></div><div class="ttdeci">virtual TObject * Get(const char *namecycle)</div><div class="ttdoc">Return pointer to object identified by namecycle. </div><div class="ttdef"><b>Definition:</b> <a href="TDirectory_8cxx_source.html#l00805">TDirectory.cxx:805</a></div></div>
<div class="ttc" id="RSha256_8hxx_html_a357394e0f6f88c8a57bd893ab28dc8f8"><div class="ttname"><a href="RSha256_8hxx.html#a357394e0f6f88c8a57bd893ab28dc8f8">f</a></div><div class="ttdeci">#define f(i)</div><div class="ttdef"><b>Definition:</b> <a href="RSha256_8hxx_source.html#l00104">RSha256.hxx:104</a></div></div>
<div class="ttc" id="namespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace. </div></div>
<div class="ttc" id="RDataSource_8hxx_html"><div class="ttname"><a href="RDataSource_8hxx.html">RDataSource.hxx</a></div></div>
<div class="ttc" id="TDirectory_8h_html"><div class="ttname"><a href="TDirectory_8h.html">TDirectory.h</a></div></div>
<div class="ttc" id="TChain_8h_html"><div class="ttname"><a href="TChain_8h.html">TChain.h</a></div></div>
<div class="ttc" id="classROOT_1_1RDataFrame_html"><div class="ttname"><a href="classROOT_1_1RDataFrame.html">ROOT::RDataFrame</a></div><div class="ttdoc"> ROOT&amp;#39;s RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV&amp;#39;s and other data formats. </div><div class="ttdef"><b>Definition:</b> <a href="RDataFrame_8hxx_source.html#l00042">RDataFrame.hxx:42</a></div></div>
<div class="ttc" id="classROOT_1_1RDF_1_1RInterface_html_aafbc83aa8c2589aba0525c17a46ae44c"><div class="ttname"><a href="classROOT_1_1RDF_1_1RInterface.html#aafbc83aa8c2589aba0525c17a46ae44c">ROOT::RDF::RInterface&lt; RDFDetail::RLoopManager &gt;::GetProxiedPtr</a></div><div class="ttdeci">const std::shared_ptr&lt; RDFDetail::RLoopManager &gt; &amp; GetProxiedPtr() const</div><div class="ttdef"><b>Definition:</b> <a href="RInterface_8hxx_source.html#l02489">RInterface.hxx:2489</a></div></div>
<div class="ttc" id="namespaceROOT_1_1Internal_1_1RDF_html"><div class="ttname"><a href="namespaceROOT_1_1Internal_1_1RDF.html">ROOT::Internal::RDF</a></div><div class="ttdef"><b>Definition:</b> <a href="RArrowDS_8hxx_source.html#l00015">RArrowDS.hxx:15</a></div></div>
<div class="ttc" id="namespaceROOT_1_1Detail_1_1RDF_html"><div class="ttname"><a href="namespaceROOT_1_1Detail_1_1RDF.html">ROOT::Detail::RDF</a></div><div class="ttdef"><b>Definition:</b> <a href="GraphUtils_8hxx_source.html#l00028">GraphUtils.hxx:28</a></div></div>
<div class="ttc" id="classTDirectory_html"><div class="ttname"><a href="classTDirectory.html">TDirectory</a></div><div class="ttdoc">Describe directory structure in memory. </div><div class="ttdef"><b>Definition:</b> <a href="TDirectory_8h_source.html#l00034">TDirectory.h:34</a></div></div>
<div class="ttc" id="RtypesCore_8h_html_aec5c78ee1411360ee0f2dc942f475c63"><div class="ttname"><a href="RtypesCore_8h.html#aec5c78ee1411360ee0f2dc942f475c63">ULong64_t</a></div><div class="ttdeci">unsigned long long ULong64_t</div><div class="ttdef"><b>Definition:</b> <a href="RtypesCore_8h_source.html#l00070">RtypesCore.h:70</a></div></div>
<div class="ttc" id="namespacecling_html"><div class="ttname"><a href="namespacecling.html">cling</a></div><div class="ttdoc">Print a TSeq at the prompt: </div><div class="ttdef"><b>Definition:</b> <a href="TDatime_8h_source.html#l00115">TDatime.h:115</a></div></div>
<div class="ttc" id="classROOT_1_1RDataFrame_html_a0813d17002d46c962513acb96ddc8d57"><div class="ttname"><a href="classROOT_1_1RDataFrame.html#a0813d17002d46c962513acb96ddc8d57">ROOT::RDataFrame::RDataFrame</a></div><div class="ttdeci">RDataFrame(std::string_view treeName, std::string_view filenameglob, const ColumnNames_t &amp;defaultBranches={})</div><div class="ttdoc">Build the dataframe. </div><div class="ttdef"><b>Definition:</b> <a href="RDataFrame_8cxx_source.html#l00828">RDataFrame.cxx:828</a></div></div>
<div class="ttc" id="classROOT_1_1RDF_1_1RInterface_html_a44a7516adcf1c64c08b1b59b8eddba5d"><div class="ttname"><a href="classROOT_1_1RDF_1_1RInterface.html#a44a7516adcf1c64c08b1b59b8eddba5d">ROOT::RDF::RInterface::GetLoopManager</a></div><div class="ttdeci">RLoopManager * GetLoopManager() const</div><div class="ttdef"><b>Definition:</b> <a href="RInterface_8hxx_source.html#l02487">RInterface.hxx:2487</a></div></div>
<div class="ttc" id="RDataFrame_8hxx_html"><div class="ttname"><a href="RDataFrame_8hxx.html">RDataFrame.hxx</a></div></div>
<div class="ttc" id="namespaceROOT_html_a85f93d3c1a63fd8a19edef3bc6262217"><div class="ttname"><a href="namespaceROOT.html#a85f93d3c1a63fd8a19edef3bc6262217">ROOT::ColumnNamesPtr_t</a></div><div class="ttdeci">std::shared_ptr&lt; const ColumnNames_t &gt; ColumnNamesPtr_t</div><div class="ttdef"><b>Definition:</b> <a href="RDataFrame_8cxx_source.html#l00789">RDataFrame.cxx:789</a></div></div>
<div class="ttc" id="namespacetree_html"><div class="ttname"><a href="namespacetree.html">tree</a></div><div class="ttdef"><b>Definition:</b> <a href="tree_8py_source.html#l00001">tree.py:1</a></div></div>
<div class="ttc" id="classTTree_html"><div class="ttname"><a href="classTTree.html">TTree</a></div><div class="ttdoc">A TTree represents a columnar dataset. </div><div class="ttdef"><b>Definition:</b> <a href="TTree_8h_source.html#l00071">TTree.h:71</a></div></div>
<div class="ttc" id="classROOT_1_1RDataFrame_html_a149222c853bd18aceace5e86a0ac02ff"><div class="ttname"><a href="classROOT_1_1RDataFrame.html#a149222c853bd18aceace5e86a0ac02ff">ROOT::RDataFrame::ColumnNames_t</a></div><div class="ttdeci">RDFDetail::ColumnNames_t ColumnNames_t</div><div class="ttdef"><b>Definition:</b> <a href="RDataFrame_8hxx_source.html#l00044">RDataFrame.hxx:44</a></div></div>
<div class="ttc" id="namespaceROOT_html_a73d76a9e8633d9e5f26d7f7aad7da94a"><div class="ttname"><a href="namespaceROOT.html#a73d76a9e8633d9e5f26d7f7aad7da94a">ROOT::ColumnNames_t</a></div><div class="ttdeci">ROOT::Detail::RDF::ColumnNames_t ColumnNames_t</div><div class="ttdef"><b>Definition:</b> <a href="RDataFrame_8cxx_source.html#l00788">RDataFrame.cxx:788</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:09:48 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
