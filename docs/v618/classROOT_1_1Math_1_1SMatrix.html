<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>ROOT: ROOT::Math::SMatrix&lt; T, D1, D2, R &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ROOT.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="0">
  <tr>
    <td> <img style="height:90px" alt="Logo" src="rootlogo.gif"/> </td>
    <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">ROOT</font> &#160; 6.18/03 <br> Reference Guide </td>
    <td style="width:100%"> </td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceROOT.html">ROOT</a></li><li class="navelem"><a class="el" href="namespaceROOT_1_1Math.html">Math</a></li><li class="navelem"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classROOT_1_1Math_1_1SMatrix-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="classROOT_1_1Math_1_1SMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ROOT::Math::SMatrix&lt; T, D1, D2, R &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Math.html">Math</a> &raquo; <a class="el" href="group__SMatrixGroup.html">SMatrix</a> &raquo; <a class="el" href="group__SMatrixSVector.html">Matrix and Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<div class="textblock"><h3>template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt;<br />
class ROOT::Math::SMatrix&lt; T, D1, D2, R &gt;</h3>

<p><a class="el" href="classROOT_1_1Math_1_1SMatrix.html" title="SMatrix: a generic fixed size D1 x D2 Matrix class. ">SMatrix</a>: a generic fixed size D1 x D2 Matrix class. </p>
<p>The class is template on the scalar type, on the matrix sizes: D1 = number of rows and D2 = number of columns amd on the representation storage type. By default the representation is MatRepStd&lt;T,D1,D2&gt; (standard D1xD2 of type T), but it can be of type MatRepSym&lt;T,D&gt; for symmetric matrices DxD, where the storage is only D*(D+1)/2.</p>
<p>See <a class="el" href="SMatrixDoc.html">SMatrix Class Properties</a>.</p>
<p>Original author is Thorsten Glebe HERA-B Collaboration, MPI Heidelberg (Germany)</p>
<dl class="section author"><dt>Authors</dt><dd>T. Glebe, L. Moneta and J. Palacios </dd></dl>

<p class="definition">Definition at line <a class="el" href="BinaryOperators_8h_source.html#l00031">31</a> of file <a class="el" href="BinaryOperators_8h_source.html">BinaryOperators.h</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix_1_1SMatrixRow.html">SMatrixRow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix_1_1SMatrixRow__const.html">SMatrixRow_const</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">--- Matrix dimension ---</div></td></tr>
<tr class="memitem:a0960735c8df52eebe3c358c98c98b566"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a0960735c8df52eebe3c358c98c98b566a8d0ebe2f70f4a30890b8008ce6d025b5">kRows</a> = D1, 
<a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a0960735c8df52eebe3c358c98c98b566a202c3ea3fad95f75f63749ac61f7feb9">kCols</a> = D2, 
<a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a0960735c8df52eebe3c358c98c98b566aafbc0e48b602ae3ef8ab06f3d5991a42">kSize</a> = D1*D2
 }</td></tr>
<tr class="memdesc:a0960735c8df52eebe3c358c98c98b566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration defining the matrix dimension, number of rows, columns and size = rows*columns)  <a href="classROOT_1_1Math_1_1SMatrix.html#a0960735c8df52eebe3c358c98c98b566">More...</a><br /></td></tr>
<tr class="separator:a0960735c8df52eebe3c358c98c98b566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">--- Typedefs ---</div></td></tr>
<tr class="memitem:aad926a0d28c0e08c5f3dd0519b65114f"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#aad926a0d28c0e08c5f3dd0519b65114f">value_type</a></td></tr>
<tr class="memdesc:aad926a0d28c0e08c5f3dd0519b65114f"><td class="mdescLeft">&#160;</td><td class="mdescRight">contained scalar type  <a href="#aad926a0d28c0e08c5f3dd0519b65114f">More...</a><br /></td></tr>
<tr class="separator:aad926a0d28c0e08c5f3dd0519b65114f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9c936465689f1856f5d7152ad155e1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a8f9c936465689f1856f5d7152ad155e1">rep_type</a></td></tr>
<tr class="memdesc:a8f9c936465689f1856f5d7152ad155e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">storage representation type  <a href="#a8f9c936465689f1856f5d7152ad155e1">More...</a><br /></td></tr>
<tr class="separator:a8f9c936465689f1856f5d7152ad155e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb42fc01bd537388c0fef8763107759"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a7bb42fc01bd537388c0fef8763107759">iterator</a></td></tr>
<tr class="memdesc:a7bb42fc01bd537388c0fef8763107759"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL iterator interface.  <a href="#a7bb42fc01bd537388c0fef8763107759">More...</a><br /></td></tr>
<tr class="separator:a7bb42fc01bd537388c0fef8763107759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc00045c357b418c7eb87528f5d0d0"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a7fdc00045c357b418c7eb87528f5d0d0">const_iterator</a></td></tr>
<tr class="memdesc:a7fdc00045c357b418c7eb87528f5d0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL const_iterator interface.  <a href="#a7fdc00045c357b418c7eb87528f5d0d0">More...</a><br /></td></tr>
<tr class="separator:a7fdc00045c357b418c7eb87528f5d0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">--- Constructors and Assignment ---</div></td></tr>
<tr class="memitem:a08dd2551bd253623ead2fd0d6da3759a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a08dd2551bd253623ead2fd0d6da3759a">SMatrix</a> ()</td></tr>
<tr class="memdesc:a08dd2551bd253623ead2fd0d6da3759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor:  <a href="#a08dd2551bd253623ead2fd0d6da3759a">More...</a><br /></td></tr>
<tr class="separator:a08dd2551bd253623ead2fd0d6da3759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a83528a1d1cdc7bdd6e5a963fc4c37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a51a83528a1d1cdc7bdd6e5a963fc4c37">SMatrix</a> (<a class="el" href="structROOT_1_1Math_1_1SMatrixNoInit.html">SMatrixNoInit</a>)</td></tr>
<tr class="memdesc:a51a83528a1d1cdc7bdd6e5a963fc4c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct from without initialization  <a href="#a51a83528a1d1cdc7bdd6e5a963fc4c37">More...</a><br /></td></tr>
<tr class="separator:a51a83528a1d1cdc7bdd6e5a963fc4c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df6776aa6bebdaddc929b2bee12c543"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a6df6776aa6bebdaddc929b2bee12c543">SMatrix</a> (<a class="el" href="structROOT_1_1Math_1_1SMatrixIdentity.html">SMatrixIdentity</a>)</td></tr>
<tr class="memdesc:a6df6776aa6bebdaddc929b2bee12c543"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct from an identity matrix  <a href="#a6df6776aa6bebdaddc929b2bee12c543">More...</a><br /></td></tr>
<tr class="separator:a6df6776aa6bebdaddc929b2bee12c543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da417b00942663614e8ed7e72d3e436"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a6da417b00942663614e8ed7e72d3e436">SMatrix</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6da417b00942663614e8ed7e72d3e436"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor (from a matrix of the same representation  <a href="#a6da417b00942663614e8ed7e72d3e436">More...</a><br /></td></tr>
<tr class="separator:a6da417b00942663614e8ed7e72d3e436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feb42b1be97de19489775613b1f0d17"><td class="memTemplParams" colspan="2">template&lt;class R2 &gt; </td></tr>
<tr class="memitem:a2feb42b1be97de19489775613b1f0d17"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a2feb42b1be97de19489775613b1f0d17">SMatrix</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2feb42b1be97de19489775613b1f0d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct from a matrix with different representation.  <a href="#a2feb42b1be97de19489775613b1f0d17">More...</a><br /></td></tr>
<tr class="separator:a2feb42b1be97de19489775613b1f0d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b28f023294a4dc7da43d1762c447a8"><td class="memTemplParams" colspan="2">template&lt;class A , class R2 &gt; </td></tr>
<tr class="memitem:a58b28f023294a4dc7da43d1762c447a8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a58b28f023294a4dc7da43d1762c447a8">SMatrix</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a58b28f023294a4dc7da43d1762c447a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an expression.  <a href="#a58b28f023294a4dc7da43d1762c447a8">More...</a><br /></td></tr>
<tr class="separator:a58b28f023294a4dc7da43d1762c447a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbceb96f790924be49c8e8f9d71b75ec"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:acbceb96f790924be49c8e8f9d71b75ec"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#acbceb96f790924be49c8e8f9d71b75ec">SMatrix</a> (InputIterator <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a431348cf487aeb3aa5434e8727e26035">begin</a>, InputIterator <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a17582c3665906858f124b6b325a0c9e5">end</a>, bool triang=false, bool lower=true)</td></tr>
<tr class="memdesc:acbceb96f790924be49c8e8f9d71b75ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with STL iterator interface.  <a href="#acbceb96f790924be49c8e8f9d71b75ec">More...</a><br /></td></tr>
<tr class="separator:acbceb96f790924be49c8e8f9d71b75ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a2cbb81550351c0e3dcdf5fe6a97ae"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ac3a2cbb81550351c0e3dcdf5fe6a97ae"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ac3a2cbb81550351c0e3dcdf5fe6a97ae">SMatrix</a> (InputIterator <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a431348cf487aeb3aa5434e8727e26035">begin</a>, unsigned int size, bool triang=false, bool lower=true)</td></tr>
<tr class="memdesc:ac3a2cbb81550351c0e3dcdf5fe6a97ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with STL iterator interface.  <a href="#ac3a2cbb81550351c0e3dcdf5fe6a97ae">More...</a><br /></td></tr>
<tr class="separator:ac3a2cbb81550351c0e3dcdf5fe6a97ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0960fd095fe1695095b6ef6913949cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#af0960fd095fe1695095b6ef6913949cb">SMatrix</a> (const <a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 *(D2+1)/2 &gt; &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>, bool lower=true)</td></tr>
<tr class="memdesc:af0960fd095fe1695095b6ef6913949cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor of a symmetrix a matrix from a <a class="el" href="classROOT_1_1Math_1_1SVector.html" title="SVector: a generic fixed size Vector class. ">SVector</a> containing the lower (upper) triangular part.  <a href="#af0960fd095fe1695095b6ef6913949cb">More...</a><br /></td></tr>
<tr class="separator:af0960fd095fe1695095b6ef6913949cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b06686b1f72a69de69c7b9f7b9ca76f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a8b06686b1f72a69de69c7b9f7b9ca76f">SMatrix</a> (const T &amp;rhs)</td></tr>
<tr class="memdesc:a8b06686b1f72a69de69c7b9f7b9ca76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a scalar value (only for size 1 matrices)  <a href="#a8b06686b1f72a69de69c7b9f7b9ca76f">More...</a><br /></td></tr>
<tr class="separator:a8b06686b1f72a69de69c7b9f7b9ca76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a81dbad7ead07d790b5f9e639fd4616"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a2a81dbad7ead07d790b5f9e639fd4616"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a2a81dbad7ead07d790b5f9e639fd4616">operator=</a> (const M &amp;rhs)</td></tr>
<tr class="memdesc:a2a81dbad7ead07d790b5f9e639fd4616"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structROOT_1_1Math_1_1Assign.html" title="Structure to assign from an expression based to general matrix to general matrix. ...">Assign</a> from another compatible matrix.  <a href="#a2a81dbad7ead07d790b5f9e639fd4616">More...</a><br /></td></tr>
<tr class="separator:a2a81dbad7ead07d790b5f9e639fd4616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfde9b2d1d1393e079891bbc2d3acd32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#adfde9b2d1d1393e079891bbc2d3acd32">operator=</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:adfde9b2d1d1393e079891bbc2d3acd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a05f52ab5b3442c76e2d7bab2a7472"><td class="memTemplParams" colspan="2">template&lt;class A , class R2 &gt; </td></tr>
<tr class="memitem:a98a05f52ab5b3442c76e2d7bab2a7472"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a98a05f52ab5b3442c76e2d7bab2a7472">operator=</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a98a05f52ab5b3442c76e2d7bab2a7472"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structROOT_1_1Math_1_1Assign.html" title="Structure to assign from an expression based to general matrix to general matrix. ...">Assign</a> from a matrix expression.  <a href="#a98a05f52ab5b3442c76e2d7bab2a7472">More...</a><br /></td></tr>
<tr class="separator:a98a05f52ab5b3442c76e2d7bab2a7472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e7c7d8fb1c5bd0ddee9c250ade932b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a76e7c7d8fb1c5bd0ddee9c250ade932b">operator=</a> (<a class="el" href="structROOT_1_1Math_1_1SMatrixIdentity.html">SMatrixIdentity</a>)</td></tr>
<tr class="memdesc:a76e7c7d8fb1c5bd0ddee9c250ade932b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structROOT_1_1Math_1_1Assign.html" title="Structure to assign from an expression based to general matrix to general matrix. ...">Assign</a> from an identity matrix.  <a href="#a76e7c7d8fb1c5bd0ddee9c250ade932b">More...</a><br /></td></tr>
<tr class="separator:a76e7c7d8fb1c5bd0ddee9c250ade932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba81ffd73e28a348de538e36a407df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#aaba81ffd73e28a348de538e36a407df7">operator=</a> (const T &amp;rhs)</td></tr>
<tr class="memdesc:aaba81ffd73e28a348de538e36a407df7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structROOT_1_1Math_1_1Assign.html" title="Structure to assign from an expression based to general matrix to general matrix. ...">Assign</a> from a scalar value (only for size 1 matrices)  <a href="#aaba81ffd73e28a348de538e36a407df7">More...</a><br /></td></tr>
<tr class="separator:aaba81ffd73e28a348de538e36a407df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">--- Access functions ---</div></td></tr>
<tr class="memitem:a09e49a437c30c94a3f82d5385fc21187"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a09e49a437c30c94a3f82d5385fc21187">apply</a> (unsigned int i) const</td></tr>
<tr class="memdesc:a09e49a437c30c94a3f82d5385fc21187"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the parse tree with the index starting from zero and following the C convention for the order in accessing the matrix elements.  <a href="#a09e49a437c30c94a3f82d5385fc21187">More...</a><br /></td></tr>
<tr class="separator:a09e49a437c30c94a3f82d5385fc21187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74968c69c9b11d74ca5a2bed25d447e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#af74968c69c9b11d74ca5a2bed25d447e">Array</a> () const</td></tr>
<tr class="memdesc:af74968c69c9b11d74ca5a2bed25d447e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return read-only pointer to internal array  <a href="#af74968c69c9b11d74ca5a2bed25d447e">More...</a><br /></td></tr>
<tr class="separator:af74968c69c9b11d74ca5a2bed25d447e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f6fdd555b062444d73c7bcd3badc5b"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a54f6fdd555b062444d73c7bcd3badc5b">Array</a> ()</td></tr>
<tr class="memdesc:a54f6fdd555b062444d73c7bcd3badc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return pointer to internal array  <a href="#a54f6fdd555b062444d73c7bcd3badc5b">More...</a><br /></td></tr>
<tr class="separator:a54f6fdd555b062444d73c7bcd3badc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">--- STL-like interface ---</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The iterators access the matrix element in the order how they are stored in memory.</p>
<p>The C (row-major) convention is used, and in the case of symmetric matrices the iterator spans only the lower diagonal block. For example for a symmetric 3x3 matrices the order of the 6 elements \({a_0,...a_5}\) is: </p><p class="formulaDsp">
\[ M = \left( \begin{array}{ccc} a_0 &amp; a_1 &amp; a_3 \\ a_1 &amp; a_2 &amp; a_4 \\ a_3 &amp; a_4 &amp; a_5 \end{array} \right) \]
</p>
 </div></td></tr>
<tr class="memitem:a431348cf487aeb3aa5434e8727e26035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a7bb42fc01bd537388c0fef8763107759">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a431348cf487aeb3aa5434e8727e26035">begin</a> ()</td></tr>
<tr class="memdesc:a431348cf487aeb3aa5434e8727e26035"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL iterator interface.  <a href="#a431348cf487aeb3aa5434e8727e26035">More...</a><br /></td></tr>
<tr class="separator:a431348cf487aeb3aa5434e8727e26035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17582c3665906858f124b6b325a0c9e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a7bb42fc01bd537388c0fef8763107759">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a17582c3665906858f124b6b325a0c9e5">end</a> ()</td></tr>
<tr class="memdesc:a17582c3665906858f124b6b325a0c9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL iterator interface.  <a href="#a17582c3665906858f124b6b325a0c9e5">More...</a><br /></td></tr>
<tr class="separator:a17582c3665906858f124b6b325a0c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4592e8af8311d1e9d9b67fd9c8c695ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a7fdc00045c357b418c7eb87528f5d0d0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a4592e8af8311d1e9d9b67fd9c8c695ab">begin</a> () const</td></tr>
<tr class="memdesc:a4592e8af8311d1e9d9b67fd9c8c695ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL const_iterator interface.  <a href="#a4592e8af8311d1e9d9b67fd9c8c695ab">More...</a><br /></td></tr>
<tr class="separator:a4592e8af8311d1e9d9b67fd9c8c695ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd0dcb45aa2bd356c565caef05f618e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a7fdc00045c357b418c7eb87528f5d0d0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#addd0dcb45aa2bd356c565caef05f618e">end</a> () const</td></tr>
<tr class="memdesc:addd0dcb45aa2bd356c565caef05f618e"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL const_iterator interface.  <a href="#addd0dcb45aa2bd356c565caef05f618e">More...</a><br /></td></tr>
<tr class="separator:addd0dcb45aa2bd356c565caef05f618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451dd6425ab554034ac0a288766a731f"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a451dd6425ab554034ac0a288766a731f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a451dd6425ab554034ac0a288766a731f">SetElements</a> (InputIterator <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a431348cf487aeb3aa5434e8727e26035">begin</a>, InputIterator <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a17582c3665906858f124b6b325a0c9e5">end</a>, bool triang=false, bool lower=true)</td></tr>
<tr class="memdesc:a451dd6425ab554034ac0a288766a731f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set matrix elements with STL iterator interface.  <a href="#a451dd6425ab554034ac0a288766a731f">More...</a><br /></td></tr>
<tr class="separator:a451dd6425ab554034ac0a288766a731f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f7fd80ed6adb2ae82f219bdb81d833"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a22f7fd80ed6adb2ae82f219bdb81d833"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a22f7fd80ed6adb2ae82f219bdb81d833">SetElements</a> (InputIterator <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a431348cf487aeb3aa5434e8727e26035">begin</a>, unsigned int size, bool triang=false, bool lower=true)</td></tr>
<tr class="memdesc:a22f7fd80ed6adb2ae82f219bdb81d833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with STL iterator interface.  <a href="#a22f7fd80ed6adb2ae82f219bdb81d833">More...</a><br /></td></tr>
<tr class="separator:a22f7fd80ed6adb2ae82f219bdb81d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">--- Operators ---</div></td></tr>
<tr class="memitem:a5b0e887c876cd49367eb1f566e2ae4cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a5b0e887c876cd49367eb1f566e2ae4cc">operator==</a> (const T &amp;rhs) const</td></tr>
<tr class="memdesc:a5b0e887c876cd49367eb1f566e2ae4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#a5b0e887c876cd49367eb1f566e2ae4cc">More...</a><br /></td></tr>
<tr class="separator:a5b0e887c876cd49367eb1f566e2ae4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1f76b952ca47f4364728a5e600414e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a6f1f76b952ca47f4364728a5e600414e">operator!=</a> (const T &amp;rhs) const</td></tr>
<tr class="memdesc:a6f1f76b952ca47f4364728a5e600414e"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#a6f1f76b952ca47f4364728a5e600414e">More...</a><br /></td></tr>
<tr class="separator:a6f1f76b952ca47f4364728a5e600414e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a9d96c3393b30697e8499b23465517"><td class="memTemplParams" colspan="2">template&lt;class R2 &gt; </td></tr>
<tr class="memitem:a39a9d96c3393b30697e8499b23465517"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a39a9d96c3393b30697e8499b23465517">operator==</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a39a9d96c3393b30697e8499b23465517"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#a39a9d96c3393b30697e8499b23465517">More...</a><br /></td></tr>
<tr class="separator:a39a9d96c3393b30697e8499b23465517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19f86128ee7911a7297f8f9bfe9c435"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ae19f86128ee7911a7297f8f9bfe9c435">operator!=</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ae19f86128ee7911a7297f8f9bfe9c435"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#ae19f86128ee7911a7297f8f9bfe9c435">More...</a><br /></td></tr>
<tr class="separator:ae19f86128ee7911a7297f8f9bfe9c435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7404db08b9b792fd269fdda83bacea1"><td class="memTemplParams" colspan="2">template&lt;class A , class R2 &gt; </td></tr>
<tr class="memitem:ad7404db08b9b792fd269fdda83bacea1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ad7404db08b9b792fd269fdda83bacea1">operator==</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ad7404db08b9b792fd269fdda83bacea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#ad7404db08b9b792fd269fdda83bacea1">More...</a><br /></td></tr>
<tr class="separator:ad7404db08b9b792fd269fdda83bacea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04e658b135ea77429a039535249a075"><td class="memTemplParams" colspan="2">template&lt;class A , class R2 &gt; </td></tr>
<tr class="memitem:ac04e658b135ea77429a039535249a075"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ac04e658b135ea77429a039535249a075">operator!=</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ac04e658b135ea77429a039535249a075"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#ac04e658b135ea77429a039535249a075">More...</a><br /></td></tr>
<tr class="separator:ac04e658b135ea77429a039535249a075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e7fa531332a9b2f03cb1fa18bfe3a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a24e7fa531332a9b2f03cb1fa18bfe3a0">operator&gt;</a> (const T &amp;rhs) const</td></tr>
<tr class="memdesc:a24e7fa531332a9b2f03cb1fa18bfe3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#a24e7fa531332a9b2f03cb1fa18bfe3a0">More...</a><br /></td></tr>
<tr class="separator:a24e7fa531332a9b2f03cb1fa18bfe3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393cc37d251d75c9baf11db325f299a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a393cc37d251d75c9baf11db325f299a2">operator&lt;</a> (const T &amp;rhs) const</td></tr>
<tr class="memdesc:a393cc37d251d75c9baf11db325f299a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#a393cc37d251d75c9baf11db325f299a2">More...</a><br /></td></tr>
<tr class="separator:a393cc37d251d75c9baf11db325f299a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05558faab334a9bd9b709ed87a392c4b"><td class="memTemplParams" colspan="2">template&lt;class R2 &gt; </td></tr>
<tr class="memitem:a05558faab334a9bd9b709ed87a392c4b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a05558faab334a9bd9b709ed87a392c4b">operator&gt;</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a05558faab334a9bd9b709ed87a392c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#a05558faab334a9bd9b709ed87a392c4b">More...</a><br /></td></tr>
<tr class="separator:a05558faab334a9bd9b709ed87a392c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecd28fa907b40e7eb32b8a7ee599386"><td class="memTemplParams" colspan="2">template&lt;class R2 &gt; </td></tr>
<tr class="memitem:aaecd28fa907b40e7eb32b8a7ee599386"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#aaecd28fa907b40e7eb32b8a7ee599386">operator&lt;</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:aaecd28fa907b40e7eb32b8a7ee599386"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#aaecd28fa907b40e7eb32b8a7ee599386">More...</a><br /></td></tr>
<tr class="separator:aaecd28fa907b40e7eb32b8a7ee599386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ef95c7302eb9de7c3fe7920d1e804a"><td class="memTemplParams" colspan="2">template&lt;class A , class R2 &gt; </td></tr>
<tr class="memitem:a20ef95c7302eb9de7c3fe7920d1e804a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a20ef95c7302eb9de7c3fe7920d1e804a">operator&gt;</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a20ef95c7302eb9de7c3fe7920d1e804a"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#a20ef95c7302eb9de7c3fe7920d1e804a">More...</a><br /></td></tr>
<tr class="separator:a20ef95c7302eb9de7c3fe7920d1e804a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc0130d668d302639121b74d15bd168"><td class="memTemplParams" colspan="2">template&lt;class A , class R2 &gt; </td></tr>
<tr class="memitem:a1cc0130d668d302639121b74d15bd168"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a1cc0130d668d302639121b74d15bd168">operator&lt;</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a1cc0130d668d302639121b74d15bd168"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise comparison  <a href="#a1cc0130d668d302639121b74d15bd168">More...</a><br /></td></tr>
<tr class="separator:a1cc0130d668d302639121b74d15bd168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71f5f5def880106118e5f8faf9cabb6"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ae71f5f5def880106118e5f8faf9cabb6">operator()</a> (unsigned int i, unsigned int j) const</td></tr>
<tr class="memdesc:ae71f5f5def880106118e5f8faf9cabb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">read only access to matrix element, with indices starting from 0  <a href="#ae71f5f5def880106118e5f8faf9cabb6">More...</a><br /></td></tr>
<tr class="separator:ae71f5f5def880106118e5f8faf9cabb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fbf4c2ce08d54c06a8320253bda279"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a91fbf4c2ce08d54c06a8320253bda279">operator()</a> (unsigned int i, unsigned int j)</td></tr>
<tr class="memdesc:a91fbf4c2ce08d54c06a8320253bda279"><td class="mdescLeft">&#160;</td><td class="mdescRight">read/write access to matrix element with indices starting from 0  <a href="#a91fbf4c2ce08d54c06a8320253bda279">More...</a><br /></td></tr>
<tr class="separator:a91fbf4c2ce08d54c06a8320253bda279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1784ee24c86184eb12ca8c2083e1c03e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a1784ee24c86184eb12ca8c2083e1c03e">At</a> (unsigned int i, unsigned int j) const</td></tr>
<tr class="memdesc:a1784ee24c86184eb12ca8c2083e1c03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">read only access to matrix element, with indices starting from 0.  <a href="#a1784ee24c86184eb12ca8c2083e1c03e">More...</a><br /></td></tr>
<tr class="separator:a1784ee24c86184eb12ca8c2083e1c03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f93a76cded3bef21974608d84769ac"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a81f93a76cded3bef21974608d84769ac">At</a> (unsigned int i, unsigned int j)</td></tr>
<tr class="memdesc:a81f93a76cded3bef21974608d84769ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">read/write access to matrix element with indices starting from 0.  <a href="#a81f93a76cded3bef21974608d84769ac">More...</a><br /></td></tr>
<tr class="separator:a81f93a76cded3bef21974608d84769ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce508cf841a965c270cb2827219e6ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix_1_1SMatrixRow__const.html">SMatrixRow_const</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a5ce508cf841a965c270cb2827219e6ab">operator[]</a> (unsigned int i) const</td></tr>
<tr class="memdesc:a5ce508cf841a965c270cb2827219e6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">read only access to matrix element, with indices starting from 0 : m[i][j]  <a href="#a5ce508cf841a965c270cb2827219e6ab">More...</a><br /></td></tr>
<tr class="separator:a5ce508cf841a965c270cb2827219e6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3065051e0eb8d084f4f2d0c11bf363a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix_1_1SMatrixRow.html">SMatrixRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a3065051e0eb8d084f4f2d0c11bf363a5">operator[]</a> (unsigned int i)</td></tr>
<tr class="memdesc:a3065051e0eb8d084f4f2d0c11bf363a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">read/write access to matrix element with indices starting from 0 : m[i][j]  <a href="#a3065051e0eb8d084f4f2d0c11bf363a5">More...</a><br /></td></tr>
<tr class="separator:a3065051e0eb8d084f4f2d0c11bf363a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d9f0a772ebb5877f1258ee9b8a51ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a83d9f0a772ebb5877f1258ee9b8a51ba">operator+=</a> (const T &amp;rhs)</td></tr>
<tr class="memdesc:a83d9f0a772ebb5877f1258ee9b8a51ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">addition with a scalar  <a href="#a83d9f0a772ebb5877f1258ee9b8a51ba">More...</a><br /></td></tr>
<tr class="separator:a83d9f0a772ebb5877f1258ee9b8a51ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64f9c42dc9d2652532b5e4ec95473e7"><td class="memTemplParams" colspan="2">template&lt;class R2 &gt; </td></tr>
<tr class="memitem:ac64f9c42dc9d2652532b5e4ec95473e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ac64f9c42dc9d2652532b5e4ec95473e7">operator+=</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac64f9c42dc9d2652532b5e4ec95473e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">addition with another matrix of any compatible representation  <a href="#ac64f9c42dc9d2652532b5e4ec95473e7">More...</a><br /></td></tr>
<tr class="separator:ac64f9c42dc9d2652532b5e4ec95473e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52400cf774ada04cecff0dabe815a67f"><td class="memTemplParams" colspan="2">template&lt;class A , class R2 &gt; </td></tr>
<tr class="memitem:a52400cf774ada04cecff0dabe815a67f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a52400cf774ada04cecff0dabe815a67f">operator+=</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a52400cf774ada04cecff0dabe815a67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">addition with a compatible matrix expression  <a href="#a52400cf774ada04cecff0dabe815a67f">More...</a><br /></td></tr>
<tr class="separator:a52400cf774ada04cecff0dabe815a67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b9ce490a41befc8ffed2c1bc10a314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a09b9ce490a41befc8ffed2c1bc10a314">operator-=</a> (const T &amp;rhs)</td></tr>
<tr class="memdesc:a09b9ce490a41befc8ffed2c1bc10a314"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction with a scalar  <a href="#a09b9ce490a41befc8ffed2c1bc10a314">More...</a><br /></td></tr>
<tr class="separator:a09b9ce490a41befc8ffed2c1bc10a314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c0eaf6620c4ac6b30cb8fcf3cccd52"><td class="memTemplParams" colspan="2">template&lt;class R2 &gt; </td></tr>
<tr class="memitem:ae5c0eaf6620c4ac6b30cb8fcf3cccd52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ae5c0eaf6620c4ac6b30cb8fcf3cccd52">operator-=</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae5c0eaf6620c4ac6b30cb8fcf3cccd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction with another matrix of any compatible representation  <a href="#ae5c0eaf6620c4ac6b30cb8fcf3cccd52">More...</a><br /></td></tr>
<tr class="separator:ae5c0eaf6620c4ac6b30cb8fcf3cccd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbe7dfadc595816575d00fe1680b905"><td class="memTemplParams" colspan="2">template&lt;class A , class R2 &gt; </td></tr>
<tr class="memitem:a1cbe7dfadc595816575d00fe1680b905"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a1cbe7dfadc595816575d00fe1680b905">operator-=</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1cbe7dfadc595816575d00fe1680b905"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction with a compatible matrix expression  <a href="#a1cbe7dfadc595816575d00fe1680b905">More...</a><br /></td></tr>
<tr class="separator:a1cbe7dfadc595816575d00fe1680b905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cbb50814e5fbb5d5360adfaa7eb315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a34cbb50814e5fbb5d5360adfaa7eb315">operator*=</a> (const T &amp;rhs)</td></tr>
<tr class="memdesc:a34cbb50814e5fbb5d5360adfaa7eb315"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with a scalar  <a href="#a34cbb50814e5fbb5d5360adfaa7eb315">More...</a><br /></td></tr>
<tr class="separator:a34cbb50814e5fbb5d5360adfaa7eb315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb6aa6c5a6a4ca897f0bd7e9a4f8704"><td class="memTemplParams" colspan="2">template&lt;class R2 &gt; </td></tr>
<tr class="memitem:a1cb6aa6c5a6a4ca897f0bd7e9a4f8704"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a1cb6aa6c5a6a4ca897f0bd7e9a4f8704">operator*=</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1cb6aa6c5a6a4ca897f0bd7e9a4f8704"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with another compatible matrix (it is a real matrix multiplication) Note that this operation does not avid to create a temporary to store intermidiate result  <a href="#a1cb6aa6c5a6a4ca897f0bd7e9a4f8704">More...</a><br /></td></tr>
<tr class="separator:a1cb6aa6c5a6a4ca897f0bd7e9a4f8704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff41847cbce49f4e20249eac6f0b7c68"><td class="memTemplParams" colspan="2">template&lt;class A , class R2 &gt; </td></tr>
<tr class="memitem:aff41847cbce49f4e20249eac6f0b7c68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#aff41847cbce49f4e20249eac6f0b7c68">operator*=</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aff41847cbce49f4e20249eac6f0b7c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with a compatible matrix expression (it is a real matrix multiplication)  <a href="#aff41847cbce49f4e20249eac6f0b7c68">More...</a><br /></td></tr>
<tr class="separator:aff41847cbce49f4e20249eac6f0b7c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9443e578f09c4d7a2310a3c740fd06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a9c9443e578f09c4d7a2310a3c740fd06">operator/=</a> (const T &amp;rhs)</td></tr>
<tr class="memdesc:a9c9443e578f09c4d7a2310a3c740fd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">division with a scalar  <a href="#a9c9443e578f09c4d7a2310a3c740fd06">More...</a><br /></td></tr>
<tr class="separator:a9c9443e578f09c4d7a2310a3c740fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">--- Linear Algebra Functions ---</div></td></tr>
<tr class="memitem:a860e14ec714dc67aad64758cf6724b38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a860e14ec714dc67aad64758cf6724b38">Invert</a> ()</td></tr>
<tr class="memdesc:a860e14ec714dc67aad64758cf6724b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a square Matrix ( this method changes the current matrix).  <a href="#a860e14ec714dc67aad64758cf6724b38">More...</a><br /></td></tr>
<tr class="separator:a860e14ec714dc67aad64758cf6724b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302763072163e5e521a8efd8e69a6f81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a302763072163e5e521a8efd8e69a6f81">Inverse</a> (int &amp;ifail) const</td></tr>
<tr class="memdesc:a302763072163e5e521a8efd8e69a6f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a square Matrix and returns a new matrix.  <a href="#a302763072163e5e521a8efd8e69a6f81">More...</a><br /></td></tr>
<tr class="separator:a302763072163e5e521a8efd8e69a6f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f5f0e064dc750cdfbebca15e2a6cc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ab0f5f0e064dc750cdfbebca15e2a6cc1">InvertFast</a> ()</td></tr>
<tr class="memdesc:ab0f5f0e064dc750cdfbebca15e2a6cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Invertion of a square Matrix ( this method changes the current matrix).  <a href="#ab0f5f0e064dc750cdfbebca15e2a6cc1">More...</a><br /></td></tr>
<tr class="separator:ab0f5f0e064dc750cdfbebca15e2a6cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5348787866b46aec8d35f7d6609eaab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a5348787866b46aec8d35f7d6609eaab3">InverseFast</a> (int &amp;ifail) const</td></tr>
<tr class="memdesc:a5348787866b46aec8d35f7d6609eaab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a square Matrix and returns a new matrix.  <a href="#a5348787866b46aec8d35f7d6609eaab3">More...</a><br /></td></tr>
<tr class="separator:a5348787866b46aec8d35f7d6609eaab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ed11f42c544e9263709bce51acc23d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a85ed11f42c544e9263709bce51acc23d">InvertChol</a> ()</td></tr>
<tr class="memdesc:a85ed11f42c544e9263709bce51acc23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invertion of a symmetric positive defined Matrix using Choleski decomposition.  <a href="#a85ed11f42c544e9263709bce51acc23d">More...</a><br /></td></tr>
<tr class="separator:a85ed11f42c544e9263709bce51acc23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b8fe3fa6d362faf3bcb626fbc87266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a63b8fe3fa6d362faf3bcb626fbc87266">InverseChol</a> (int &amp;ifail) const</td></tr>
<tr class="memdesc:a63b8fe3fa6d362faf3bcb626fbc87266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert of a symmetric positive defined Matrix using Choleski decomposition.  <a href="#a63b8fe3fa6d362faf3bcb626fbc87266">More...</a><br /></td></tr>
<tr class="separator:a63b8fe3fa6d362faf3bcb626fbc87266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e78b4fc9919f0744cec9c29ec0a9e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a21e78b4fc9919f0744cec9c29ec0a9e0">Det</a> (T &amp;det)</td></tr>
<tr class="memdesc:a21e78b4fc9919f0744cec9c29ec0a9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">determinant of square Matrix via Dfact.  <a href="#a21e78b4fc9919f0744cec9c29ec0a9e0">More...</a><br /></td></tr>
<tr class="separator:a21e78b4fc9919f0744cec9c29ec0a9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3dc4563a82371f5ca3d92e96ea6618"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a0e3dc4563a82371f5ca3d92e96ea6618">Det2</a> (T &amp;det) const</td></tr>
<tr class="memdesc:a0e3dc4563a82371f5ca3d92e96ea6618"><td class="mdescLeft">&#160;</td><td class="mdescRight">determinant of square Matrix via Dfact.  <a href="#a0e3dc4563a82371f5ca3d92e96ea6618">More...</a><br /></td></tr>
<tr class="separator:a0e3dc4563a82371f5ca3d92e96ea6618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">--- Matrix Slice Functions ---</div></td></tr>
<tr class="memitem:a5fd60abc34126c6b64b3faa70bb077ae"><td class="memTemplParams" colspan="2">template&lt;unsigned int D&gt; </td></tr>
<tr class="memitem:a5fd60abc34126c6b64b3faa70bb077ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a5fd60abc34126c6b64b3faa70bb077ae">Place_in_row</a> (const <a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D &gt; &amp;rhs, unsigned int row, unsigned int col)</td></tr>
<tr class="memdesc:a5fd60abc34126c6b64b3faa70bb077ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">place a vector in a Matrix row  <a href="#a5fd60abc34126c6b64b3faa70bb077ae">More...</a><br /></td></tr>
<tr class="separator:a5fd60abc34126c6b64b3faa70bb077ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb213811eb5ffe2eadd36e74f2894924"><td class="memTemplParams" colspan="2">template&lt;class A , unsigned int D&gt; </td></tr>
<tr class="memitem:abb213811eb5ffe2eadd36e74f2894924"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#abb213811eb5ffe2eadd36e74f2894924">Place_in_row</a> (const <a class="el" href="classROOT_1_1Math_1_1VecExpr.html">VecExpr</a>&lt; A, T, D &gt; &amp;rhs, unsigned int row, unsigned int col)</td></tr>
<tr class="memdesc:abb213811eb5ffe2eadd36e74f2894924"><td class="mdescLeft">&#160;</td><td class="mdescRight">place a vector expression in a Matrix row  <a href="#abb213811eb5ffe2eadd36e74f2894924">More...</a><br /></td></tr>
<tr class="separator:abb213811eb5ffe2eadd36e74f2894924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd1b5b6c2d2a04223aa72af5e6571ba"><td class="memTemplParams" colspan="2">template&lt;unsigned int D&gt; </td></tr>
<tr class="memitem:afdd1b5b6c2d2a04223aa72af5e6571ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#afdd1b5b6c2d2a04223aa72af5e6571ba">Place_in_col</a> (const <a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D &gt; &amp;rhs, unsigned int row, unsigned int col)</td></tr>
<tr class="memdesc:afdd1b5b6c2d2a04223aa72af5e6571ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">place a vector in a Matrix column  <a href="#afdd1b5b6c2d2a04223aa72af5e6571ba">More...</a><br /></td></tr>
<tr class="separator:afdd1b5b6c2d2a04223aa72af5e6571ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd22aa1d078e3fa26629f73ae940040e"><td class="memTemplParams" colspan="2">template&lt;class A , unsigned int D&gt; </td></tr>
<tr class="memitem:afd22aa1d078e3fa26629f73ae940040e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#afd22aa1d078e3fa26629f73ae940040e">Place_in_col</a> (const <a class="el" href="classROOT_1_1Math_1_1VecExpr.html">VecExpr</a>&lt; A, T, D &gt; &amp;rhs, unsigned int row, unsigned int col)</td></tr>
<tr class="memdesc:afd22aa1d078e3fa26629f73ae940040e"><td class="mdescLeft">&#160;</td><td class="mdescRight">place a vector expression in a Matrix column  <a href="#afd22aa1d078e3fa26629f73ae940040e">More...</a><br /></td></tr>
<tr class="separator:afd22aa1d078e3fa26629f73ae940040e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5c156b06cc270a8170b8931ac868fa"><td class="memTemplParams" colspan="2">template&lt;unsigned int D3, unsigned int D4, class R2 &gt; </td></tr>
<tr class="memitem:a2b5c156b06cc270a8170b8931ac868fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a2b5c156b06cc270a8170b8931ac868fa">Place_at</a> (const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D3, D4, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs, unsigned int row, unsigned int col)</td></tr>
<tr class="memdesc:a2b5c156b06cc270a8170b8931ac868fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">place a matrix in this matrix  <a href="#a2b5c156b06cc270a8170b8931ac868fa">More...</a><br /></td></tr>
<tr class="separator:a2b5c156b06cc270a8170b8931ac868fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96705ac5626264fd8cd06bdb155a220"><td class="memTemplParams" colspan="2">template&lt;class A , unsigned int D3, unsigned int D4, class R2 &gt; </td></tr>
<tr class="memitem:ac96705ac5626264fd8cd06bdb155a220"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ac96705ac5626264fd8cd06bdb155a220">Place_at</a> (const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D3, D4, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;rhs, unsigned int row, unsigned int col)</td></tr>
<tr class="memdesc:ac96705ac5626264fd8cd06bdb155a220"><td class="mdescLeft">&#160;</td><td class="mdescRight">place a matrix expression in this matrix  <a href="#ac96705ac5626264fd8cd06bdb155a220">More...</a><br /></td></tr>
<tr class="separator:ac96705ac5626264fd8cd06bdb155a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea64e96dd7e3fb981a360d0c8fee75af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#aea64e96dd7e3fb981a360d0c8fee75af">Row</a> (unsigned int therow) const</td></tr>
<tr class="memdesc:aea64e96dd7e3fb981a360d0c8fee75af"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a full Matrix row as a vector (copy the content in a new vector)  <a href="#aea64e96dd7e3fb981a360d0c8fee75af">More...</a><br /></td></tr>
<tr class="separator:aea64e96dd7e3fb981a360d0c8fee75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00db819ce7ace5a0f99a0e401def59a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a00db819ce7ace5a0f99a0e401def59a9">Col</a> (unsigned int thecol) const</td></tr>
<tr class="memdesc:a00db819ce7ace5a0f99a0e401def59a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a full Matrix column as a vector (copy the content in a new vector)  <a href="#a00db819ce7ace5a0f99a0e401def59a9">More...</a><br /></td></tr>
<tr class="separator:a00db819ce7ace5a0f99a0e401def59a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada143f4cd090cbc85c1dd00c4bf5ec3d"><td class="memTemplParams" colspan="2">template&lt;class SubVector &gt; </td></tr>
<tr class="memitem:ada143f4cd090cbc85c1dd00c4bf5ec3d"><td class="memTemplItemLeft" align="right" valign="top">SubVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ada143f4cd090cbc85c1dd00c4bf5ec3d">SubRow</a> (unsigned int therow, unsigned int col0=0) const</td></tr>
<tr class="memdesc:ada143f4cd090cbc85c1dd00c4bf5ec3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a slice of therow as a vector starting at the colum value col0 until col0+N, where N is the size of the vector (SubVector::kSize ) Condition col0+N &lt;= D2  <a href="#ada143f4cd090cbc85c1dd00c4bf5ec3d">More...</a><br /></td></tr>
<tr class="separator:ada143f4cd090cbc85c1dd00c4bf5ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d1702fdfa8fb8775b9fd5d5c4a6531"><td class="memTemplParams" colspan="2">template&lt;class SubVector &gt; </td></tr>
<tr class="memitem:a23d1702fdfa8fb8775b9fd5d5c4a6531"><td class="memTemplItemLeft" align="right" valign="top">SubVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a23d1702fdfa8fb8775b9fd5d5c4a6531">SubCol</a> (unsigned int thecol, unsigned int row0=0) const</td></tr>
<tr class="memdesc:a23d1702fdfa8fb8775b9fd5d5c4a6531"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a slice of the column as a vector starting at the row value row0 until row0+Dsub.  <a href="#a23d1702fdfa8fb8775b9fd5d5c4a6531">More...</a><br /></td></tr>
<tr class="separator:a23d1702fdfa8fb8775b9fd5d5c4a6531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3456d9f21c7e28e674a397ae6b7e24e2"><td class="memTemplParams" colspan="2">template&lt;class SubMatrix &gt; </td></tr>
<tr class="memitem:a3456d9f21c7e28e674a397ae6b7e24e2"><td class="memTemplItemLeft" align="right" valign="top">SubMatrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a3456d9f21c7e28e674a397ae6b7e24e2">Sub</a> (unsigned int row0, unsigned int col0) const</td></tr>
<tr class="memdesc:a3456d9f21c7e28e674a397ae6b7e24e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a submatrix with the upper left corner at the values (row0, col0) and with sizes N1, N2 where N1 and N2 are the dimension of the sub-matrix (SubMatrix::kRows and SubMatrix::kCols ) Condition row0+N1 &lt;= D1 &amp;&amp; col0+N2 &lt;=D2  <a href="#a3456d9f21c7e28e674a397ae6b7e24e2">More...</a><br /></td></tr>
<tr class="separator:a3456d9f21c7e28e674a397ae6b7e24e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6136d68a2289b921a19e81a231b9a85b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a6136d68a2289b921a19e81a231b9a85b">Diagonal</a> () const</td></tr>
<tr class="memdesc:a6136d68a2289b921a19e81a231b9a85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return diagonal elements of a matrix as a Vector.  <a href="#a6136d68a2289b921a19e81a231b9a85b">More...</a><br /></td></tr>
<tr class="separator:a6136d68a2289b921a19e81a231b9a85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667f6fde244b957e9027747421f73f00"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a667f6fde244b957e9027747421f73f00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a667f6fde244b957e9027747421f73f00">SetDiagonal</a> (const Vector &amp;<a class="el" href="Dict_8h.html#ae4dfd0ff80708edc0ec19fe36e65d9a7">v</a>)</td></tr>
<tr class="memdesc:a667f6fde244b957e9027747421f73f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the diagonal elements from a Vector Require that vector implements <a class="el" href="TStructNode_8h.html#a1946a4629dc0c855b358be489581aa78a69e8ce9b71e061cf72667e7ff70ca699">kSize</a> since a check (statically) is done on diagonal size == vector size.  <a href="#a667f6fde244b957e9027747421f73f00">More...</a><br /></td></tr>
<tr class="separator:a667f6fde244b957e9027747421f73f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a272630d53729a527787b086484ad5"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ac6a272630d53729a527787b086484ad5">Trace</a> () const</td></tr>
<tr class="memdesc:ac6a272630d53729a527787b086484ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the trace of a matrix Sum of the diagonal elements  <a href="#ac6a272630d53729a527787b086484ad5">More...</a><br /></td></tr>
<tr class="separator:ac6a272630d53729a527787b086484ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103b09a3c037a061d386899546da9ab0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 *(D2+1)/2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a103b09a3c037a061d386899546da9ab0">UpperBlock</a> () const</td></tr>
<tr class="memdesc:a103b09a3c037a061d386899546da9ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the upper Triangular block of the matrices (including the diagonal) as a vector of sizes N = D1 * (D1 + 1)/2.  <a href="#a103b09a3c037a061d386899546da9ab0">More...</a><br /></td></tr>
<tr class="separator:a103b09a3c037a061d386899546da9ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27b797648f4153bece5f5ef3b840a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 *(D2+1)/2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ab27b797648f4153bece5f5ef3b840a5d">LowerBlock</a> () const</td></tr>
<tr class="memdesc:ab27b797648f4153bece5f5ef3b840a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the lower Triangular block of the matrices (including the diagonal) as a vector of sizes N = D1 * (D1 + 1)/2.  <a href="#ab27b797648f4153bece5f5ef3b840a5d">More...</a><br /></td></tr>
<tr class="separator:ab27b797648f4153bece5f5ef3b840a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">--- Other Functions ---</div></td></tr>
<tr class="memitem:a8aab3ad36a0d36fbf664b866bb3c5df7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a8aab3ad36a0d36fbf664b866bb3c5df7">IsInUse</a> (const T *p) const</td></tr>
<tr class="memdesc:a8aab3ad36a0d36fbf664b866bb3c5df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if a matrix is sharing same memory location of the passed pointer This function is used by the expression templates to avoid the alias problem during expression evaluation.  <a href="#a8aab3ad36a0d36fbf664b866bb3c5df7">More...</a><br /></td></tr>
<tr class="separator:a8aab3ad36a0d36fbf664b866bb3c5df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ca07fd4724a1fa57fdf7d40a4773f9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a28ca07fd4724a1fa57fdf7d40a4773f9">Print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a28ca07fd4724a1fa57fdf7d40a4773f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print: used by <a class="el" href="namespaceROOT_1_1Math.html#a0aebfc90d2cfdbf1ee78a6cc61fc0bf2" title="Stream Output and Input. ">operator&lt;&lt;()</a>  <a href="#a28ca07fd4724a1fa57fdf7d40a4773f9">More...</a><br /></td></tr>
<tr class="separator:a28ca07fd4724a1fa57fdf7d40a4773f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">--- Data Member ---</div></td></tr>
<tr class="memitem:a47b4028ee04d5b904772da560be12b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a47b4028ee04d5b904772da560be12b64">fRep</a></td></tr>
<tr class="memdesc:a47b4028ee04d5b904772da560be12b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix Storage Object containing matrix data.  <a href="#a47b4028ee04d5b904772da560be12b64">More...</a><br /></td></tr>
<tr class="separator:a47b4028ee04d5b904772da560be12b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

<p><code>#include &lt;<a class="el" href="BinaryOperators_8h_source.html">Math/BinaryOperators.h</a>&gt;</code></p>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7fdc00045c357b418c7eb87528f5d0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdc00045c357b418c7eb87528f5d0d0">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a7fdc00045c357b418c7eb87528f5d0d0">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STL const_iterator interface. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8h_source.html#l00138">138</a> of file <a class="el" href="SMatrix_8h_source.html">SMatrix.h</a>.</p>

</div>
</div>
<a id="a7bb42fc01bd537388c0fef8763107759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb42fc01bd537388c0fef8763107759">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a7bb42fc01bd537388c0fef8763107759">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STL iterator interface. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8h_source.html#l00135">135</a> of file <a class="el" href="SMatrix_8h_source.html">SMatrix.h</a>.</p>

</div>
</div>
<a id="a8f9c936465689f1856f5d7152ad155e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9c936465689f1856f5d7152ad155e1">&#9670;&nbsp;</a></span>rep_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a8f9c936465689f1856f5d7152ad155e1">rep_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>storage representation type </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8h_source.html#l00132">132</a> of file <a class="el" href="SMatrix_8h_source.html">SMatrix.h</a>.</p>

</div>
</div>
<a id="aad926a0d28c0e08c5f3dd0519b65114f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad926a0d28c0e08c5f3dd0519b65114f">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html#aad926a0d28c0e08c5f3dd0519b65114f">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>contained scalar type </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8h_source.html#l00129">129</a> of file <a class="el" href="SMatrix_8h_source.html">SMatrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0960735c8df52eebe3c358c98c98b566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0960735c8df52eebe3c358c98c98b566">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration defining the matrix dimension, number of rows, columns and size = rows*columns) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0960735c8df52eebe3c358c98c98b566a8d0ebe2f70f4a30890b8008ce6d025b5"></a>kRows&#160;</td><td class="fielddoc"><p>return no. of matrix rows </p>
</td></tr>
<tr><td class="fieldname"><a id="a0960735c8df52eebe3c358c98c98b566a202c3ea3fad95f75f63749ac61f7feb9"></a>kCols&#160;</td><td class="fielddoc"><p>return no. of matrix columns </p>
</td></tr>
<tr><td class="fieldname"><a id="a0960735c8df52eebe3c358c98c98b566aafbc0e48b602ae3ef8ab06f3d5991a42"></a>kSize&#160;</td><td class="fielddoc"><p>return no of elements: rows*columns </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SMatrix_8h_source.html#l00257">257</a> of file <a class="el" href="SMatrix_8h_source.html">SMatrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a08dd2551bd253623ead2fd0d6da3759a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dd2551bd253623ead2fd0d6da3759a">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor: </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00072">72</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a51a83528a1d1cdc7bdd6e5a963fc4c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a83528a1d1cdc7bdd6e5a963fc4c37">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structROOT_1_1Math_1_1SMatrixNoInit.html">SMatrixNoInit</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct from without initialization </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8h_source.html#l00152">152</a> of file <a class="el" href="SMatrix_8h_source.html">SMatrix.h</a>.</p>

</div>
</div>
<a id="a6df6776aa6bebdaddc929b2bee12c543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df6776aa6bebdaddc929b2bee12c543">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structROOT_1_1Math_1_1SMatrixIdentity.html">SMatrixIdentity</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct from an identity matrix </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00079">79</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a6da417b00942663614e8ed7e72d3e436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da417b00942663614e8ed7e72d3e436">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy constructor (from a matrix of the same representation </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00093">93</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a2feb42b1be97de19489775613b1f0d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2feb42b1be97de19489775613b1f0d17">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct from a matrix with different representation. </p>
<p>Works only from symmetric to general and not viceversa. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00100">100</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a58b28f023294a4dc7da43d1762c447a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b28f023294a4dc7da43d1762c447a8">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from an expression. </p>
<p>In case of symmetric matrices does not work if expression is of type general matrices. In case one needs to force the assignment from general to symmetric, one can use the <a class="el" href="structROOT_1_1Math_1_1AssignSym.html#a3eefce80c2b47a4d8b76c1b0bf87f3c7" title="assign a symmetric matrix from an expression ">ROOT::Math::AssignSym::Evaluate</a> function. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00107">107</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="acbceb96f790924be49c8e8f9d71b75ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbceb96f790924be49c8e8f9d71b75ec">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>triang</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lower</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with STL iterator interface. </p>
<p>The data will be copied into the matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>start iterator position </td></tr>
    <tr><td class="paramname">end</td><td>end iterator position </td></tr>
    <tr><td class="paramname">triang</td><td>if true only the triangular lower/upper part of the matrix is filled from the iterators </td></tr>
    <tr><td class="paramname">lower</td><td>if true the lower triangular part is filled</td></tr>
  </table>
  </dd>
</dl>
<p>Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the triangular block. In the case of symmetric matrices triang is considered always to be true (what-ever the user specifies) and the size of the iterators must be equal to the size of the triangular block, which is the number of independent elements of a symmetric matrix: N*(N+1)/2 </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00117">117</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ac3a2cbb81550351c0e3dcdf5fe6a97ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a2cbb81550351c0e3dcdf5fe6a97ae">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>triang</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lower</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with STL iterator interface. </p>
<p>The data will be copied into the matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>start iterator position </td></tr>
    <tr><td class="paramname">size</td><td>iterator size </td></tr>
    <tr><td class="paramname">triang</td><td>if true only the triangular lower/upper part of the matrix is filled from the iterators </td></tr>
    <tr><td class="paramname">lower</td><td>if true the lower triangular part is filled</td></tr>
  </table>
  </dd>
</dl>
<p>Size of the iterators must not be larger than the size of the matrix representation. In the case of symmetric matrices the size is N*(N+1)/2. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00125">125</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="af0960fd095fe1695095b6ef6913949cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0960fd095fe1695095b6ef6913949cb">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 *(D2+1)/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lower</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor of a symmetrix a matrix from a <a class="el" href="classROOT_1_1Math_1_1SVector.html" title="SVector: a generic fixed size Vector class. ">SVector</a> containing the lower (upper) triangular part. </p>
<p>construct from upper/lower block </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00858">858</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a8b06686b1f72a69de69c7b9f7b9ca76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b06686b1f72a69de69c7b9f7b9ca76f">&#9670;&nbsp;</a></span>SMatrix() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a scalar value (only for size 1 matrices) </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00138">138</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a09e49a437c30c94a3f82d5385fc21187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e49a437c30c94a3f82d5385fc21187">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the parse tree with the index starting from zero and following the C convention for the order in accessing the matrix elements. </p>
<p>Same convention for general and symmetric matrices. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00627">627</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="af74968c69c9b11d74ca5a2bed25d447e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74968c69c9b11d74ca5a2bed25d447e">&#9670;&nbsp;</a></span>Array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return read-only pointer to internal array </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00630">630</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a54f6fdd555b062444d73c7bcd3badc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f6fdd555b062444d73c7bcd3badc5b">&#9670;&nbsp;</a></span>Array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return pointer to internal array </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00633">633</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a1784ee24c86184eb12ca8c2083e1c03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1784ee24c86184eb12ca8c2083e1c03e">&#9670;&nbsp;</a></span>At() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::At </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read only access to matrix element, with indices starting from 0. </p>
<p>Function will check index values and it will assert if they are wrong </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00653">653</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a81f93a76cded3bef21974608d84769ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f93a76cded3bef21974608d84769ac">&#9670;&nbsp;</a></span>At() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::At </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read/write access to matrix element with indices starting from 0. </p>
<p>Function will check index values and it will assert if they are wrong </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00660">660</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a431348cf487aeb3aa5434e8727e26035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431348cf487aeb3aa5434e8727e26035">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL iterator interface. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00670">670</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a4592e8af8311d1e9d9b67fd9c8c695ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4592e8af8311d1e9d9b67fd9c8c695ab">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL const_iterator interface. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00680">680</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a00db819ce7ace5a0f99a0e401def59a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00db819ce7ace5a0f99a0e401def59a9">&#9670;&nbsp;</a></span>Col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 &gt; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Col </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thecol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a full Matrix column as a vector (copy the content in a new vector) </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00590">590</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a21e78b4fc9919f0744cec9c29ec0a9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e78b4fc9919f0744cec9c29ec0a9e0">&#9670;&nbsp;</a></span>Det()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Det </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>det</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determinant of square Matrix via Dfact. </p>
<p>Return true when the calculation is successfull. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">det</td><td>will contain the calculated determinant value <b>Note:</b> this will destroy the contents of the Matrix! </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00466">466</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a0e3dc4563a82371f5ca3d92e96ea6618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3dc4563a82371f5ca3d92e96ea6618">&#9670;&nbsp;</a></span>Det2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Det2 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>det</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determinant of square Matrix via Dfact. </p>
<p>Return true when the calculation is successfull. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">det</td><td>will contain the calculated determinant value <b>Note:</b> this will preserve the content of the Matrix! </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00473">473</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a6136d68a2289b921a19e81a231b9a85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6136d68a2289b921a19e81a231b9a85b">&#9670;&nbsp;</a></span>Diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 &gt; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return diagonal elements of a matrix as a Vector. </p>
<p>It works only for squared matrices D1 == D2, otherwise it will produce a compile error </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00755">755</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a17582c3665906858f124b6b325a0c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17582c3665906858f124b6b325a0c9e5">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL iterator interface. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00675">675</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="addd0dcb45aa2bd356c565caef05f618e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd0dcb45aa2bd356c565caef05f618e">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL const_iterator interface. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00685">685</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a302763072163e5e521a8efd8e69a6f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302763072163e5e521a8efd8e69a6f81">&#9670;&nbsp;</a></span>Inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Inverse </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ifail</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert a square Matrix and returns a new matrix. </p>
<p>In case the inversion fails the current matrix is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ifail</td><td>. ifail will be set to 0 when inversion is successfull. See <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a860e14ec714dc67aad64758cf6724b38" title="Invert a square Matrix ( this method changes the current matrix). ">ROOT::Math::SMatrix::Invert</a> for the inversion algorithm </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00419">419</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a63b8fe3fa6d362faf3bcb626fbc87266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b8fe3fa6d362faf3bcb626fbc87266">&#9670;&nbsp;</a></span>InverseChol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::InverseChol </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ifail</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert of a symmetric positive defined Matrix using Choleski decomposition. </p>
<p>A compile error is given if the matrix is not of type symmetric and a run-time failure if the matrix is not positive defined. In case the inversion fails the current matrix is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ifail</td><td>. ifail will be set to 0 when inversion is successfull. See <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a85ed11f42c544e9263709bce51acc23d" title="Invertion of a symmetric positive defined Matrix using Choleski decomposition. ">ROOT::Math::SMatrix::InvertChol</a> for the inversion algorithm </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00452">452</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a5348787866b46aec8d35f7d6609eaab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5348787866b46aec8d35f7d6609eaab3">&#9670;&nbsp;</a></span>InverseFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::InverseFast </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ifail</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert a square Matrix and returns a new matrix. </p>
<p>In case the inversion fails the current matrix is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ifail</td><td>. ifail will be set to 0 when inversion is successfull. See <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#ab0f5f0e064dc750cdfbebca15e2a6cc1" title="Fast Invertion of a square Matrix ( this method changes the current matrix). ">ROOT::Math::SMatrix::InvertFast</a> for the inversion algorithm </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00436">436</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a860e14ec714dc67aad64758cf6724b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e14ec714dc67aad64758cf6724b38">&#9670;&nbsp;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert a square Matrix ( this method changes the current matrix). </p>
<p>Return true if inversion is successfull. The method used for general square matrices is the LU factorization taken from Dinv routine from the CERNLIB (written in C++ from CLHEP authors) In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used (The implementation is the one written by the CLHEP authors) </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00412">412</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a85ed11f42c544e9263709bce51acc23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ed11f42c544e9263709bce51acc23d">&#9670;&nbsp;</a></span>InvertChol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::InvertChol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invertion of a symmetric positive defined Matrix using Choleski decomposition. </p>
<p>( this method changes the current matrix). Return true if inversion is successfull. The method used is based on Choleski decomposition A compile error is given if the matrix is not of type symmetric and a run-time failure if the matrix is not positive defined. For solving a linear system, it is possible to use also the function ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00446">446</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ab0f5f0e064dc750cdfbebca15e2a6cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f5f0e064dc750cdfbebca15e2a6cc1">&#9670;&nbsp;</a></span>InvertFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::InvertFast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast Invertion of a square Matrix ( this method changes the current matrix). </p>
<p>Return true if inversion is successfull. The method used is based on direct inversion using the Cramer rule for matrices upto 5x5. Afterwards the same default algorithm of <a class="el" href="classROOT_1_1Math_1_1SMatrix.html#a860e14ec714dc67aad64758cf6724b38" title="Invert a square Matrix ( this method changes the current matrix). ">Invert()</a> is used. Note that this method is faster but can suffer from much larger numerical accuracy when the condition of the matrix is large </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00429">429</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a8aab3ad36a0d36fbf664b866bb3c5df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aab3ad36a0d36fbf664b866bb3c5df7">&#9670;&nbsp;</a></span>IsInUse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::IsInUse </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if a matrix is sharing same memory location of the passed pointer This function is used by the expression templates to avoid the alias problem during expression evaluation. </p>
<p>When the matrix is in use, for example in operations like A = B * A, a temporary object storing the intermediate result is automatically created when evaluating the expression. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00895">895</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ab27b797648f4153bece5f5ef3b840a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27b797648f4153bece5f5ef3b840a5d">&#9670;&nbsp;</a></span>LowerBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 *(D2+1)/2 &gt; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::LowerBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the lower Triangular block of the matrices (including the diagonal) as a vector of sizes N = D1 * (D1 + 1)/2. </p>
<p>It works only for square matrices with D1==D2, otherwise it will produce a compile error </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00826">826</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a6f1f76b952ca47f4364728a5e600414e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1f76b952ca47f4364728a5e600414e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="TCut_8cxx.html#a41eff35811213263b65ac1ae507222e4">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00327">327</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ae19f86128ee7911a7297f8f9bfe9c435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19f86128ee7911a7297f8f9bfe9c435">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="TCut_8cxx.html#a41eff35811213263b65ac1ae507222e4">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00332">332</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ac04e658b135ea77429a039535249a075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04e658b135ea77429a039535249a075">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::<a class="el" href="TCut_8cxx.html#a41eff35811213263b65ac1ae507222e4">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00338">338</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ae71f5f5def880106118e5f8faf9cabb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71f5f5def880106118e5f8faf9cabb6">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read only access to matrix element, with indices starting from 0 </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00639">639</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a91fbf4c2ce08d54c06a8320253bda279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fbf4c2ce08d54c06a8320253bda279">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read/write access to matrix element with indices starting from 0 </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00644">644</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a34cbb50814e5fbb5d5360adfaa7eb315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cbb50814e5fbb5d5360adfaa7eb315">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiplication with a scalar </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00258">258</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a1cb6aa6c5a6a4ca897f0bd7e9a4f8704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb6aa6c5a6a4ca897f0bd7e9a4f8704">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiplication with another compatible matrix (it is a real matrix multiplication) Note that this operation does not avid to create a temporary to store intermidiate result </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00268">268</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="aff41847cbce49f4e20249eac6f0b7c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff41847cbce49f4e20249eac6f0b7c68">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiplication with a compatible matrix expression (it is a real matrix multiplication) </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00276">276</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a83d9f0a772ebb5877f1258ee9b8a51ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d9f0a772ebb5877f1258ee9b8a51ba">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>addition with a scalar </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00197">197</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ac64f9c42dc9d2652532b5e4ec95473e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64f9c42dc9d2652532b5e4ec95473e7">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>addition with another matrix of any compatible representation </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00207">207</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a52400cf774ada04cecff0dabe815a67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52400cf774ada04cecff0dabe815a67f">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>addition with a compatible matrix expression </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00217">217</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a09b9ce490a41befc8ffed2c1bc10a314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b9ce490a41befc8ffed2c1bc10a314">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>subtraction with a scalar </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00228">228</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ae5c0eaf6620c4ac6b30cb8fcf3cccd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c0eaf6620c4ac6b30cb8fcf3cccd52">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>subtraction with another matrix of any compatible representation </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00238">238</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a1cbe7dfadc595816575d00fe1680b905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbe7dfadc595816575d00fe1680b905">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>subtraction with a compatible matrix expression </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00248">248</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a9c9443e578f09c4d7a2310a3c740fd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9443e578f09c4d7a2310a3c740fd06">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>division with a scalar </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00287">287</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a393cc37d251d75c9baf11db325f299a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393cc37d251d75c9baf11db325f299a2">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00379">379</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="aaecd28fa907b40e7eb32b8a7ee599386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecd28fa907b40e7eb32b8a7ee599386">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00389">389</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a1cc0130d668d302639121b74d15bd168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc0130d668d302639121b74d15bd168">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00399">399</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a2a81dbad7ead07d790b5f9e639fd4616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a81dbad7ead07d790b5f9e639fd4616">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structROOT_1_1Math_1_1Assign.html" title="Structure to assign from an expression based to general matrix to general matrix. ...">Assign</a> from another compatible matrix. </p>
<p>Possible Symmetirc to general but NOT vice-versa </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00155">155</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="adfde9b2d1d1393e079891bbc2d3acd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfde9b2d1d1393e079891bbc2d3acd32">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00161">161</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a98a05f52ab5b3442c76e2d7bab2a7472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a05f52ab5b3442c76e2d7bab2a7472">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structROOT_1_1Math_1_1Assign.html" title="Structure to assign from an expression based to general matrix to general matrix. ...">Assign</a> from a matrix expression. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00168">168</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a76e7c7d8fb1c5bd0ddee9c250ade932b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e7c7d8fb1c5bd0ddee9c250ade932b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structROOT_1_1Math_1_1SMatrixIdentity.html">SMatrixIdentity</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structROOT_1_1Math_1_1Assign.html" title="Structure to assign from an expression based to general matrix to general matrix. ...">Assign</a> from an identity matrix. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00177">177</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="aaba81ffd73e28a348de538e36a407df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba81ffd73e28a348de538e36a407df7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structROOT_1_1Math_1_1Assign.html" title="Structure to assign from an expression based to general matrix to general matrix. ...">Assign</a> from a scalar value (only for size 1 matrices) </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00144">144</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a5b0e887c876cd49367eb1f566e2ae4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0e887c876cd49367eb1f566e2ae4cc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00299">299</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a39a9d96c3393b30697e8499b23465517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a9d96c3393b30697e8499b23465517">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00309">309</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ad7404db08b9b792fd269fdda83bacea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7404db08b9b792fd269fdda83bacea1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00315">315</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a24e7fa531332a9b2f03cb1fa18bfe3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e7fa531332a9b2f03cb1fa18bfe3a0">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00347">347</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a05558faab334a9bd9b709ed87a392c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05558faab334a9bd9b709ed87a392c4b">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00357">357</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a20ef95c7302eb9de7c3fe7920d1e804a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ef95c7302eb9de7c3fe7920d1e804a">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D1, D2, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise comparison </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00367">367</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a5ce508cf841a965c270cb2827219e6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce508cf841a965c270cb2827219e6ab">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix_1_1SMatrixRow__const.html">SMatrixRow_const</a> <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read only access to matrix element, with indices starting from 0 : m[i][j] </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8h_source.html#l00421">421</a> of file <a class="el" href="SMatrix_8h_source.html">SMatrix.h</a>.</p>

</div>
</div>
<a id="a3065051e0eb8d084f4f2d0c11bf363a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3065051e0eb8d084f4f2d0c11bf363a5">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix_1_1SMatrixRow.html">SMatrixRow</a> <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read/write access to matrix element with indices starting from 0 : m[i][j] </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8h_source.html#l00425">425</a> of file <a class="el" href="SMatrix_8h_source.html">SMatrix.h</a>.</p>

</div>
</div>
<a id="a2b5c156b06cc270a8170b8931ac868fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5c156b06cc270a8170b8931ac868fa">&#9670;&nbsp;</a></span>Place_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;unsigned int D3, unsigned int D4, class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Place_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D3, D4, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>place a matrix in this matrix </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00552">552</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ac96705ac5626264fd8cd06bdb155a220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96705ac5626264fd8cd06bdb155a220">&#9670;&nbsp;</a></span>Place_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A, unsigned int D3, unsigned int D4, class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Place_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1Expr.html">Expr</a>&lt; A, T, D3, D4, <a class="el" href="sha1_8inl.html#a774229b80509be0e9e0a1d9819580224">R2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>place a matrix expression in this matrix </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00564">564</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="afdd1b5b6c2d2a04223aa72af5e6571ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd1b5b6c2d2a04223aa72af5e6571ba">&#9670;&nbsp;</a></span>Place_in_col() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;unsigned int D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Place_in_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>place a vector in a Matrix column </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00518">518</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="afd22aa1d078e3fa26629f73ae940040e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd22aa1d078e3fa26629f73ae940040e">&#9670;&nbsp;</a></span>Place_in_col() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A, unsigned int D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Place_in_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1VecExpr.html">VecExpr</a>&lt; A, T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>place a vector expression in a Matrix column </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00535">535</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a5fd60abc34126c6b64b3faa70bb077ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd60abc34126c6b64b3faa70bb077ae">&#9670;&nbsp;</a></span>Place_in_row() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;unsigned int D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Place_in_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>place a vector in a Matrix row </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00484">484</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="abb213811eb5ffe2eadd36e74f2894924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb213811eb5ffe2eadd36e74f2894924">&#9670;&nbsp;</a></span>Place_in_row() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class A, unsigned int D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SMatrix.html">SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt; &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Place_in_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classROOT_1_1Math_1_1VecExpr.html">VecExpr</a>&lt; A, T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>place a vector expression in a Matrix row </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00501">501</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a28ca07fd4724a1fa57fdf7d40a4773f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ca07fd4724a1fa57fdf7d40a4773f9">&#9670;&nbsp;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print: used by <a class="el" href="namespaceROOT_1_1Math.html#a0aebfc90d2cfdbf1ee78a6cc61fc0bf2" title="Stream Output and Input. ">operator&lt;&lt;()</a> </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00603">603</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="aea64e96dd7e3fb981a360d0c8fee75af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea64e96dd7e3fb981a360d0c8fee75af">&#9670;&nbsp;</a></span>Row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D2 &gt; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Row </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>therow</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a full Matrix row as a vector (copy the content in a new vector) </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00575">575</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a667f6fde244b957e9027747421f73f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667f6fde244b957e9027747421f73f00">&#9670;&nbsp;</a></span>SetDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a> <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::SetDiagonal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the diagonal elements from a Vector Require that vector implements <a class="el" href="TStructNode_8h.html#a1946a4629dc0c855b358be489581aa78a69e8ce9b71e061cf72667e7ff70ca699">kSize</a> since a check (statically) is done on diagonal size == vector size. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00770">770</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a451dd6425ab554034ac0a288766a731f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451dd6425ab554034ac0a288766a731f">&#9670;&nbsp;</a></span>SetElements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a> <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::SetElements </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>triang</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lower</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set matrix elements with STL iterator interface. </p>
<p>The data will be copied into the matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>start iterator position </td></tr>
    <tr><td class="paramname">end</td><td>end iterator position </td></tr>
    <tr><td class="paramname">triang</td><td>if true only the triangular lower/upper part of the matrix is filled from the iterators </td></tr>
    <tr><td class="paramname">lower</td><td>if true the lower triangular part is filled</td></tr>
  </table>
  </dd>
</dl>
<p>Size of the matrix must match size of the iterators, if triang is false, otherwise the size of the triangular block. In the case of symmetric matrices triang is considered always to be true (what-ever the user specifies) and the size of the iterators must be equal to the size of the triangular block, which is the number of independent elements of a symmetric matrix: N*(N+1)/2 </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00692">692</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a22f7fd80ed6adb2ae82f219bdb81d833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f7fd80ed6adb2ae82f219bdb81d833">&#9670;&nbsp;</a></span>SetElements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="TSystem_8h.html#a48a4b7a430b095306ef0a70bcbdaa63b">void</a> <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::SetElements </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>triang</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lower</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with STL iterator interface. </p>
<p>The data will be copied into the matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>start iterator position </td></tr>
    <tr><td class="paramname">size</td><td>iterator size </td></tr>
    <tr><td class="paramname">triang</td><td>if true only the triangular lower/upper part of the matrix is filled from the iterators </td></tr>
    <tr><td class="paramname">lower</td><td>if true the lower triangular part is filled</td></tr>
  </table>
  </dd>
</dl>
<p>Size of the iterators must not be larger than the size of the matrix representation. In the case of symmetric matrices the size is N*(N+1)/2. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00699">699</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a3456d9f21c7e28e674a397ae6b7e24e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3456d9f21c7e28e674a397ae6b7e24e2">&#9670;&nbsp;</a></span>Sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class SubMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubMatrix <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Sub </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a submatrix with the upper left corner at the values (row0, col0) and with sizes N1, N2 where N1 and N2 are the dimension of the sub-matrix (SubMatrix::kRows and SubMatrix::kCols ) Condition row0+N1 &lt;= D1 &amp;&amp; col0+N2 &lt;=D2 </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00745">745</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a23d1702fdfa8fb8775b9fd5d5c4a6531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d1702fdfa8fb8775b9fd5d5c4a6531">&#9670;&nbsp;</a></span>SubCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class SubVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubVector <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::SubCol </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thecol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row0</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a slice of the column as a vector starting at the row value row0 until row0+Dsub. </p>
<p>where N is the size of the vector (SubVector::kSize ) Condition row0+N &lt;= D1 </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00728">728</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ada143f4cd090cbc85c1dd00c4bf5ec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada143f4cd090cbc85c1dd00c4bf5ec3d">&#9670;&nbsp;</a></span>SubRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
<div class="memtemplate">
template&lt;class SubVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubVector <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::SubRow </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>therow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col0</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a slice of therow as a vector starting at the colum value col0 until col0+N, where N is the size of the vector (SubVector::kSize ) Condition col0+N &lt;= D2 </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00712">712</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="ac6a272630d53729a527787b086484ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a272630d53729a527787b086484ad5">&#9670;&nbsp;</a></span>Trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::Trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the trace of a matrix Sum of the diagonal elements </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00784">784</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<a id="a103b09a3c037a061d386899546da9ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103b09a3c037a061d386899546da9ab0">&#9670;&nbsp;</a></span>UpperBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int D1, unsigned int D2, class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROOT_1_1Math_1_1SVector.html">SVector</a>&lt; T, D1 *(D2+1)/2 &gt; <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::UpperBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the upper Triangular block of the matrices (including the diagonal) as a vector of sizes N = D1 * (D1 + 1)/2. </p>
<p>It works only for square matrices with D1==D2, otherwise it will produce a compile error </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8icc_source.html#l00797">797</a> of file <a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a47b4028ee04d5b904772da560be12b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b4028ee04d5b904772da560be12b64">&#9670;&nbsp;</a></span>fRep</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStd&lt;T, D1, D2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> <a class="el" href="classROOT_1_1Math_1_1SMatrix.html">ROOT::Math::SMatrix</a>&lt; T, D1, D2, <a class="el" href="RSha256_8hxx.html#ae076917a1bc8cbea6ed0af47d7c897fe">R</a> &gt;::fRep</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix Storage Object containing matrix data. </p>

<p class="definition">Definition at line <a class="el" href="SMatrix_8h_source.html#l00709">709</a> of file <a class="el" href="SMatrix_8h_source.html">SMatrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>math/smatrix/inc/Math/<a class="el" href="BinaryOperators_8h_source.html">BinaryOperators.h</a></li>
<li>math/smatrix/inc/Math/<a class="el" href="SMatrix_8h_source.html">SMatrix.h</a></li>
<li>math/smatrix/inc/Math/<a class="el" href="SMatrix_8icc_source.html">SMatrix.icc</a></li>
</ul>
</div><!-- contents -->
<html>
<body>
<div id="footer" style="background-color:#E5EBF3;">
<small>
<img class="footer" src="rootlogo_s.gif" alt="root"/></a>
ROOT 6.18/03 - Reference Guide Generated on Thu Aug 29 2019 04:11:57 (GVA Time) using Doxygen 1.8.14.
</small>
</div>
</body>
</html>
